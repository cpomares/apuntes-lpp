



<!doctype html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copiar al portapapeles">
      
        <meta name="lang:clipboard.copied" content="Copiado al portapapeles">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No se encontraron documentos">
      
        <meta name="lang:search.result.one" content="1 documento encontrado">
      
        <meta name="lang:search.result.other" content="# documentos encontrados">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.1.1">
    
    
      
        <title>Tema 6: Programación OO con Swift - LPP</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.3020aac5.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.224b79ff.css">
      
      
        
        
        <meta name="theme-color" content="#009688">
      
    
    
      <script src="../../assets/javascripts/modernizr.01ccdecf.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="teal" data-md-color-accent="teal">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#tema-6-programacion-orientada-a-objetos-con-swift" tabindex="1" class="md-skip">
        Saltar a contenido
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="LPP" class="md-header-nav__button md-logo">
          
            <img src="../../imagenes/logo.png" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              LPP
            </span>
            <span class="md-header-nav__topic">
              Tema 6: Programación OO con Swift
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Teclee para comenzar búsqueda
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="LPP" class="md-nav__button md-logo">
      
        <img src="../../imagenes/logo.png" width="48" height="48">
      
    </a>
    LPP
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1" checked>
    
    <label class="md-nav__link" for="nav-1">
      Teoría
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        Teoría
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../tema00-descripcion-asignatura/tema00-descripcion-asignatura.html" title="Descripción de la asignatura" class="md-nav__link">
      Descripción de la asignatura
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html" title="Tema 1: Historia de los lenguajes de programación" class="md-nav__link">
      Tema 1: Historia de los lenguajes de programación
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema02-programacion-funcional/tema02-programacion-funcional.html" title="Tema 2: Programación funcional" class="md-nav__link">
      Tema 2: Programación funcional
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html" title="Tema 3: Procedimientos recursivos" class="md-nav__link">
      Tema 3: Procedimientos recursivos
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema04-estructuras-recursivas/tema04-estructuras-recursivas.html" title="Tema 4: Estructuras recursivas" class="md-nav__link">
      Tema 4: Estructuras recursivas
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html" title="Tema 5: Programación funcional con Swift" class="md-nav__link">
      Tema 5: Programación funcional con Swift
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Tema 6: Programación OO con Swift
      </label>
    
    <a href="tema06-programacion-orientada-objetos-swift.html" title="Tema 6: Programación OO con Swift" class="md-nav__link md-nav__link--active">
      Tema 6: Programación OO con Swift
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#mas-conceptos-sobre-clausuras" title="Más conceptos sobre clausuras" class="md-nav__link">
    Más conceptos sobre clausuras
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#repaso-de-clausuras" title="Repaso de clausuras" class="md-nav__link">
    Repaso de clausuras
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clausuras-escapadas" title="Clausuras escapadas" class="md-nav__link">
    Clausuras escapadas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#autoclausuras" title="Autoclausuras" class="md-nav__link">
    Autoclausuras
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#introduccion-historia-y-caracteristicas-de-la-programacion-orientada-a-objetos" title="Introducción, historia y características de la Programación Orientada a Objetos" class="md-nav__link">
    Introducción, historia y características de la Programación Orientada a Objetos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#nacimiento" title="Nacimiento" class="md-nav__link">
    Nacimiento
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alan-kay" title="Alan Kay" class="md-nav__link">
    Alan Kay
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#interesados-en-smalltalk" title="¿Interesados en Smalltalk?" class="md-nav__link">
    ¿Interesados en Smalltalk?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lenguajes-oo" title="Lenguajes OO" class="md-nav__link">
    Lenguajes OO
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#del-paradigma-imperativo-al-oo" title="Del paradigma imperativo al OO" class="md-nav__link">
    Del paradigma imperativo al OO
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#caracteristicas-de-la-poo" title="Características de la POO" class="md-nav__link">
    Características de la POO
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clases-y-objetos" title="Clases y objetos" class="md-nav__link">
    Clases y objetos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lenguajes-poo-dinamicos-vs-estaticos" title="Lenguajes POO dinámicos vs. estáticos" class="md-nav__link">
    Lenguajes POO dinámicos vs. estáticos
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#clases-y-estructuras" title="Clases y estructuras" class="md-nav__link">
    Clases y estructuras
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#definicion" title="Definición" class="md-nav__link">
    Definición
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instancias-de-clases-y-estructuras" title="Instancias de clases y estructuras" class="md-nav__link">
    Instancias de clases y estructuras
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#acceso-a-propiedades" title="Acceso a propiedades" class="md-nav__link">
    Acceso a propiedades
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inicializacion-de-las-estructuras-por-sus-propiedades" title="Inicialización de las estructuras por sus propiedades" class="md-nav__link">
    Inicialización de las estructuras por sus propiedades
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estructuras-y-enumeraciones-son-tipos-valor" title="Estructuras y enumeraciones son tipos valor" class="md-nav__link">
    Estructuras y enumeraciones son tipos valor
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#las-clases-son-tipos-referencia" title="Las clases son tipos referencia" class="md-nav__link">
    Las clases son tipos referencia
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#declaracion-de-instancias-con-let" title="Declaración de instancias con let" class="md-nav__link">
    Declaración de instancias con let
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operadores-de-identidad" title="Operadores de identidad" class="md-nav__link">
    Operadores de identidad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#criterios-para-usar-estructuras-y-clases" title="Criterios para usar estructuras y clases" class="md-nav__link">
    Criterios para usar estructuras y clases
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#propiedades" title="Propiedades" class="md-nav__link">
    Propiedades
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#propiedades-almacenadas" title="Propiedades almacenadas" class="md-nav__link">
    Propiedades almacenadas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#propiedades-calculadas" title="Propiedades calculadas" class="md-nav__link">
    Propiedades calculadas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#propiedades-solo-lectura" title="Propiedades solo-lectura" class="md-nav__link">
    Propiedades solo-lectura
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#observadores-de-propiedades" title="Observadores de propiedades" class="md-nav__link">
    Observadores de propiedades
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#variables-locales-y-globales" title="Variables locales y globales" class="md-nav__link">
    Variables locales y globales
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#propiedades-del-tipo" title="Propiedades del tipo" class="md-nav__link">
    Propiedades del tipo
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#metodos" title="Métodos" class="md-nav__link">
    Métodos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#metodos-de-instancia" title="Métodos de instancia" class="md-nav__link">
    Métodos de instancia
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nombres-locales-y-externos-de-parametros" title="Nombres locales y externos de parámetros" class="md-nav__link">
    Nombres locales y externos de parámetros
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#la-propiedad-self" title="La propiedad self" class="md-nav__link">
    La propiedad self
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operaciones-con-instancias-de-tipo-valor" title="Operaciones con instancias de tipo valor" class="md-nav__link">
    Operaciones con instancias de tipo valor
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modificacion-de-tipos-valor-desde-dentro-de-la-instancia" title="Modificación de tipos valor desde dentro de la instancia" class="md-nav__link">
    Modificación de tipos valor desde dentro de la instancia
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asignacion-a-self-en-un-metodo-mutador" title="Asignación a self en un método mutador" class="md-nav__link">
    Asignación a self en un método mutador
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#metodos-del-tipo" title="Métodos del tipo" class="md-nav__link">
    Métodos del tipo
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Seminarios
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Seminarios
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../seminarios/seminario1-scheme/seminario1-scheme.html" title="Seminario de Scheme" class="md-nav__link">
      Seminario de Scheme
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../seminarios/seminario2-swift/seminario2-swift.html" title="Seminario de Swift" class="md-nav__link">
      Seminario de Swift
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      Prácticas
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Prácticas
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica01/practica01.html" title="Práctica 1" class="md-nav__link">
      Práctica 1
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica02/practica02.html" title="Práctica 2" class="md-nav__link">
      Práctica 2
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica03/practica03.html" title="Práctica 3" class="md-nav__link">
      Práctica 3
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica04/practica04.html" title="Práctica 4" class="md-nav__link">
      Práctica 4
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica05/practica05.html" title="Práctica 5" class="md-nav__link">
      Práctica 5
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica06/practica06.html" title="Práctica 6" class="md-nav__link">
      Práctica 6
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica07/practica07.html" title="Práctica 7" class="md-nav__link">
      Práctica 7
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica08/practica08.html" title="Práctica 8" class="md-nav__link">
      Práctica 8
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica09/practica09.html" title="Práctica 9" class="md-nav__link">
      Práctica 9
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#mas-conceptos-sobre-clausuras" title="Más conceptos sobre clausuras" class="md-nav__link">
    Más conceptos sobre clausuras
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#repaso-de-clausuras" title="Repaso de clausuras" class="md-nav__link">
    Repaso de clausuras
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clausuras-escapadas" title="Clausuras escapadas" class="md-nav__link">
    Clausuras escapadas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#autoclausuras" title="Autoclausuras" class="md-nav__link">
    Autoclausuras
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#introduccion-historia-y-caracteristicas-de-la-programacion-orientada-a-objetos" title="Introducción, historia y características de la Programación Orientada a Objetos" class="md-nav__link">
    Introducción, historia y características de la Programación Orientada a Objetos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#nacimiento" title="Nacimiento" class="md-nav__link">
    Nacimiento
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alan-kay" title="Alan Kay" class="md-nav__link">
    Alan Kay
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#interesados-en-smalltalk" title="¿Interesados en Smalltalk?" class="md-nav__link">
    ¿Interesados en Smalltalk?
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lenguajes-oo" title="Lenguajes OO" class="md-nav__link">
    Lenguajes OO
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#del-paradigma-imperativo-al-oo" title="Del paradigma imperativo al OO" class="md-nav__link">
    Del paradigma imperativo al OO
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#caracteristicas-de-la-poo" title="Características de la POO" class="md-nav__link">
    Características de la POO
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clases-y-objetos" title="Clases y objetos" class="md-nav__link">
    Clases y objetos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lenguajes-poo-dinamicos-vs-estaticos" title="Lenguajes POO dinámicos vs. estáticos" class="md-nav__link">
    Lenguajes POO dinámicos vs. estáticos
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#clases-y-estructuras" title="Clases y estructuras" class="md-nav__link">
    Clases y estructuras
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#definicion" title="Definición" class="md-nav__link">
    Definición
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instancias-de-clases-y-estructuras" title="Instancias de clases y estructuras" class="md-nav__link">
    Instancias de clases y estructuras
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#acceso-a-propiedades" title="Acceso a propiedades" class="md-nav__link">
    Acceso a propiedades
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inicializacion-de-las-estructuras-por-sus-propiedades" title="Inicialización de las estructuras por sus propiedades" class="md-nav__link">
    Inicialización de las estructuras por sus propiedades
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estructuras-y-enumeraciones-son-tipos-valor" title="Estructuras y enumeraciones son tipos valor" class="md-nav__link">
    Estructuras y enumeraciones son tipos valor
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#las-clases-son-tipos-referencia" title="Las clases son tipos referencia" class="md-nav__link">
    Las clases son tipos referencia
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#declaracion-de-instancias-con-let" title="Declaración de instancias con let" class="md-nav__link">
    Declaración de instancias con let
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operadores-de-identidad" title="Operadores de identidad" class="md-nav__link">
    Operadores de identidad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#criterios-para-usar-estructuras-y-clases" title="Criterios para usar estructuras y clases" class="md-nav__link">
    Criterios para usar estructuras y clases
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#propiedades" title="Propiedades" class="md-nav__link">
    Propiedades
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#propiedades-almacenadas" title="Propiedades almacenadas" class="md-nav__link">
    Propiedades almacenadas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#propiedades-calculadas" title="Propiedades calculadas" class="md-nav__link">
    Propiedades calculadas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#propiedades-solo-lectura" title="Propiedades solo-lectura" class="md-nav__link">
    Propiedades solo-lectura
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#observadores-de-propiedades" title="Observadores de propiedades" class="md-nav__link">
    Observadores de propiedades
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#variables-locales-y-globales" title="Variables locales y globales" class="md-nav__link">
    Variables locales y globales
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#propiedades-del-tipo" title="Propiedades del tipo" class="md-nav__link">
    Propiedades del tipo
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#metodos" title="Métodos" class="md-nav__link">
    Métodos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#metodos-de-instancia" title="Métodos de instancia" class="md-nav__link">
    Métodos de instancia
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nombres-locales-y-externos-de-parametros" title="Nombres locales y externos de parámetros" class="md-nav__link">
    Nombres locales y externos de parámetros
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#la-propiedad-self" title="La propiedad self" class="md-nav__link">
    La propiedad self
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#operaciones-con-instancias-de-tipo-valor" title="Operaciones con instancias de tipo valor" class="md-nav__link">
    Operaciones con instancias de tipo valor
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modificacion-de-tipos-valor-desde-dentro-de-la-instancia" title="Modificación de tipos valor desde dentro de la instancia" class="md-nav__link">
    Modificación de tipos valor desde dentro de la instancia
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#asignacion-a-self-en-un-metodo-mutador" title="Asignación a self en un método mutador" class="md-nav__link">
    Asignación a self en un método mutador
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#metodos-del-tipo" title="Métodos del tipo" class="md-nav__link">
    Métodos del tipo
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <!--

Para el curso que viene:
 - Incluir modificador 'opcional' en protocolos

Cosas importantes que no contamos, que habría que contar (si hubiera 
tiempo en la última sesión):

- Un protocolo puede extender otro protocolo (o más de uno)
https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID280

- Ampliar el tema de genéricos con type constraints y cláusula where

-->

<h1 id="tema-6-programacion-orientada-a-objetos-con-swift">Tema 6: Programación Orientada a Objetos con Swift<a class="headerlink" href="#tema-6-programacion-orientada-a-objetos-con-swift" title="Permanent link">&para;</a></h1>
<h2 id="mas-conceptos-sobre-clausuras">Más conceptos sobre clausuras<a class="headerlink" href="#mas-conceptos-sobre-clausuras" title="Permanent link">&para;</a></h2>
<h3 id="repaso-de-clausuras">Repaso de clausuras<a class="headerlink" href="#repaso-de-clausuras" title="Permanent link">&para;</a></h3>
<p>Ya vimos en el tema anterior que las clausuras en Swift son bloques de
código con funcionalidades que se pueden pasar de un sitio a otro en
nuestro programa. Son muy similares a las expresiones lambda de Scheme
o de Java 8 o a los bloques de Objective-C. Una clausura puede
capturar o almacenar referencias a cualquier constante o variable del
contexto o ámbito dentro de la cual han sido definidas.</p>
<p>Se pueden definir clausuras en Swift de las siguientes formas:</p>
<ul>
<li>Funciones anidadas que pueden capturar valores de la función englobante:</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">construyeFunc</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">0</span>
   <span class="kd">func</span> <span class="nf">funcion</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
      <span class="n">x</span> <span class="p">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="k">return</span> <span class="n">x</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="n">funcion</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">f</span> <span class="p">=</span> <span class="n">construyeFunc</span><span class="p">()</span>
<span class="n">f</span><span class="p">()</span> <span class="c1">// -&gt; 1</span>
<span class="n">f</span><span class="p">()</span> <span class="c1">// -&gt; 2</span>
</pre></div>
</td></tr></table>

<p>La función devuelta por <code>construyeFunc()</code> también se puede formular
como una expresión de clausura:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">construyeFunc</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">0</span>
   <span class="k">return</span> <span class="p">{</span>
      <span class="n">x</span> <span class="p">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="k">return</span> <span class="n">x</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>En el siguiente ejemplo vemos claramente que la función captura las
variables definidas en el ámbito en el que se creó. En el caso
anterior la clausura devuelta captura la variable <code>x</code> con el valor 0.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">usaFunc</span><span class="p">(</span><span class="kc">_</span> <span class="n">f</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
     <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">4</span>
     <span class="k">return</span> <span class="n">f</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">f</span> <span class="p">=</span> <span class="n">construyeFunc</span><span class="p">()</span>
<span class="n">usaFunc</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="c1">// -&gt; 1</span>
</pre></div>
</td></tr></table>

<p>El valor devuelto por <code>usaFunc</code> el el resultado de la invocación a
<code>f()</code> en su segunda línea de código. Y el valor de <code>x</code> usado por la
clausura <code>f</code> es el capturado en el momento de su creación (el valor
<code>x=0</code> definido en la primera línea de <code>construyeFunc</code>).</p>
<ul>
<li>Funciones anónimas que pueden capturar valores del contexto que las rodean:</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">100</span>
<span class="n">usaFunc</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">10</span><span class="p">}</span> <span class="c1">// -&gt; 110</span>
</pre></div>
</td></tr></table>

<p>En el ejemplo anterior la expresión de clausura se define en el ámbito
global donde la <code>x</code>toma el valor 100. Ese valor queda capturado y es
el que se usa en la evaluación de la función. Por tanto, en el
contexto donde se evalúa esa clausura (dentro del cuerpo de la
funcioón <code>usaFunc</code>), la <code>x</code>que toma es la capturada y no la definida
en el cuerpo de <code>usaFunc</code>.</p>
<h3 id="clausuras-escapadas">Clausuras escapadas<a class="headerlink" href="#clausuras-escapadas" title="Permanent link">&para;</a></h3>
<p>Se dice que una clausura escapa de una función cuando la función
recibe una función o clausura como parámetro que se llama después de
que la función finalice su ejecución.</p>
<p>Por ejemplo, definimos un array global de tipo función:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">array</span> <span class="p">:</span> <span class="p">[()</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span>
</pre></div>
</td></tr></table>

<p>Definimos una función que recibe una clausura como parámetro, pero no
se llama dentro de la función que la recibe, sólo la almacena en el
array. Al no ser llamada dentro de la función, hay que ponerle el
atributo <code>@escaping</code> delante del tipo del parámetro para que Swift
permita que sea llamada posteriormente fuera de la función que la
recibe. Si no lo ponemos, el compilador da un error:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">usaClausura</span><span class="p">(</span><span class="kc">_</span> <span class="n">f</span><span class="p">:</span> <span class="p">@</span><span class="n">escaping</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Void</span> <span class="p">{</span>
   <span class="n">array</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">usaClausura</span> <span class="p">{</span><span class="k">return</span> <span class="mi">4</span><span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Se llama posteriormente, fuera de la función:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]()</span> <span class="c1">//-&gt; 4</span>
</pre></div>
</td></tr></table>

<h3 id="autoclausuras">Autoclausuras<a class="headerlink" href="#autoclausuras" title="Permanent link">&para;</a></h3>
<p>Una autoclausura permite crear automáticamente una función en tiempo
de ejecución sin necesidad de utilizar la sintaxis de las expresiones
de clausura.</p>
<p>Se puede ver la autoclausura como una forma de retardar la evaluación,
porque esa expresión no se evaluará hasta que se llame a la
clausura. Retardar la evaluación es útil con trozos de código que
provocan efectos laterales o son costosos computacionalmente, ya que
nos permiten controlar el momento de su evaluación.</p>
<p>Por ejemplo, podemos modificar la función anterior <code>usaFunc</code> añadiendo
la anotación <code>@autoclosure</code> antes del tipo del parámetro clausura:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">usaFunc</span><span class="p">(</span><span class="kc">_</span> <span class="n">f</span><span class="p">:</span> <span class="kr">@autoclosure</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
     <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">4</span>
     <span class="k">return</span> <span class="n">f</span><span class="p">()</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Al declararlo de esta forma, se puede llamar a <code>usaFunc</code> escribiendo
como parámetro una sentencia que el compilador convierte a clausura:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">100</span>
<span class="n">usaFunc</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>La expresión <code>x + 10</code> se considera <em>retardada</em>: se construye una
clausura con ella y su evaluación se realiza dentro de <code>usaFunc</code>.</p>
<p>Otro ejemplo en el que podemos comprobar el orden de evaluación:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">printTest2</span><span class="p">(</span><span class="kc">_</span> <span class="n">result</span><span class="p">:</span> <span class="kr">@autoclosure</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Void</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Antes&quot;</span><span class="p">)</span>
    <span class="n">result</span><span class="p">()</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Después&quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">printTest2</span><span class="p">(</span><span class="bp">print</span><span class="p">(</span><span class="s">&quot;Hola&quot;</span><span class="p">))</span>

<span class="c1">// Imprime: </span>
<span class="c1">//     Antes</span>
<span class="c1">//     Hola</span>
<span class="c1">//     Después</span>
</pre></div>
</td></tr></table>

<p>La sentencia <code>print("Hola")</code> se pasa como una autoclausura, por lo que
el compilador crea automáticamente una clausura con ella sin tener
nosotros que escribir la expresión de clausura.</p>
<h2 id="introduccion-historia-y-caracteristicas-de-la-programacion-orientada-a-objetos">Introducción, historia y características de la Programación Orientada a Objetos<a class="headerlink" href="#introduccion-historia-y-caracteristicas-de-la-programacion-orientada-a-objetos" title="Permanent link">&para;</a></h2>
<h3 id="nacimiento">Nacimiento<a class="headerlink" href="#nacimiento" title="Permanent link">&para;</a></h3>
<ul>
<li>La Programación Orientada a Objetos es un paradigma de programación
  que explota en los 80 pero nace a partir de ideas a finales de los
  60 y 70</li>
<li>Primer lenguaje con las ideas fundamentales de POO: Simula</li>
<li>Smalltalk (1980) como lenguaje paradigmática de POO</li>
<li><strong>Alan Kay</strong> es el creador del término “Object-Oriented” y una de las
  figuras fundamentales de la historia de la informática
  moderna. Trabajó en Xerox Park y desarrolló allí ideas que han sido
  clave para la informática personal (como el Dynabook, precursor de
  tablets y dispositivos móviles y el lenguajes de programación Smalltalk)</li>
<li>Artículo de Alan Kay:
  <a href="http://gagne.homedns.org/%7etgagne/contrib/EarlyHistoryST.html">“The Early History of Smalltalk”</a>,
  ACM SIGPLAN, March 1993</li>
</ul>
<h3 id="alan-kay">Alan Kay<a class="headerlink" href="#alan-kay" title="Permanent link">&para;</a></h3>
<blockquote>
<p>“I invented the term Object-Oriented and I can tell you I did not
have C++ in mind.”</p>
<p>“Smalltalk is not only NOT its syntax or the class library, it is
not even about classes. I'm sorry that I long ago coined the term
objects for this topic because it gets many people to focus on the
lesser idea. The big idea is messaging.”</p>
<p>“Smalltalk's design–and existence–is due to the insight that
everything we can describe can be represented by the recursive
composition of a single kind of behavioral building block that hides
its combination of state and process inside itself and can be dealt
with only through the exchange of messages.”</p>
</blockquote>
<h3 id="interesados-en-smalltalk">¿Interesados en Smalltalk?<a class="headerlink" href="#interesados-en-smalltalk" title="Permanent link">&para;</a></h3>
<p>Visitar:</p>
<ul>
<li><a href="http://www.squeak.org/">http://www.squeak.org/</a></li>
<li><a href="http://swiki.agro.uba.ar/small_land">http://swiki.agro.uba.ar/small_land</a></li>
<li><a href="http://www.squeakland.org">http://www.squeakland.org</a></li>
</ul>
<h3 id="lenguajes-oo">Lenguajes OO<a class="headerlink" href="#lenguajes-oo" title="Permanent link">&para;</a></h3>
<ul>
<li>Smalltalk, Java, Scala, Ruby, Python, C#, C++, Swift, ...</li>
</ul>
<h3 id="del-paradigma-imperativo-al-oo">Del paradigma imperativo al OO<a class="headerlink" href="#del-paradigma-imperativo-al-oo" title="Permanent link">&para;</a></h3>
<ul>
<li>Programación procedural: estado abstracto (tipos de datos y barrera
  de abstracción) + funciones</li>
<li>Siguiente paso: agrupar estado y funciones en una única entidad</li>
<li>Los objetos son estas entidades</li>
</ul>
<h3 id="caracteristicas-de-la-poo">Características de la POO<a class="headerlink" href="#caracteristicas-de-la-poo" title="Permanent link">&para;</a></h3>
<ul>
<li>Objetos (creados/instanciados en tiempo de ejecución) y clases
  (plantillas estáticas/tiempo de compilación)</li>
<li>Los objetos agrupan estado y conducta (métodos)</li>
<li>Los métodos se invocan mediante mensajes</li>
<li><em>Dispatch dinámico</em>: cuando una operación es invocada sobre un
  objeto, el propio objeto determina qué código se ejecuta. Dos
  objetos con la misma interfaz pueden tener implementaciones
  distintas.</li>
<li>Herencia: las clases se pueden definir utilizando otras clases como
  plantillas y modificando sus métodos y/o variables de instancia.</li>
</ul>
<h3 id="clases-y-objetos">Clases y objetos<a class="headerlink" href="#clases-y-objetos" title="Permanent link">&para;</a></h3>
<p>Objeto:</p>
<ul>
<li>Un objeto contiene un estado (propiedades, atributos o variables de
  instancia) y un conjunto de funciones (métodos) que se ejecutan en
  el ámbito del objeto e implementan las funcionalidades soportadas</li>
<li>Al ejecutar un método, el objeto modifica su estado</li>
<li>Pedimos a un objeto que ejecute un método</li>
</ul>
<p>Clase:</p>
<ul>
<li>Una clase es la plantilla que sirve para definir los objetos</li>
<li>En una clase se define los elementos que componen el objeto (sus
  atributos o campos) y sus métodos</li>
<li>En algunos lenguajes se pueden definir también en las clases
  variables (variables de clase) compartidas por todos los objetos de
  esa clase</li>
</ul>
<h3 id="lenguajes-poo-dinamicos-vs-estaticos">Lenguajes POO dinámicos vs. estáticos<a class="headerlink" href="#lenguajes-poo-dinamicos-vs-estaticos" title="Permanent link">&para;</a></h3>
<p>Dos tendencias:</p>
<ul>
<li>
<p>Lenguajes <strong>dinámicos</strong>: muchas características del programa se
  obtienen en tiempo de ejecución</p>
<ul>
<li>Mayor flexibilidad y generalidad del código</li>
<li>Dispatch dinámico</li>
<li>Reflexión (posibilidad de consultar características de la
  instancia (nombres de métodos, propiedades, etc.) en tiempo de
  ejecución)</li>
<li>Ejemplos: Smalltalk, Ruby, Python, JavaScript, Java (en menor
  medida)</li>
</ul>
</li>
<li>
<p>Lenguajes <strong>estáticos</strong>: la mayoría de características del programa
  se obtienen en tiempo de compilación</p>
<ul>
<li>Mayor eficiencia</li>
<li>Se conoce a priori el tipo de la mayor parte de instancias del
  programa</li>
<li>Fuertemente tipeado</li>
<li>Ejemplos: C++, Swift</li>
</ul>
</li>
</ul>
<p>Vamos a detallar a continuación las <strong>características de Programación
Orientada a Objetos de Swift</strong>. Para tener una introducción rápida
puedes empezar leyendo los últimos apartados del <a href="https://github.com/domingogallardo/apuntes-lpp/blob/master/seminarios/seminario2-swift/seminario2-swift.md">seminario de
Swift</a>
(los apartados <strong>Objetos, clases y estructuras</strong>, <strong>Protocolos y
extensiones</strong> y <strong>Genéricos</strong>).</p>
<h2 id="clases-y-estructuras">Clases y estructuras<a class="headerlink" href="#clases-y-estructuras" title="Permanent link">&para;</a></h2>
<p>En el caso de Swift, las clases y las estructuras son muchas más
cercanas en funcionalidad que en otros lenguajes, como C o C++, y
tienen muchas características comunes. Muchas características de las
instancias de una clase se pueden aplicar también a las instancias de
una estructura. Por eso en Swift se suele hablar de <em>instancias</em> (un
término más general) en lugar de <em>objetos</em>.</p>
<p>Las clases y las estructuras en Swift tienen muchas cosas en
común. Ambos pueden:</p>
<ul>
<li>Definir propiedades y almacenar valores</li>
<li>Definir métodos para proporcionar funcionalidad</li>
<li>Definir subíndices para proporcionar acceso a sus valores usando una
  sintaxis de subíndice</li>
<li>Definir inicializadores para configurar el estado inicial</li>
<li>Ser extendidas para expandir su funcionalidad más allá de una
  implementación por defecto</li>
<li>Ajustarse a un protocolo </li>
</ul>
<p>Las clases tienen características adicionales que no tienen las
estructuras:</p>
<ul>
<li>Mediante la herencia una clase puede heredar las características de
  otra</li>
<li>El casting de tipos permite comprobar e interpretar el tipo de una
  instancia de una clase en tiempo de ejecución</li>
<li>Los deinicializadores permiten a una instancia de una clase liberar
  los recursos que ha asignado</li>
<li>Mediante el conteo de referencias se permite que exista más de una
  referencia a una instancia de una clase</li>
</ul>
<h3 id="definicion">Definición<a class="headerlink" href="#definicion" title="Permanent link">&para;</a></h3>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">UnaClase</span> <span class="p">{</span>
    <span class="c1">// definición de clase</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="nc">UnaEstructura</span> <span class="p">{</span>
    <span class="c1">// definición de una estructura</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">CoordsPantalla</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">posX</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">var</span> <span class="nv">posY</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Ventana</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">esquina</span> <span class="p">=</span> <span class="n">CoordsPantalla</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">altura</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">var</span> <span class="nv">anchura</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">var</span> <span class="nv">visible</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="kd">var</span> <span class="nv">etiqueta</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>El ejemplo define una nueva estructura llamada <code>CoordsPantalla</code>, que
describe una coordenada de pantalla con posiciones basadas en
píxeles. La estructura tiene dos propiedades almacenadas llamadas
<code>posX</code> y <code>posY</code>. Las propiedades son constantes o variables que se
almacenan en la instancia de la clase o de la estructura. El
compilador infiere que estas dos propiedades son <code>Int</code> al
inicializarlas a los valores iniciales de 0.</p>
<p>El ejemplo también define una nueva clase llamada <code>Ventana</code> que
describe una ventana en una pantalla. Esta clase tiene cinco
propiedades variables. La primera, <code>esquina</code>, se inicializa con una
instancia nueva de una estructura <code>CoorsPantalla</code> y se infiere que es
de tipo <code>CoordsPantalla</code>. Representa la posición superior izquierda de
la pantalla. Las propiedades <code>altura</code> y <code>anchura</code> representan el
número de píxeles de las dimensiones de la pantalla. Se inicializan
a 0. La propiedad <code>visible</code> es un <code>Bool</code> que indica si la ventana es
visible en pantalla. Por ejemplo, una ventana que esté minimizada no
será visible. Por último, <code>etiqueta</code> representa el nombre que aparece
en la parte superior de la ventana. Es un <code>String</code> opcional que se
inicializa a <code>nil</code> porque no se le asigna un valor inicial.</p>
<h3 id="instancias-de-clases-y-estructuras">Instancias de clases y estructuras<a class="headerlink" href="#instancias-de-clases-y-estructuras" title="Permanent link">&para;</a></h3>
<p>La definición de las estructuras y las clases únicamente definen sus
aspectos generales. Para describir una configuración específica (una
resolución o un modo de vídeo concreto) es necesario crear una
instancia de una estructura o una clase. La sintaxis para crear ambas
es similar:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">unasCoordsPantalla</span> <span class="p">=</span> <span class="n">CoordsPantalla</span><span class="p">()</span>
<span class="kd">var</span> <span class="nv">unaVentana</span> <span class="p">=</span> <span class="n">Ventana</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>La forma más sencilla de inicialización es la anterior. Se utiliza el
nombre del tipo de la clase o estructura seguidos de paréntesis
vacíos. Esto crea una nueva instancia de una clase o estructura, con
sus propiedades inicializadas a sus valores por defectos. Más adelante
comentaremos otras formas más elaboradas de inicialización.</p>
<p>Todas las propiedades de una instancia deben estar definidas después
de haberse inicializado, a no ser que la propiedad se un opcional.</p>
<h3 id="acceso-a-propiedades">Acceso a propiedades<a class="headerlink" href="#acceso-a-propiedades" title="Permanent link">&para;</a></h3>
<p>Se puede acceder y modificar las propiedades usando la <em>sintaxis de
punto</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// Accedemos a la propiedad</span>
<span class="n">coords</span><span class="p">.</span><span class="n">posX</span> <span class="c1">// Devuelve 0</span>
<span class="c1">// Actualizamos la propiedad</span>
<span class="n">coords</span><span class="p">.</span><span class="n">posX</span> <span class="p">=</span> <span class="mi">100</span>
<span class="n">ventana</span><span class="p">.</span><span class="n">esquina</span><span class="p">.</span><span class="n">posY</span> <span class="p">=</span> <span class="mi">100</span>
</pre></div>
</td></tr></table>

<h3 id="inicializacion-de-las-estructuras-por-sus-propiedades">Inicialización de las estructuras por sus propiedades<a class="headerlink" href="#inicializacion-de-las-estructuras-por-sus-propiedades" title="Permanent link">&para;</a></h3>
<p>Podemos inicializar las estructuras el <strong>inicializador por defecto</strong>,
en el que damos valor a todas sus propiedades. En las clases no se
puede usar esta inicialización por defecto.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">coords</span> <span class="p">=</span> <span class="n">CoordsPantalla</span><span class="p">(</span><span class="n">posX</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span> <span class="n">posY</span><span class="p">:</span> <span class="mi">400</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Es necesario inicializar todas las propiedades. Si no, el compilador
da un error:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">coords2</span> <span class="p">=</span> <span class="n">CoordsPantalla</span><span class="p">(</span><span class="n">posX</span><span class="p">:</span> <span class="mi">200</span><span class="p">)</span>
<span class="c1">// error</span>
</pre></div>
</td></tr></table>

<h3 id="estructuras-y-enumeraciones-son-tipos-valor">Estructuras y enumeraciones son tipos valor<a class="headerlink" href="#estructuras-y-enumeraciones-son-tipos-valor" title="Permanent link">&para;</a></h3>
<p>Un <em>tipo valor</em> es un tipo cuyo valor se copia cuando se asigna a una
variable o constante, o cuando se pasa a una función.</p>
<p>Todos los tipos básicos de Swift -enteros, números en punto flotante,
cadenas, arrays y diccionarios- son tipos valor y se implementan como
estructuras. Las estructuras y las enumeraciones son tipos valor en
Swift.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">coords1</span> <span class="p">=</span> <span class="n">CoordsPantalla</span><span class="p">(</span><span class="n">posX</span><span class="p">:</span> <span class="mi">600</span><span class="p">,</span> <span class="n">posY</span><span class="p">:</span> <span class="mi">600</span><span class="p">)</span>
<span class="kd">var</span> <span class="nv">coords2</span> <span class="p">=</span> <span class="n">coords1</span>
<span class="n">coords2</span><span class="p">.</span><span class="n">posX</span> <span class="p">=</span> <span class="mi">1000</span>
<span class="n">coords1</span><span class="p">.</span><span class="n">poxX</span> <span class="c1">// devuelve 600</span>
</pre></div>
</td></tr></table>

<p>En el ejemplo se declara una constante llamada <code>coords1</code> y se asigna a una
instancia de <code>CoordsPantalla</code> inicializada con la posición x de 600 y
la posición y de 600. Después se declara una variable llamada
<code>coords2</code> y se asigna al valor actual de <code>coors1</code>. Debido a que <code>CoordsPantalla</code>
es una estructura, se crea <em>una copia</em> de la instancia existente y
esta nueva copia se asigna a <code>coords2</code>. Aunque ahora <code>coords2</code> y <code>coords1</code> tienen
las mismas <code>posX</code> y <code>posY</code>, son dos instancias completamente
distintas. Después, la propiedad <code>posX</code> de <code>coords2</code> se actualiza a 1000.</p>
<p>Podemos comprobar que la propiedad se modifica, pero que el valor de
<code>posX</code> en <code>coords1</code> sigue siendo el mismo.</p>
<h3 id="las-clases-son-tipos-referencia">Las clases son tipos referencia<a class="headerlink" href="#las-clases-son-tipos-referencia" title="Permanent link">&para;</a></h3>
<p>A diferencia de los tipos valor, los tipos de referencias no se copian
cuando se asignan o se pasan a funciones. En su lugar se usa una
referencia a la misma instancia existente.</p>
<p>Veamos un ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">ventana1</span> <span class="p">=</span> <span class="n">Ventana</span><span class="p">()</span>
<span class="n">ventana1</span><span class="p">.</span><span class="n">esquina</span> <span class="p">=</span> <span class="n">coords1</span>
<span class="n">ventana1</span><span class="p">.</span><span class="n">altura</span> <span class="p">=</span> <span class="mi">800</span>
<span class="n">ventana1</span><span class="p">.</span><span class="n">anchura</span> <span class="p">=</span> <span class="mi">800</span>
<span class="n">ventana1</span><span class="p">.</span><span class="n">etiqueta</span> <span class="p">=</span> <span class="s">&quot;Finder&quot;</span>
<span class="kd">var</span> <span class="nv">ventana2</span> <span class="p">=</span> <span class="n">ventana1</span>
<span class="n">ventana2</span><span class="p">.</span><span class="n">anchura</span> <span class="p">=</span> <span class="mi">1000</span>
<span class="n">ventana1</span><span class="p">.</span><span class="n">anchura</span> <span class="c1">// devuelve 1000</span>
</pre></div>
</td></tr></table>

<p>Declaramos una constante llamada <code>ventana1</code> inicializada con una
instancia nueva de la clase <code>Ventana</code>. Le asignamos a la propiedad
<code>esquina</code> una copia de la resolución anterior <code>coords1</code>. Después
declaramos la altura, anchura y etiqueta de la ventana.</p>
<p>Después, <code>ventana1</code> se asigna a una nueva constante llamada
<code>ventan2</code>, y la anchura se modifica. Debido a que son
tipos de referencia, <code>ventana1</code> y <code>ventana2</code> se refieren
a la misma instancia de <code>Ventana</code>. Son sólo dos nombres distintos
para la misma única instancia.</p>
<p>Hay que hacer notar que <code>ventana1</code> y <code>ventana2</code> se
declaran con <code>let</code> como constantes. Sin embargo, podemos modificar sus
propiedades debido a que no se ha reasignado su instancia a la que se
refieren". Esas variables no "almacenan" instancias de <code>Ventana</code>, sino que se
"refieren" a una instancia de la clase. Es la propiedad <code>anchura</code>
de la instancia subyacente la que se cambia, no los valores de las
referencias constantes a la instancia de <code>Ventana</code>.</p>
<p>A diferencia de las clases, una instancia de un <code>struct</code> definida con
un <code>let</code> define como constantes todas sus propiedades. Por ejemplo, el
siguiente código generaría un error:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">coords3</span> <span class="p">=</span> <span class="n">CoordsPantalla</span><span class="p">(</span><span class="n">posX</span><span class="p">:</span> <span class="mi">400</span><span class="p">,</span> <span class="n">posY</span><span class="p">:</span> <span class="mi">400</span><span class="p">)</span>
<span class="n">coords3</span><span class="p">.</span><span class="n">posX</span> <span class="p">=</span> <span class="mi">800</span>
<span class="c1">// error: cannot assign to property: &#39;coords3&#39; is a &#39;let&#39; constant</span>
</pre></div>
</td></tr></table>

<h3 id="declaracion-de-instancias-con-let">Declaración de instancias con <code>let</code><a class="headerlink" href="#declaracion-de-instancias-con-let" title="Permanent link">&para;</a></h3>
<p>Las estructuras y clases tienen comportamientos distintos cuando se
declaran las variables con <code>let</code>.</p>
<p>Si definimos con <code>let</code> una instancia de una estructura estamos
declarando constante la variable y todas las propiedades de la
instancia. No podremos modificar ninguna:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">coords3</span> <span class="p">=</span> <span class="n">CoordsPantalla</span><span class="p">(</span><span class="n">posX</span><span class="p">:</span> <span class="mi">400</span><span class="p">,</span> <span class="n">posY</span><span class="p">:</span> <span class="mi">400</span><span class="p">)</span>
<span class="n">coords3</span><span class="p">.</span><span class="n">posX</span> <span class="p">=</span> <span class="mi">800</span>
<span class="c1">// error: cannot assign to property: &#39;coords3&#39; is a &#39;let&#39; constant</span>
</pre></div>
</td></tr></table>

<p>Si definimos con un <code>let</code> una instancia de una clase sólo estamos
declarando constante la variable. No podremos reasignarla, pero sí que
podremos modificar las propiedades de la instancia referenciada por la
variable:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">ventana3</span> <span class="p">=</span> <span class="n">Ventana</span><span class="p">()</span>
<span class="c1">// Sí que podemos modificar una propiedad de la instancia:</span>
<span class="n">ventana3</span><span class="p">.</span><span class="n">etiqueta</span> <span class="p">=</span> <span class="s">&quot;Listado&quot;</span>
<span class="c1">// Pero no podemos reasignar la variable:</span>
<span class="n">ventana3</span> <span class="p">=</span> <span class="n">ventana1</span>
<span class="c1">// error: cannot assign to value: &#39;ventana3&#39; is a &#39;let&#39; constant</span>
</pre></div>
</td></tr></table>

<h3 id="operadores-de-identidad">Operadores de identidad<a class="headerlink" href="#operadores-de-identidad" title="Permanent link">&para;</a></h3>
<p>A veces puede ser útil descubrir si dos constantes o variables se
refieren exactamente a la misma instancia de una clase. Para permitir
esto, Swift proporciona dos operadores de identidad:</p>
<ul>
<li>Idéntico a (<code>===</code>)</li>
<li>No idéntico a (<code>!==</code>)</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">ventana1</span> <span class="p">===</span> <span class="n">ventana2</span> <span class="c1">// devuelve true</span>
<span class="n">ventana1</span> <span class="p">===</span> <span class="n">ventana3</span> <span class="c1">// devuelve false</span>
</pre></div>
</td></tr></table>

<p>Estos operadores "idéntico a" no son los mismos que los de "igual a"
(representado por dos signos iguales <code>==</code>):</p>
<ul>
<li>"Idéntico a" significa que dos constantes o variables de una clase
  se refieren exactamente a la misma instancia de la clase.</li>
<li>"Igual a" significa que dos instancias se consideran "iguales" o
  "equivalentes" en su valor. Es responsabilidad del diseñador de la
  clase definir la implementación de estos operadores.</li>
</ul>
<p>Si tienes experiencia con C, C++, o Objective-C, puedes saber que
estos lenguajes usan punteros para referirse a una dirección de
memoria. Una constante o variable en Swift que se refiere a una
instancia de un tipo referencia es similar a un puntero en C, pero no
es un puntero que apunta a una dirección de memoria y no requiere que
se escriba un asterisco (*) para indicar que estas creando una
referencia. En su lugar, estas referencias se definen como cualquier
otra constante o variable en Swift.</p>
<h3 id="criterios-para-usar-estructuras-y-clases">Criterios para usar estructuras y clases<a class="headerlink" href="#criterios-para-usar-estructuras-y-clases" title="Permanent link">&para;</a></h3>
<p>Podemos usar tanto clases como estructuras para definir nuestros tipos
de datos y utilizarlos como bloques de construcción del código de
nuestros programas. Sin embargo, se utilizan para distintos tipos de
tareas.</p>
<p>Como regla general, utilizaremos una estructura cuando se cumplen una
o más de las siguientes condiciones:</p>
<ul>
<li>El principal objetivo de la estructura es encapsular unos pocos
  datos relativamente sencillos.</li>
<li>Es razonable esperar que los valores encapsulados serán copiados,
  más que referenciados, cuando asignamos o pasamos una instancia de
  esa estructura.</li>
<li>Todas las propiedades almacenadas en la estructura son a su vez
  tipos valor, que también se espera que sean copiados más que
  referenciados.</li>
<li>La estructura no necesita heredar propiedades o conducta de otro
  tipo existente.</li>
</ul>
<p>Ejemplos de buenos candidatos de estructuras incluyen:</p>
<ul>
<li>El tamaño de una forma geométrica, encapsulando por ejemplo las
  propiedades <code>ancho</code> y <code>alto</code> de tipo <code>Double</code>.</li>
<li>Una forma de referirse a rangos dentro de una serie, encapsulando
  por ejemplo, una propiedad <code>comienzo</code> y otra <code>longitud</code>, ambos del
  tipo <code>Int</code>.</li>
<li>Un punto en un sistema de coordenadas 3D, encapsulando quizás las
  propiedades <code>x</code>, <code>y</code> y <code>z</code>, todos ellos de tipo <code>Double</code>.</li>
</ul>
<p>En el resto de casos, definiremos una clase y crearemos instancias de
esa clase que tendrán que ser gestionadas y pasadas por referencia. En
la práctica, esto representa que la mayoría de datos que construiremos
en nuestros programas deberían clases, no estructuras. Aunque usaremos
muchas de las estructuras estándar de Swift.</p>
<h2 id="propiedades">Propiedades<a class="headerlink" href="#propiedades" title="Permanent link">&para;</a></h2>
<p>Las <em>propiedades</em> asocian valores con una clase, estructura o
enumeración particular. Las propiedades almacenadas (<em>stored
properties</em>) almacenan valores constantes y variables como parte de
una instancia, mientras que las propiedades calculadas (<em>computed
properties</em>) calculan (en lugar de almacenar) un valor. Las
propiedades calculadas se definen en clases, estructuras y
enumeraciones. Las propiedades almacenadas se definen sólo en clases y
estructuras.</p>
<ul>
<li>Enumeraciones: pueden contener sólo propiedades calculadas.</li>
<li>Clases y estructuras: pueden contener propiedades almacenadas y calculadas.</li>
</ul>
<p>Las propiedades calculadas y almacenadas se asocian habitualmente con
instancias de un tipo particular. Sin embargo, las propiedades también
pueden asociarse con el propio tipo. Estas propiedades se conocen como
propiedades del tipo (<em>type properties</em>).</p>
<p>Además, en Swift es posible definir observadores de propiedades que
monitoricen cambios en los valores de una propiedad, a los que podemos
responder con acciones programadas. Los observadores de propiedades
pueden añadirse tanto a propiedades almacenadas definidas por nosotros
como a propiedades heredadas de la superclase.</p>
<h3 id="propiedades-almacenadas">Propiedades almacenadas<a class="headerlink" href="#propiedades-almacenadas" title="Permanent link">&para;</a></h3>
<p>En su forma más simple, una propiedad almacenada es una constante o
variable que está almacenada como parte de una instancia de una clase
o estructura particular. Las propiedades almacenadas pueden ser o bien
variables (usando la palabra clave <code>var</code>) o bien constantes (usando la
palabra clave <code>let</code>).</p>
<p>Podemos proporcionar un valor por defecto para la inicialización de
las propiedades almacenadas, tanto variables como constantes.</p>
<p>El siguiente ejemplo define una estructura llamada <code>RangoLongitudFija</code>
que describe un rango de valores enteros cuya longitud no puede ser
modificada una vez que se crea:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">RangoLongitudFija</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">primerValor</span><span class="p">:</span> <span class="nb">Int</span>
    <span class="kd">let</span> <span class="nv">longitud</span><span class="p">:</span> <span class="nb">Int</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">rangoDeTresItemss</span> <span class="p">=</span> <span class="n">RangoLongitudFija</span><span class="p">(</span><span class="n">primerValor</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">longitud</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">// el rango representa ahora valores enteros the range represents integer values 0, 1, and 2</span>
<span class="n">rangoDeTresItemss</span><span class="p">.</span><span class="n">primerValor</span> <span class="p">=</span> <span class="mi">6</span>
<span class="c1">// el rango representa ahora valores enteros 6, 7 y 8</span>
</pre></div>
</td></tr></table>

<p>Las instancias de <code>RangoLongitudFija</code> tienen una propiedad almacenada
variable llamada <code>primerValor</code> y una propiedad almacenada constante
llamada <code>longitud</code>. En el ejemplo, <code>longitud</code> se inicializa cuando se
crea el nuevo rango y no puede ser cambiada en el futuro, por ser una
propiedad constante.</p>
<p>Si creamos una instancia de una estructura y la asignamos a una
constante, no podremos modificar las propiedades de la instancia,
incluso si han sido declaradas como propiedades variables:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">rangoDeCuatroItems</span> <span class="p">=</span> <span class="n">RangoLongitudFija</span><span class="p">(</span><span class="n">primerValor</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">longitud</span><span class="p">:</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">// este rango representa valores enteros 0, 1, 2 y 3</span>
<span class="n">rangoDeCuatroItems</span><span class="p">.</span><span class="n">primerValor</span> <span class="p">=</span> <span class="mi">6</span>
<span class="c1">// esto producirá un error, incluso aun siendo primerValor una propiedad variable</span>
</pre></div>
</td></tr></table>

<h3 id="propiedades-calculadas">Propiedades calculadas<a class="headerlink" href="#propiedades-calculadas" title="Permanent link">&para;</a></h3>
<p>Además de las propiedades almacenadas, las clases, estructuras y
enumeraciones pueden definir <em>propiedades calculadas</em>, que no
almacenan realmente un valor. En su lugar, proporcionan un <em>getter</em> y
un opcional <em>setter</em> que devuelven y modifican otras propiedades y
valores de forma indirecta.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Punto</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="mf">0.0</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="nc">Tama</span><span class="err">ñ</span><span class="n">o</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">ancho</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">alto</span> <span class="p">=</span> <span class="mf">0.0</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="nc">Rectangulo</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">origen</span> <span class="p">=</span> <span class="n">Punto</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">tama</span><span class="err">ñ</span><span class="n">o</span> <span class="p">=</span> <span class="n">Tama</span><span class="err">ñ</span><span class="n">o</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">centro</span><span class="p">:</span> <span class="n">Punto</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nv">centroX</span> <span class="p">=</span> <span class="n">origen</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">tama</span><span class="err">ñ</span><span class="n">o</span><span class="p">.</span><span class="n">ancho</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="kd">let</span> <span class="nv">centroY</span> <span class="p">=</span> <span class="n">origen</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">tama</span><span class="err">ñ</span><span class="n">o</span><span class="p">.</span><span class="n">alto</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">centroX</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">centroY</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="kr">set</span><span class="p">(</span><span class="n">centroNuevo</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">origen</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">centroNuevo</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">tama</span><span class="err">ñ</span><span class="n">o</span><span class="p">.</span><span class="n">ancho</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">origen</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">centroNuevo</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">tama</span><span class="err">ñ</span><span class="n">o</span><span class="p">.</span><span class="n">alto</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">cuadrado</span> <span class="p">=</span> <span class="n">Rectangulo</span><span class="p">(</span><span class="n">origen</span><span class="p">:</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">),</span>
                  <span class="n">tama</span><span class="err">ñ</span><span class="n">o</span><span class="p">:</span> <span class="n">Tama</span><span class="err">ñ</span><span class="n">o</span><span class="p">(</span><span class="n">ancho</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span> <span class="n">alto</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">))</span>
<span class="kd">let</span> <span class="nv">centroCuadradoInicial</span> <span class="p">=</span> <span class="n">cuadrado</span><span class="p">.</span><span class="n">centro</span>
<span class="n">cuadrado</span><span class="p">.</span><span class="n">centro</span> <span class="p">=</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">15.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">15.0</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;cuadrado.origen está ahora en (</span><span class="si">\(</span><span class="n">cuadrado</span><span class="p">.</span><span class="n">origen</span><span class="p">.</span><span class="n">x</span><span class="si">)</span><span class="s">, </span><span class="si">\(</span><span class="n">cuadrado</span><span class="p">.</span><span class="n">origen</span><span class="p">.</span><span class="n">y</span><span class="si">)</span><span class="s">)&quot;</span><span class="p">)</span>
<span class="c1">// Prints &quot;cuadrado.origen está ahora en (10.0, 10.0)&quot;</span>
</pre></div>
</td></tr></table>

<p>Este ejemplo define tres estructuras para trabajar con formas
geométricas:</p>
<ul>
<li><code>Punto</code> encapsula una coordenada <code>(x, y)</code></li>
<li><code>Tamaño</code> encapsula un ancho y un alto</li>
<li><code>Rectangulo</code> define una rectángulo por un punto de origen y un
  tamaño</li>
</ul>
<p>La estructura <code>Rectangulo</code> proporciona una propiedad calculada llamada
<code>centro</code>. La posición actual del centro de un <code>Rectangulo</code> puede ser
siempre determinada a partir de su origen y su tamaño, por lo que no
necesitamos almacenarlo como un <code>Punto</code> explícito. En su lugar,
<code>Rectangulo</code> define un <em>getter</em> y un <em>setter</em> programado para una
variable calculada llamada <code>centro</code>, para permitirnos trabajar con el
centro del rectángulo como si fuera una propiedad almacenada.</p>
<p>En el ejemplo se crea una variable <code>Rectangulo</code> llamada <code>cuadrado</code>. La
variable <code>cuadrado</code> se inicializa un un punto origen de <code>(0, 0)</code> y un
ancho y tamaño de <code>10</code>. Este cuadrado está representado por el
cuadrado azul en el diagrama de abajo.</p>
<p>Accedemos entonces a la propiedad <code>centro</code> de la variable <code>cuadrado</code>
usando la sintaxis del punto (<code>square.centro</code>), lo que causa que se
llame al <em>getter</em> de <code>centro</code> para devolver el valor actual de la
propiedad. En lugar de devolver los valores existentes, el <em>getter</em>
calcula realmente y devuelve un nuevo <code>Punto</code> para representar el
centro del cuadrado. Como puede verse arriba, el <em>getter</em> devuelve
correctamente un punto con los valores <code>(5, 5)</code>.</p>
<p>Después la propiedad centro se actualiza al nuevo valor de <code>(15, 15)</code>
lo que mueve el cuadrado arriba a la derecha, a la nueva posición
mostrada por el cuadrado naranja en el diagrama de abajo. Al asignar
el nuevo valor a la propiedad se llama al <em>setter</em> del centro, lo que
modifica los valores <code>x</code> e <code>y</code> de las propiedades almacenadas
originales, y mueve el cuadrado a su nueva posición.</p>
<p><img src="imagenes/computedProperties.png" width="300px"/></p>
<p>Se puede definir una versión acortada del <em>setter</em> usando la variable
por defecto <code>newValue</code> que contiene el nuevo valor asignado en el
<em>setter</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Rectangulo</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">origen</span> <span class="p">=</span> <span class="n">Punto</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">tama</span><span class="err">ñ</span><span class="n">o</span> <span class="p">=</span> <span class="n">Tama</span><span class="err">ñ</span><span class="n">o</span><span class="p">()</span>
    <span class="kd">var</span> <span class="nv">centro</span><span class="p">:</span> <span class="n">Punto</span> <span class="p">{</span>
        <span class="kr">get</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nv">centroX</span> <span class="p">=</span> <span class="n">origen</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">tama</span><span class="err">ñ</span><span class="n">o</span><span class="p">.</span><span class="n">ancho</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="kd">let</span> <span class="nv">centroY</span> <span class="p">=</span> <span class="n">origen</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">tama</span><span class="err">ñ</span><span class="n">o</span><span class="p">.</span><span class="n">alto</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">centroX</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">centroY</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="kr">set</span> <span class="p">{</span>
            <span class="n">origen</span><span class="p">.</span><span class="n">x</span> <span class="p">=</span> <span class="n">newValue</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">tama</span><span class="err">ñ</span><span class="n">o</span><span class="p">.</span><span class="n">ancho</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">origen</span><span class="p">.</span><span class="n">y</span> <span class="p">=</span> <span class="n">newValue</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">tama</span><span class="err">ñ</span><span class="n">o</span><span class="p">.</span><span class="n">alto</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="propiedades-solo-lectura">Propiedades solo-lectura<a class="headerlink" href="#propiedades-solo-lectura" title="Permanent link">&para;</a></h3>
<p>Una propiedad calculada con un <em>getter</em> y sin <em>setter</em> se conoce como
una propiedad calculada de solo-lectura. Una propiedad calculada de
solo-lectura siempre devuelve un valor, y puede accederse a ella
usando la sintaxis de punto, pero no puede modificarse a un valor
distinto.</p>
<p>Es posible simplificar la declaración de una propiedad calculada de
solo-lectura eliminando la palabra clave <code>get</code> y sus llaves:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Cuboide</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">ancho</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">alto</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">profundo</span> <span class="p">=</span> <span class="mf">0.0</span>
    <span class="kd">var</span> <span class="nv">volumen</span><span class="p">:</span> <span class="nb">Double</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">ancho</span> <span class="o">*</span> <span class="n">alto</span> <span class="o">*</span> <span class="n">profundo</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">cuatroPorCincoPorDos</span> <span class="p">=</span> <span class="n">Cuboide</span><span class="p">(</span><span class="n">ancho</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span> <span class="n">alto</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">profundo</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;el volumen de cuatroPorCincoPorDos es </span><span class="si">\(</span><span class="n">cuatroPorCincoPorDos</span><span class="p">.</span><span class="n">volumen</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;el volumen de cuatroPorCincoPorDos es 40.0&quot;</span>
</pre></div>
</td></tr></table>

<p>Este ejemplo define una nueva estructura llamada <code>Cubiode</code>, que
representa una caja rectangular 3D con propiedades <code>ancho</code>, <code>alto</code> y
<code>profundo</code>. Esta estructura tiene una propiedad calculada llamada
<code>volumen</code>, que calcula y devuelve el volumen actual del cuboide. No
tendría sentido que el volumen fuera modificable, porque no sería
ambiguo determinar qué valores concretos de ancho, alto y profundo
deberían usarse para un valor particular del volumen.</p>
<h3 id="observadores-de-propiedades">Observadores de propiedades<a class="headerlink" href="#observadores-de-propiedades" title="Permanent link">&para;</a></h3>
<p>Los observadores de propiedades (<em>property observers</em>) observan y
responden a cambios en el valor de una propiedad. Los observadores de
propiedades se llaman cada vez que el valor de una propiedad es
actualizado, incluso si el nuevo valor es el mismo que el valor actual
de la propiedad.</p>
<p>Se pueden añadir observadores a cualquier propiedad almacenada que se
definan. Se pueden también añadir observadores a cualquier propiedad
heredada (ya sea almacenada o calculada) sobreescribiendo la propiedad
en la subclase. No es necesario definir observadores de propiedades
calculadas no sobreescritas porque siempre es posible observar y
responder a cambios en su valor en el <em>setter</em> de la propiedad.</p>
<p>Es posible definir alguno o ambos de estos observadores sobre una propiedad:</p>
<ul>
<li><code>willSet</code> es llamado justo antes de que el nuevo valor se almacena
  en la propiedad.</li>
<li><code>didSet</code> es llamado inmediatamente después de que el nuevo valor es
  almacenado en la propiedad.</li>
</ul>
<p>Si implementamos un observador <code>willSet</code>, se le pasa el nuevo valor de
la propiedad como un parámetro constante. Podemos especificar un
nombre para este parámetro como parte de la implementación de
<code>willSet</code>. Si no escribimos el nombre del parámetro y los paréntesis
dentro de la implementación, el parámetro estará disponible con el
nombre por defecto de <code>newValue</code>.</p>
<p>De forma similar, si implementamos un observador <code>didSet</code>, se pasa
como un parámetro constante que contiene el valor antiguo de la
propiedad. Podemos darle nombre al parámetro o usar el nombre por
defecto de <code>oldValue</code>. Si asignamos un valor a la propiedad dentro de
su propio observador <code>didSet</code>, el nuevo valor que asignamos reemplaza
el que acaba de añadirse a la propiedad.</p>
<p>A continuación podemos ver un ejemplo de <code>willSet</code> y <code>didSet</code> en
acción. En el definimos una clase nueva llamada <code>CuentaPasos</code>, que
hace un seguimiento del número total de pasos que una persona hace al
caminar. Esta clase puede usarse con datos de entrada de un
<em>podómetro</em> o cualquier otro sistema de seguir el ejercicio de la
persona durante sus rutina diaria.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">ContadorPasos</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">totalPasos</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="kr">willSet</span><span class="p">(</span><span class="n">nuevoTotalPasos</span><span class="p">)</span> <span class="p">{</span>
            <span class="bp">print</span><span class="p">(</span><span class="s">&quot;A punto de actualizar totoalPasos a </span><span class="si">\(</span><span class="n">nuevoTotalPasos</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="kr">didSet</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">totalPasos</span> <span class="o">&gt;</span> <span class="n">oldValue</span>  <span class="p">{</span>
                <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Añadidos </span><span class="si">\(</span><span class="n">totalPasos</span> <span class="o">-</span> <span class="n">oldValue</span><span class="si">)</span><span class="s"> pasos&quot;</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">contadorPasos</span> <span class="p">=</span> <span class="n">ContadorPasos</span><span class="p">()</span>
<span class="n">contadorPasos</span><span class="p">.</span><span class="n">totalPasos</span> <span class="p">=</span> <span class="mi">200</span>
<span class="c1">// Imprime: &quot;A punto de actualizar totalPasos a 200&quot;</span>
<span class="c1">// Imprime: &quot;Añadidos 200 pasos&quot;</span>
<span class="n">contadorPasos</span><span class="p">.</span><span class="n">totalPasos</span> <span class="p">=</span> <span class="mi">360</span>
<span class="c1">// Imprime: &quot;A punto de actualizar totalPasos a 360&quot;</span>
<span class="c1">// Imprime: &quot;Añadidos 160 pasos&quot;</span>
<span class="n">contadorPasos</span><span class="p">.</span><span class="n">totalPasos</span> <span class="p">=</span> <span class="mi">896</span>
<span class="c1">// Imprime: &quot;A punto de actualizar totalPasos a 896&quot;</span>
<span class="c1">// Imprime: &quot;Añadidos 536 pasos&quot;</span>
</pre></div>
</td></tr></table>

<p>La clase <code>CuentaPasos</code> declara la propiedad <code>totalPasos</code> de tipo
<code>Int</code>. Esta es una propiedad almacenada con observadores <code>willSet</code> y
<code>didSet</code>.</p>
<p>Los observadores <code>willSet</code> y <code>didSet</code> de <code>totalPasos</code> se llaman
siempre que se le asigna un nuevo valor a la propiedad. Esto es así
incluso si el nuevo valor es el mismo que el valor actual.</p>
<p>El observador <code>willSet</code> usa un parámetro definido por nosotros con el
nombre de <code>nuevoTotalPasos</code> para el valor que llega. En el ejemplo,
sencillamente imprime el valor que está a punto de establecer.</p>
<p>El observador <code>didSet</code> se llama después de que el valor de
<code>totalPasos</code> se ha actualizado. Compara el nuevo valor de <code>totalPasos</code>
con el valor antiguo. Si el número total de pasos se ha incrementado,
se imprime un mensaje indicando cuántos pasos se han tomado. El
observador <code>didSet</code> no proporciona un parámetro definido por nosotros
para el valor antiguo, sino que usa el nombre por defecto <code>oldValue</code>.</p>
<h3 id="variables-locales-y-globales">Variables locales y globales<a class="headerlink" href="#variables-locales-y-globales" title="Permanent link">&para;</a></h3>
<p>Las capacidades anteriores de propiedades calculadas y de observadores
también están disponibles para variables globales y locales.</p>
<p>El siguiente ejemplo muestra un ejemplo con una variable calculada a
partir de otras dos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">10</span>  <span class="p">{</span>
   <span class="kr">didSet</span> <span class="p">{</span>
      <span class="bp">print</span><span class="p">(</span><span class="s">&quot;El nuevo valor: </span><span class="si">\(</span><span class="n">x</span><span class="si">)</span><span class="s"> y el valor antiguo: </span><span class="si">\(</span><span class="n">oldValue</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">y</span> <span class="p">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
<span class="kd">var</span> <span class="nv">z</span> <span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="kr">get</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
   <span class="p">}</span>
   <span class="kr">set</span> <span class="p">{</span>
      <span class="n">x</span> <span class="p">=</span> <span class="n">newValue</span> <span class="o">/</span> <span class="mi">2</span>
      <span class="n">y</span> <span class="p">=</span> <span class="n">newValue</span> <span class="o">/</span> <span class="mi">2</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
<span class="n">z</span> <span class="p">=</span> <span class="mi">100</span>
<span class="bp">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<h3 id="propiedades-del-tipo">Propiedades del tipo<a class="headerlink" href="#propiedades-del-tipo" title="Permanent link">&para;</a></h3>
<p>Las propiedades de las instancias son propiedades que pertenecen a una
instancia de un tipo particular. Cada vez que creamos una nueva
instancia de ese tipo, tiene su propio conjunto de valores de
propiedades, separados de los de cualquier otra instancia.</p>
<p>Podemos definir también propiedades que pertenecen al tipo propiamente
dicho, no a ninguna de las instancias de ese tipo. Sólo habrá una
copia de estas propiedades, sea cual sea el número de instancias de
ese tipo que creemos. Estos tipos de propiedades se llaman propiedades
del tipo (<em>type propierties</em>). Se pueden definir en tanto en
estructuras, clases como en enumeraciones.</p>
<p>Las propiedades del tipo son útiles para definir valores que son
universales a todas las instancias de un tipo particular, como una
propiedad constante que todas las instancias pueden usar (como una
constante estática en C), o una propiedad variable que almacena un
valor que es global a todas las instancias de ese tipo (como una
variable estática en C).</p>
<p>Las propiedades del tipo almacenadas pueden ser variables o
constantes. Las propiedades del tipo calculadas se declaran siempre
como propiedades variables, de la misma forma que las propiedades
calculadas de instancias.</p>
<p>A diferencia de las propiedades almacenadas de instancias, debemos
siempre proporcionar un valor por defecto para las propiedades
almacenadas de tipo. Esto es debido a que el tipo por si mismo no
tiene un inicializador que pueda asignar un valor en tiempo de
inicialización.</p>
<p>En Swift, las propiedades del tipo se definen como parte de la
definición del tipo, dentro de las llaves del tipo. Las propiedades
del tipo toman valor en el ámbito del tipo. Para definir una propiedad
del tipo hay que usar la palabra clave <code>static</code>. Para propiedades de
tipo calculadas de clases, podemos usar en su lugar la palabra clave
<code>class</code> para permitir a las subclases que sobreescriban la
implementación de la superclase.</p>
<p>Las propiedades del tipo pueden ser también constantes (<code>let</code>) o
variables (<code>var</code>).</p>
<p>Ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">UnaEstructura</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">almacenada</span> <span class="p">=</span> <span class="s">&quot;A&quot;</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">calculada</span> <span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">enum</span> <span class="nc">UnaEnumeracion</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">almacenada</span> <span class="p">=</span> <span class="s">&quot;A&quot;</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">calculada</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nc">UnaClase</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">almacenada</span> <span class="p">=</span> <span class="s">&quot;A&quot;</span>
    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">calculada</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Las propiedades del tipo se consultan y actualizan usando también la
sintaxis de punto, pero sobre <em>el tipo</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">UnaEstructura</span><span class="p">.</span><span class="n">almacenada</span> <span class="c1">// devuelve &quot;A&quot;</span>
<span class="n">UnaEstructura</span><span class="p">.</span><span class="n">almacenada</span> <span class="p">=</span> <span class="s">&quot;B&quot;</span> 
<span class="n">UnaClase</span><span class="p">.</span><span class="n">calculada</span> <span class="c1">// devuelve 1</span>
</pre></div>
</td></tr></table>

<ul>
<li>No es posible acceder a la variable del tipo a través de una instancia:</li>
</ul>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">a</span> <span class="p">=</span> <span class="n">UnaEstructura</span><span class="p">()</span>
<span class="n">a</span><span class="p">.</span><span class="n">almacenada</span> <span class="c1">// error</span>
</pre></div>
</td></tr></table>

<p>El siguiente ejemplo muestra cómo es posible usar una variable del
tipo para almacenar información global a todas las instancias de ese tipo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Valor</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nv">valor</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="kr">didSet</span> <span class="p">{</span>
         <span class="n">Valor</span><span class="p">.</span><span class="n">sumaValores</span> <span class="o">+=</span> <span class="n">valor</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="kd">static</span> <span class="kd">var</span> <span class="nv">sumaValores</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">c1</span> <span class="p">=</span> <span class="n">Valor</span><span class="p">()</span>
<span class="kd">var</span> <span class="nv">c2</span> <span class="p">=</span> <span class="n">Valor</span><span class="p">()</span>
<span class="kd">var</span> <span class="nv">c3</span> <span class="p">=</span> <span class="n">Valor</span><span class="p">()</span>
<span class="n">c1</span><span class="p">.</span><span class="n">valor</span> <span class="p">=</span> <span class="mi">10</span>
<span class="n">c2</span><span class="p">.</span><span class="n">valor</span> <span class="p">=</span> <span class="mi">20</span>
<span class="n">c3</span><span class="p">.</span><span class="n">valor</span> <span class="p">=</span> <span class="mi">30</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Suma de los cambios de valores: </span><span class="si">\(</span><span class="n">Valor</span><span class="p">.</span><span class="n">sumaValores</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// Imprime 60</span>
</pre></div>
</td></tr></table>

<h2 id="metodos">Métodos<a class="headerlink" href="#metodos" title="Permanent link">&para;</a></h2>
<p>Los <em>métodos</em> son funciones que están asociadas a un tipo
particular. Las clases, estructuras y enumeraciones pueden definir
todas ellas métodos de instancia, que encapsulan tareas y
funcionalidades específicas que trabajan con una instancia de un tipo
dado. Las clases, estructuras y enumeraciones también pueden definir
métodos del tipo, que están asociados con el propio tipo. Los métodos
del tipo son similares a los métodos de clase en Java.</p>
<p>El hecho de que las estructuras y las enumeraciones puedan definir
métodos en Swift es una diferencia importante con C y Objective-C.</p>
<h3 id="metodos-de-instancia">Métodos de instancia<a class="headerlink" href="#metodos-de-instancia" title="Permanent link">&para;</a></h3>
<p>Los métodos de instancia son funciones que pertenecen a instancias de
una clase, estructura o enumeración. Proporcionan la funcionalidad de
esas instancias, bien proporcionando formas de acceder y modificar
propiedades de las instancias, o bien proporcionando funcionalidades
relacionadas con el propósito de la instancia. Los métodos de
instancia tienen exactamente la misma sintaxis que las funciones.</p>
<p>Los métodos de instancia se escriben dentro de las llaves del tipo al
que pertenecen. Un método de instancia tiene acceso implícito a todos
los otros métodos de instancia y propiedades del tipo. Un método de
instancia puede ser invocado sólo sobre una instancia específica del
tipo al que pertenece. No puede ser invocado de forma aislada sin una
instancia existente.</p>
<p>A continuación podemos ver un ejemplo que define una sencilla clase
<code>Contador</code>, que puede usarse para contar el número de veces que sucede
una acción:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Contador</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">veces</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">func</span> <span class="nf">incrementa</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">veces</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">incrementa</span><span class="p">(</span><span class="n">en</span> <span class="n">cantidad</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">veces</span> <span class="o">+=</span> <span class="n">cantidad</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">reset</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">veces</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Y un ejemplo de uso:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">contador</span> <span class="p">=</span> <span class="n">Contador</span><span class="p">()</span>
<span class="c1">// el valor inicial del contador es 0</span>
<span class="n">contador</span><span class="p">.</span><span class="n">incrementa</span><span class="p">()</span>
<span class="c1">// el valor del contador es ahora 1</span>
<span class="n">contador</span><span class="p">.</span><span class="n">incrementa</span><span class="p">(</span><span class="n">en</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// el valor del contador es ahora 6</span>
<span class="n">contador</span><span class="p">.</span><span class="n">reset</span><span class="p">()</span>
<span class="c1">// el valor del contador es ahora 0</span>
</pre></div>
</td></tr></table>

<p>En el ejemplo anterior, los métodos no devuelven ningún
valor. Podemos modificar el ejemplo para que los métodos
devuelvan el valor actualizado del contador:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Contador</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">veces</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">func</span> <span class="nf">incrementa</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="n">veces</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">veces</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">incrementa</span><span class="p">(</span><span class="n">en</span> <span class="n">cantidad</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="n">veces</span> <span class="o">+=</span> <span class="n">cantidad</span>
        <span class="k">return</span> <span class="n">veces</span>
    <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">reset</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="n">veces</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">veces</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="nombres-locales-y-externos-de-parametros">Nombres locales y externos de parámetros<a class="headerlink" href="#nombres-locales-y-externos-de-parametros" title="Permanent link">&para;</a></h3>
<p>Ya vimos que los parámetros de las funciones pueden tener un nombre
interno y un nombre externo. Lo mismo sucede con los métodos, porque
los métodos no son más que funciones asociadas con un tipo.</p>
<p>Los nombres de los métodos en Swift se refieren normalmente al primer
parámetro usando una preposición como <code>con</code>, <code>en</code>, <code>a</code> o <code>por</code>, como
hemos visto en el ejemplo anterior <code>incrementa(en:)</code>. El uso de la
preposición permite que el método se lea como una frase.</p>
<p>El nombre de una parámetro se utiliza también como etiqueta del
argumento (nombre externo). Al igual que en las funciones, es posible
definir dos nombres del parámetro, uno externo y otro interno. Y el
nombre externo puede ser un <code>_</code> para indicar que no es necesario usar
la etiqueta del argumento.</p>
<p>Esta forma de invocar a los métodos hace que el lenguaje sea más
expresivo, sin necesidad de nombres largos de métodos o funciones.</p>
<p>Consideremos por ejemplo esta versión alternativa de la clase
<code>Contador</code>, que define una forma más compleja del método
<code>incrementa(en:)</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Contador</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">valor</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">func</span> <span class="nf">incrementa</span><span class="p">(</span><span class="n">en</span> <span class="n">cantidad</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">numeroDeVeces</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">valor</span> <span class="o">+=</span> <span class="n">cantidad</span> <span class="o">*</span> <span class="n">numeroDeVeces</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>El método <code>incrementa(en:numeroDeVeces:)</code> tiene dos parámetros:
<code>cantidad</code> y <code>numeroDeVeces</code>. El primer parámetro tiene un nombre
externo y otro interno. En el cuerpo del método se utiliza el nombre
interno (<code>cantidad</code>). El segundo parámetro <code>numeroDeVeces</code> es tanto
nombre externo como interno. Podemos llamar al método de la siguiente
forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">contador</span> <span class="p">=</span> <span class="n">Contador</span><span class="p">()</span>
<span class="n">contador</span><span class="p">.</span><span class="n">incrementa</span><span class="p">(</span><span class="n">en</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">numeroDeVeces</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">// el valor del contador es ahora 15</span>
</pre></div>
</td></tr></table>

<p>Al igual que en las funciones, podemos definir explícitamente los
nombres externos de los parámetros y usar el subrayado (<code>_</code>) para
indicar que ese parámetro no tendrá nombre externo.</p>
<h3 id="la-propiedad-self">La propiedad <code>self</code><a class="headerlink" href="#la-propiedad-self" title="Permanent link">&para;</a></h3>
<p>Toda instancia de un tipo tiene una propiedad implícita llamada
<code>self</code>, que es exactamente equivalente a la instancia misma. Podemos
usar la propiedad <code>self</code> para referirnos a la instancia actual dentro
de sus propios métodos de instancia.</p>
<p>El método <code>incrementa()</code> en el ejemplo anterior podría haberse escrito
de esta forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">incrementa</span><span class="p">()</span> <span class="p">{</span>
    <span class="kc">self</span><span class="p">.</span><span class="n">veces</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>En la práctica no es necesario usar <code>self</code> casi nunca. Swift asume que
cualquier referencia a una propiedad dentro de un método se refiere a
la propiedad de la instancia. El único caso en que es obligado usarlo
es cuando el nombre de la propiedad coincide con el nombre de un
parámetro. En esta situación el nombre del parámetro toma precedencia
y es necesario usar <code>self</code> para poder referirse a la propiedad de la
instancia.</p>
<p>Un ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Punto</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="mf">0.0</span>
    <span class="kd">func</span> <span class="nf">estaAlaDerecha</span><span class="p">(</span><span class="n">de</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">self</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">x</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">unPunto</span> <span class="p">=</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">)</span>
<span class="k">if</span> <span class="n">unPunto</span><span class="p">.</span><span class="n">estaAlaDerecha</span><span class="p">(</span><span class="n">de</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Este punto está a la derecha de la línea donde x == 1.0&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Imprime &quot;Este punto está a la derecha de la línea donde x == 1.0&quot;</span>
</pre></div>
</td></tr></table>

<h3 id="operaciones-con-instancias-de-tipo-valor">Operaciones con instancias de tipo valor<a class="headerlink" href="#operaciones-con-instancias-de-tipo-valor" title="Permanent link">&para;</a></h3>
<p>Las estructuras y las enumeraciones son <strong>tipos valor</strong>. Por defecto,
las propiedades de un tipo valor no pueden ser modificadas desde
dentro de los métodos de instancia.</p>
<p>Si queremos modificar una propiedad de un tipo valor la forma más
natural de hacerlo es creando una instancia nueva, usando el estilo de 
programación funcional:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Punto</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="mf">0.0</span>
    <span class="kd">func</span> <span class="nf">incrementa</span><span class="p">(</span><span class="n">incX</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">incY</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Punto</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="n">incX</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span><span class="o">+</span><span class="n">incY</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">unPunto</span> <span class="p">=</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="kd">var</span> <span class="nv">puntoMovido</span> <span class="p">=</span> <span class="n">unPunto</span><span class="p">.</span><span class="n">incrementa</span><span class="p">(</span><span class="n">incX</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">incY</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Hemos movido el punto a (</span><span class="si">\(</span><span class="n">puntoMovido</span><span class="p">.</span><span class="n">x</span><span class="si">)</span><span class="s">, </span><span class="si">\(</span><span class="n">puntoMovido</span><span class="p">.</span><span class="n">y</span><span class="si">)</span><span class="s">)&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;Hemos movido el punto a (3.0, 4.0)&quot;</span>
</pre></div>
</td></tr></table>

<h3 id="modificacion-de-tipos-valor-desde-dentro-de-la-instancia">Modificación de tipos valor desde dentro de la instancia<a class="headerlink" href="#modificacion-de-tipos-valor-desde-dentro-de-la-instancia" title="Permanent link">&para;</a></h3>
<p>Sin embargo, hay ocasiones en las que necesitamos modificar las
propiedades de nuestra estructura o enumeración dentro de un método
particular. </p>
<p>Necesitamos conseguir una conducta <em>mutadora</em> para ese método. El
método puede mutar (esto es, cambiar) sus propiedades desde dentro del
método, así como asignar una instancia completamente nueva a su
propiedad implícita <code>self</code>, con lo que esta nueva instancia
reemplazará la existente cuando el método termine.</p>
<p>Podemos conseguir esta conducta colocando la palabra clave <code>mutating</code>
antes de la palabra <code>func</code> del método:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Punto</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="mf">0.0</span>
    <span class="kr">mutating</span> <span class="kd">func</span> <span class="nf">incrementado</span><span class="p">(</span><span class="n">incX</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">incY</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">incX</span>
        <span class="n">y</span> <span class="o">+=</span> <span class="n">incY</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">unPunto</span> <span class="p">=</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="n">unPunto</span><span class="p">.</span><span class="n">incrementado</span><span class="p">(</span><span class="n">incX</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">incY</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;El punto está ahora en (</span><span class="si">\(</span><span class="n">unPunto</span><span class="p">.</span><span class="n">x</span><span class="si">)</span><span class="s">, </span><span class="si">\(</span><span class="n">unPunto</span><span class="p">.</span><span class="n">y</span><span class="si">)</span><span class="s">)&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;El punto está ahora en (3.0, 4.0)&quot;</span>
</pre></div>
</td></tr></table>

<p>La estructura <code>Punto</code> anterior define un método mutador
<code>incrementado(incX:incY:)</code> que mueve una instancia de <code>Punto</code> una cierta
cantidad. En lugar de devolver un nuevo punto, el método modifica
realmente el punto en el que es llamado. La palabra clave <code>mutating</code>
se añade a su definición para permitirle modificar sus propiedades.</p>
<p>Hay que hacer notar que no es posible llamar a un método mutador sobre
una constante de un tiempo estructura, porque sus propiedades no se
pueden cambiar, incluso aunque sean propiedades variables:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">puntoFijo</span> <span class="p">=</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="n">puntoFijo</span><span class="p">.</span><span class="n">incrementado</span><span class="p">(</span><span class="n">incX</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">incY</span><span class="p">:</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="c1">// esto provocará un error</span>
</pre></div>
</td></tr></table>

<h3 id="asignacion-a-self-en-un-metodo-mutador">Asignación a <code>self</code> en un método mutador<a class="headerlink" href="#asignacion-a-self-en-un-metodo-mutador" title="Permanent link">&para;</a></h3>
<p>Los métodos mutadores pueden asignar una nueva instancia completamente
nueva a la propiedad <code>self</code>. El anterior ejemplo <code>Punto</code> podría habers
escrito de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">struct</span> <span class="nc">Punto</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="mf">0.0</span>
    <span class="kr">mutating</span> <span class="kd">func</span> <span class="nf">incrementa</span><span class="p">(</span><span class="n">incX</span><span class="p">:</span> <span class="nb">Double</span><span class="p">,</span> <span class="n">incY</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="kc">self</span> <span class="p">=</span> <span class="n">Punto</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">incX</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">y</span> <span class="o">+</span> <span class="n">incY</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Esta versión del método mutador <code>incrementa(incX:incY:)</code> crea una
estructura nueva cuyos valores <code>x</code> e <code>y</code> se inicializan a los valores
desados. El resutado final de llamar a esta versión alternativa será
exactamente el mismo que llamar a la versión anterior (aunque con una
pequeña penalización de eficiencia: este método es 1,3 veces más lento
que el anterior en la versión 2.2 del compilador de Swift).</p>
<p>Los métodos mutadores de enumeraciones pueden establecer el parámetro
<code>self</code> implícito para que tenga un subtipo distinto de la misma
enumeración:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="nc">InterruptorTriEstado</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">apagado</span><span class="p">,</span> <span class="n">medio</span><span class="p">,</span> <span class="n">alto</span>
    <span class="kr">mutating</span> <span class="kd">func</span> <span class="nf">siguiente</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="kc">self</span> <span class="p">{</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">apagado</span><span class="p">:</span>
            <span class="kc">self</span> <span class="p">=</span> <span class="p">.</span><span class="n">medio</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">medio</span><span class="p">:</span>
            <span class="kc">self</span> <span class="p">=</span> <span class="p">.</span><span class="n">alto</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">alto</span><span class="p">:</span>
            <span class="kc">self</span> <span class="p">=</span> <span class="p">.</span><span class="n">apagado</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">var</span> <span class="nv">luzHorno</span> <span class="p">=</span> <span class="n">InterruptorTriEstado</span><span class="p">.</span><span class="n">medio</span>
<span class="n">luzHorno</span><span class="p">.</span><span class="n">siguiente</span><span class="p">()</span>
<span class="c1">// luzHorno es ahora .alto</span>
<span class="n">luzHorno</span><span class="p">.</span><span class="n">siguiente</span><span class="p">()</span>
<span class="c1">// luzHorno es ahora .apagado</span>
</pre></div>
</td></tr></table>

<h3 id="metodos-del-tipo">Métodos del tipo<a class="headerlink" href="#metodos-del-tipo" title="Permanent link">&para;</a></h3>
<p>Los métodos de instancia, como los descritos antes, se llaman en
instancias de un tipo particular. Es posible también definir métodos
que se llaman en el propio tipo. Esta clase de métodos se denominan
<em>métodos del tipo</em>. Se define un método del tipo escribiendo la
palabra clave <code>static</code> antes de la palabra clave <code>func</code> del
método. Las clases también pueden usar la palabra clave <code>class</code> para
permitir a las subclases sobreescribir la implementación del método.</p>
<p>Los métodos del tipo se invocan también con la sintaxis de punto,
escribiendo el nombre del tipo. Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">NuevaClase</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">unMetodoDelTipo</span><span class="p">()</span> <span class="p">{</span>
        <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Hola desde el tipo&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">NuevaClase</span><span class="p">.</span><span class="n">unMetodoDelTipo</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>Dentro del cuerpo del método, la propiedad implícita <code>self</code> se refiere
al propio tipo, más que a una instancia de ese tipo. Para estructuras
y enumeraciones, esto significa que puedes usar <code>self</code> para
desambiguar entre propiedades del tipo y los parámetros del método, de
la misma forma que se hace en los métodos de instancias.</p>
<p>Cualquier nombre de método o propiedad que se utilice en el cuerpo de
un método del tipo se referirá a otras propiedades o métodos de nivel
del tipo. Se puede utilizar estos nombres sin necesidad de añadir el
prefijo del nombre del tipo.</p>
<p>Por ejemplo, podemos añadir a la clase <code>Ventana</code> una propiedad
y método de clase con la que almacenar instancias de ventanas. Inicialmente
guardamos un array vacío.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">class</span> <span class="nc">Ventana</span> <span class="p">{</span>

    <span class="c1">// Propiedades</span>


    <span class="kd">static</span> <span class="kd">var</span> <span class="nv">ventanas</span><span class="p">:</span> <span class="p">[</span><span class="n">Ventana</span><span class="p">]</span> <span class="p">=</span> <span class="p">[]</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">registrar</span><span class="p">(</span><span class="n">ventana</span><span class="p">:</span> <span class="n">Ventana</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ventanas</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ventana</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Cada vez que creamos una ventana podemos llamar al método <code>registrar</code>
de la clase para añadirlo a la colección de ventanas de la clase:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">v1</span> <span class="p">=</span> <span class="n">Ventana</span><span class="p">()</span>
<span class="n">Ventana</span><span class="p">.</span><span class="n">registrar</span><span class="p">(</span><span class="n">ventana</span><span class="p">:</span> <span class="n">v1</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Se han registrado </span><span class="si">\(</span><span class="n">Ventana</span><span class="p">.</span><span class="n">ventanas</span><span class="p">.</span><span class="bp">count</span><span class="si">)</span><span class="s"> ventanas&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;Se han registrado 1 ventanas&quot;</span>
</pre></div>
</td></tr></table>

<!--

## Inicialización

_Inicialización_ es el proceso de preparar para su uso una instancia
de una clase, estructura o enumeración. Este proceso incluye la
asignación de un valor inicial para cada propiedad almacenada y la
ejecución de cualquier otra operación de inicialización que se
necesite para que la nueva instancia esté lista para usarse.

Para implementar este proceso de inicialización hay que definir
_inicializadores_, que son como métodos especiales que pueden llamarse
para crear una nueva instancia de un tipo particular. A diferencia de
otros lenguajes, los inicializadores en Swift no devuelven un
valor. Su papel principal es que las nuevas instancias del tipo estén
correctamente inicializadas antes de poder ser usadas por primera vez.

También es posible implementar _deinicializadores_, métodos que se
ejecutan cuando las instancias son eliminadas de la memoria (no vamos
a explicarlos por falta de tiempo).

El proceso de inicialización de una instancia puede resultar un
proceso complicado, sobre todo cuando se tienen relaciones de herencia
y hay que especificar también cómo realizar la inicialización de la
subclase utilizando la superclase. Por falta de tiempo no vamos a
explicar todo el proceso completo. Recomendamos consultar la
[documentación original de Swift](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203).

### Inicialización de propiedades almacenadas

Las clases y estructuras deben definir todas sus propiedades
almacenadas a un valor inicial en el tiempo en la instancia se
crea. Las propiedades almacenadas no pueden dejarse en un estado
indeterminado. Podemos definir el valor inicial para una propiedad en
un inicializador o asignándole un valor por defecto como parte de la
definición de la propiedad.

Un _inicializador_, en su forma más simple, es como un método de la
instancia sin parámetros, escrito con la palabra clave `init`:


wzxhzdk:48

Por ejemplo, podemos definir la estructura `Farenheit` que almacena
una temperatura en grados Farenheit. Tiene una propiedad almacenada de
tipo `Double`. Definimos un inicializador que inicializa las
instancias a 32.0 (equivalente a 0.0 grados Celsius).

wzxhzdk:49

La implementación anterior es equivalente a la siguiente (que es
preferible, por ser más clara):

wzxhzdk:50

### Customización de la inicialización

Es posible _customizar_ el proceso de inicialización con parámetros de
entrada y tipos opcionales, o asignando propiedades constantes durante
la inicialización.

Podemos proporcionar parámetros de inicialización como parte de la
definición de un inicializador, para definir los tipos y los nombres
de los valores que _customizan_ el proceso de inicialización. Los
parámetros de inicialización tienen las mismas capacidades y sintaxis
que los parámetros de funciones y métodos.

wzxhzdk:51

Vemos que dependiendo del nombre de parámetro proporcionado se escoge
un inicializador u otro. En los inicializadores es obligatorio
proporcionar los nombres de todos los parámetros:

wzxhzdk:52

Podemos evitar proporcionar nombres externos usando un subrayado. Por
ejemplo, podemos añadir al struct anterior `Celsius` un inicializador
sin nombre externo para el caso en que pasemos la temperatura inicial
precisamente en Celsius:

wzxhzdk:53

Por último, es posible dejar sin inicializar propiedades opcionales,
ya que el valor que tomarían sería `nil`:

wzxhzdk:54

En el ejemplo anterior se comprueba también que es posible inicializar
constantes. Por ejemplo, la propiedad `text` está definida con un
`let` y se inicializa en el inicializador.

Por último, es posible definir más de un inicializador, así como
invocar a inicializadores más básicos desde otros. Si definimos un
inicializador en una estructura los inicializadores por defecto dejan
de funcionar, es necesario escribirlos también.

wzxhzdk:55



## Herencia

Una clase puede _heredar_ métodos, propiedades y otras características
de otra clase. Cuando una clase hereda de otra, la clase que hereda se
denomina _subclase_, y la clase de la que se hereda se denomina su
_superclase_. La herencia es una conducta fundamental que diferencia
las clases de otros tipos en Swift.

Las clases en Swift pueden llamar y acceder a métodos y propiedades
que pertenecen a su superclase y pueden proporcionar sus propias
versiones que sobreescriben esos métodos y propiedades. Para
sobreescribir un método o una propiedad es necesario cumplir con la
definición proporcionada por la superclase.

Las clases también pueden añadir observadores a las propiedades
heredadas para ser notificadas cuando cambia el valor de una
propiedad. A cualquier propiedad se le puede añadir un observador de
propiedad, independientemente de si es originalmente una propiedad
almacenada o calculada.

### Definición de una clase base

Una clase que no hereda de ninguna otra se denomina una _clase base_
(_base class_). A diferencia de otros lenguajes orientados a objetos,
las clases en Swift no heredan de una clase base universal.

También a diferencia de otros lenguajes orientados a objetos Swift no
permite definir clases _abstractas_ que no permiten crear
instancias. Cualquier clase en Swift puede ser instanciada.

El siguiente ejemplo define una clase base llamada `Vehiculo`. Esta
clase base define una propiedad almacenada llamada `velocidadActual`
con un valor por defecto de 0.0. Esta propiedad se utiliza por una
propiedad `String` calculada llamada `descripcion` que crea una
descripción del vehículo.

La clase base `Vehiculo` también define un método llamdo
`hazRuido`. Este método no hace nada realmente para una instancia de
un vehículo base, pero será modificado más adelante por las subclases
de `Vehiculo`.

wzxhzdk:56

Creamos una instancia nueva de `Vehiculo` con la sintaxis de
inicialización que hemos visto, en la que se escribe el nombre del
tipo de la clase seguido por paréntesis vacíos:

wzxhzdk:57

Habiendo creado una instancia nueva de `Vehiculo`, podemos acceder a
su descripción:

wzxhzdk:58

La clase `Vehiculo` define características comunes para un vehículo
arbitrario, pero no es de mucha utilidad por si misma. Para hacerla
más útil, tenemos que refinarla para describir tipos de vehículos más
específicos.

### Construcción de subclases

La construcción de una subclase (_subclassing_) es la acción de basar
una nueva clase en una clase existente. La subclase hereda
características de la clase existente, que después podemos
refinar. También podemos añadir nuevas características a la subclase.

Para indicar que una subclase tiene una superclase hay que escribir el
nombre de la subclase antes de el de la superclase, separadas por dos
puntos (`:`):

wzxhzdk:59

En el ejemplo anterior del `Vehiculo` podemos definir una subclase
`Bicicleta`:

wzxhzdk:60

La nueva clase `Bicicleta` obtiene automáticamente todas las
características del `Vehiculo`, como sus propiedades `velocidadActual`
y `descripcion` y su método `haceRuido()`.

Además de las características que hereda, la clase `Bicicleta` define
una nueva propiedad almacenada, `tieneCesta`, con un valor por defecto
de `false`.

Por defecto, cualquier instancia nueva de `Bicicleta` no tendrá una
cesta. Puedes establecer la propiedad `tieneCesta` a `true` para una
instancia particular de `Bicicleta` después de crearla:

wzxhzdk:61

Podemos también modificar la propiedad heredada `velocidadActual` y
preguntar por la propiedad `descripcion`:

wzxhzdk:62

Podemos construir subclases a partir de otras subclases. El siguiente
ejemplo crea una subclase de `Bicicleta` que representa una bicicleta
de dos sillines (un "tandem"):

wzxhzdk:63

`Tandem` hereda todas las propiedades y métodos de `Bicicleta`, que a
su vez hereda todas sus propiedades y métodos de `Vehiculo`. La
subclase `Tandem` también añade una nueva propiedad almacenada llamada
`numeroActualDePasajeros`, con un valor por defecto de 0.

Si creamos una instancia de `Tandem` podremos trabajar con cualquiera
de sus propiedades nuevas y heredadas, y preguntar a la descripción de
solo lectura que hereda de `Vehiculo`:

wzxhzdk:64

### Sobreescritura

Una subclase puede proporcionar su propia implementación de un método
de la instancia, método del tipo, propiedad de la instancia o
propiedad del tipo que hereda de su superclase. Esto se conoce como
_sobreescritura_ (_overriding_).

Para sobreescribir una característica que sería de otra forma heredada
debemos usar el prefijo `override`. De esta forma se clarifica que
intentamos proporcionar una sobreescritura y que no lo hacemos por
error. Esta palabra clave también hace que el compilador comprueba que
la superclase (o una de sus clases padre) tiene una declaración que
empareja con la que proporcionamos en la sobreescritura.

Cuando proporcionamos una sobreescritura puede ser útil acceder a los
valores proporcionados por la clase padre. Para acceder a ellos
podemos usar el prefijo `super`.

El siguiente ejemplo define una nueva subclase de `Vehiculo` llamada
`Tren`, que sobreescribe el método `hazRuido()`:

wzxhzdk:65

Si creamos una nueva instancia de `Tren` y llamamos al método
`hazRuido` podemos comprobar que se llama a la versión del método de
la subclase:

wzxhzdk:66

Podemos sobreescribir cualquier propiedad heredada del tipo o de la
instancia y proporcionar nuestros propios _getters_ y _setters_ para
esa propiedad, o añadir observadores de propiedades para observar
cuando cambian los valores subyacentes de la propiedad.

Podemos proporcionar un _getter_ (o _setter_, si es apropiado) para
sobreescribir cualquier propiedad heredada, independientemente de si
la propiedad heredada se implementa como una propiedad almacenada o
calculada. La naturaleza almacenada o calculada no se conoce por la
subclase, que solo conoce su nombre y su tipo. Es posible convertir
una propiedad heredada de solo-lectura en una de lectura-escritura. No
es posible presentar una propiedad heredada de lectura-escritura como
de solo-lectura.

El siguiente ejemplo define una nueva clase llamada `Coche`, que es
una subclase de `Vehiculo`. La clase `Coche` introduce una nueva
propiedad almacenada llamada `marcha`, con un valor por defecto
de 1. También sobreescribe la propiedad heredada `descripcion`,
incluyendo la marcha actual en la descripción:

wzxhzdk:67

Podemos ver el funcionamiento en el siguiente ejemplo:

wzxhzdk:68

Por último, podemos añadir observadores a propiedades heredadas. Esto
nos permite ser notificados cuando el valor de una propiedad heredada
cambia, independientemente de si esa propiedad se ha implementado en
la subclase o en la superclase.

El siguiente ejemplo define una nueva clase llamada `CocheAutomatico`
que es una subclase de `Coche`. La clase `CocheAutomatico` representa
un coche con una caja de cambios automática, que selecciona
automáticamente la marcha basándose en la velocidad actual:

wzxhzdk:69

En cualquier momento que se modifica la propiedad `velocidadActual` de
una instancia de `CocheAutomatico`, el observador `didSet` establece
la propiedad `marcha` a un valor apropiado para la nueva velocidad. Un
ejemplo de ejecución:

wzxhzdk:70

Por último, es posible prevenir un método o propiedad de ser
sobreescrito declarándolo como _final_. Para ello, hay que escribir el
modificador `final` antes del nombre de la palabra clave que introduce
el método o la propiedad (como `final var`, `final func` o `final
class`). También es posible marcar la clase completa como final,
escribiendo el modificador antes de `class` (`final class`).



## Protocolos

Un _protocolo_ (_protocol_) define un esquema de métodos, propiedades
y otros requisitos que encajan en una tarea particular o un trozo de
funcionalidad. El protocolo puede luego ser _adoptado_ (_adopted_) por
una clase, estructura o enumarción para proporcionar una
implementación real de esos requisitos. Cualquier tipo que satisface
los requerimientos de un protocolo se dice que _se ajusta_ o _cumple_
(_conform_) ese protocolo.

Además de especificar los requisitos de los tipos que cumplen el
protocolo, también se puede **extender un protocolo** (lo veremos más
adelante, cuando hablemos de **extensiones**) para proporcionar una
implementación de algunos de los métodos requeridos por el protocolo.


### Sintaxis

Los protocolos se definen de forma similar a las clases, estructuras y
enumeraciones:

wzxhzdk:71

Para definir un tipo que se ajusta a un protocolo particular se debe
poner el nombre del protocolo tras el nombre del tipo, separado por
dos puntos. Podemos listar más de un protocolo, y se separan por
comas:

wzxhzdk:72

Si una clase tiene una superclase, se escribe el nombre de la
superclase antes los protocolos, seguido por una coma:

wzxhzdk:73

### Requisitos de propiedades

Un protocolo puede requerir a cualquier tipo que se ajuste a él que
proporcione una propiedad de instancia o de tipo con un nombre y tipo
particular. El protocolo no especifica si la propiedad es una
propiedad calculada o almacenada, sólo especifica el nombre y el tipo
de la propiedad requerida. El protocolo también especifica si la
propiedad debe ser de lectura y escritura o sólo de lectura.

Si un protocolo requiere que una propiedad sea de lectura y escritura,
el requisito no puede ser satisfecho por una propiedad constante
almacenada o por una propiedad calculada de sólo lectura. Si el
protocolo sólo requiere que la propiedad sea de lectura, el requisito
puede ser satisfecho por cualquier tipo de propiedad, y es válido que
la propiedad sea también de escritura si es útil para nuestro propio
código.

Los requisitos de la propiedad se declaran siempre como propiedades
variables, precedido por la palabra clave `var`. Las propiedades de
lectura y escritura se indican escribiendo `{ get set }` después de la
declaración de su tipo, y las propiedades de sólo lectura se indican
escribiendo `{ get }`.


wzxhzdk:74

Para definir una propiedad de tipo hay que precederla en el protocolo
con la palabra clave `static`:

wzxhzdk:75

Veamos un ejemplo. Definimos el protocolo `TieneNombre` en el que se
requiere que cualquier clase que se ajuste a él debe tener una
propiedad de instancia de lectura de tipo `String` que se llame
`nombreCompleto`:

wzxhzdk:76

Un ejemplo de una sencilla estructura que adopta el protocolo:

wzxhzdk:77

Este ejemplo define una estructure llamada `Persona`, que representa
una persona con una edad y un nombre específico. En la primera línea
se declara que se adopta el protocolo `TieneNombre`. Cada instancia de
`Persona` tiene la propiedad almacenada llamada `nombreCompleto`, que
es de tipo `String`. Esto cumple el único requisito del protocolo
`TieneNombre`, y signifca que `Persona` se ajusta correctamente al
protocolo (Swift informa de un error en tiempo de compilación si un
requisito de un protocolo no se cumple).

Otro ejemplo de una clase más compleja, que también adopta el protocolo:

wzxhzdk:78

Esta clase implementa el requisito de la propiedad `nombreCompleto`
como una propiedad calculada de solo lectura para una nave
estelar. Cada instancia de `NavaEstelar` almacena un nombre
obligatorio y un prefijo opcional. La propiedad `nombreCompleto` usa
el valor del prefijo si existe, y la añade al comienzo del nombre para
crear un nombre completo de la nave estelar.

### Requisitos de métodos

Los protocolos pueden requerir que los tipos que se ajusten a ellos
implementen métodos de instancia y de tipos específicos. Estos métodos
se escriben como parte de la definición del protocolo de la misma
forma que los métodos normales, pero sin sus cuerpos. Los métodos del
tipo en el protocolo deben indicarse con la palabra clave `static`:

wzxhzdk:79

Por ejemplo:

wzxhzdk:80

Este protocolo, `GeneradorNumerosAleatorios`, requiere que cualquier
tipo que se ajuste a él tenga un método de instancia llamado `random`,
que devuelve un valor `Double` cada vez que se llama. Aunque no está
especificado en el protocolo, se asume que este valor será un número
entre 0.0 y 1.0 (sin incluirlo). El protocolo
`GeneradorNumerosAleatorios` no hace ninguna suposición sobre cómo
será generado cada número aleatorio, simplemente requiere al generador
que proporcione una forma estándar de generarlo.

Una implementación de una clase que adopta el protocolo:

wzxhzdk:81

### Requisito de método `mutating`

Si definimos un protocolo con un requisito de método de instancia que
pretenda mutar las instancias del tipo que adopte el protocolo, se
debe marcar el método con la palabra `mutating`. Esto permite a las
estructuras y enumeraciones que adopten el protocolo definir ese
método como `mutating`. No es necesario hacerlo con las clases, porque
la palabra `mutating` solo es necesaria en estructuras y
enumeraciones.

Un ejemplo:

wzxhzdk:82

### Protocolos como tipos

Los protocolos no implementan realmente ninguna funcionalidad por
ellos mismos. Sin embargo, cualquier protocolo que definamos se
convierte automáticamente en un tipo con todas sus propiedades que
podemos usar en nuestro código.

Podemos entonces usar el protocolo en cualquier sitio donde permitamos
otros tipos, incluyendo:

- El tipo de un parámetro de una función, método o inicializador o de
  sus valores devueltos.
- El tipo de una constante, variable o propiedad
- El tipo de los ítems de un array, diccionario u otro contenedor

wzxhzdk:83

Este ejemplo define una nueva clase llamada `Dado`, que representa un
dado de _n_ caras que se puede usar en un juego de tablero. Las
instancias de dados tienen una propiedad llamada `caras`, que
representa cuántas caras tienen, y una propiedad llamada `generador`,
que proporciona un generador a partir del cual crear valores de
tiradas.

La propiedad generador es del tipo
`GeneradorNumerosAleatorios`. Podemos asignarle una instancia de
cualquier tipo que adopte el protocolo `GeneradorNumerosAleatorios`.

`Dado` tiene también un inicializador, para configurar sus estado
inicial. El inicializador tiene un parámetro llamado `generador`, que
también es del tipo `GeneradorNumerosAleatorios`. Podemos pasarle un
valor de cualquier instancia que se ajuste a este tipo. Y también
proporciona un método de instancia llamado `tirar`, que devuelve un
valor entero entre 1 y el número de caras del dado. Este método llama
al método `random()` del generador para crear un nuevo número
aleatorio entre 0.0 y 1.0 y usa este número aleatorio para crear un
valor de tirada que esté dentro del rango correcto. Debido a que
sabemos que el generador se ajusta al protocolo
`GeneradorNumerosAleatorios` tenemos la garantía de que va a existir
un método `random()` al que llamar.

Un ejemplo de uso del código:

wzxhzdk:84

### Colecciones de tipos protocolo

Como hemos comentado anteriormente, un protocolo puede usarse como el
tipo que se almacena un una colección (array, diccionario,
etc.). Veamos un ejemplo:

wzxhzdk:85

Hay que hacer notar que la constante `cosa` que itera sobre los
elementos del array es de tipo `TieneNombre`], no es de tipo `Persona`
ni de tipo `NaveEstelar`, incluso aunque las instancias que hay tras
de escena son do esos tipos. Por ser del tipo `TieneNombre` sabemos
que tiene una propiedad `nombreCompleto` que podemos usar sobre la
variable iteradora.

### Protocolos de la biblioteca estándar de Swift

En la [biblioteca estándar de
Swift](https://developer.apple.com/documentation/swift) se definen
distintos protocolos como `Collection` y `Equatable` que describen
abstracciones comunes. Muchos de estos protocolos incorporan
implementaciones por defecto de algunos de sus métodos mediante
extensiones definidas en la propia biblioteca estándar.

Veamos por ejemplo el protocolo
[`Equatable`](https://developer.apple.com/documentation/swift/equatable). Se
trata de un protocolo importante que define las operaciones de
igualdad (`==`) y diferencia (`!=`). Debemos implementar la operación
de igualdad en cualquier clase que se ajuste al protocolo, pero la
operación de diferencia ya tiene una implementación por defecto.

Un ejemplo:

wzxhzdk:86

El operador `==` se define en la propia estructura. Se utiliza la
palabra `static` para indicar que se trata de un operador que estamos
sobrecargando (hablaremos más adelante de los operadores).

El operador `!=` que se usa en la última instrucción se define en una
implementación por defecto.


## Casting de tipos

El _casting_ de tipos es una forma de comprobar el tipo de una
instancia o de tratar esa instancia como de una superclase distinta o
conseguir una subclase de algún otro sitio en la propia jerarquía de
clase. La forma de implementarlo es utilizando los operadores `is` y
`as`. Estos operadores proporcionan una forma simple y expresiva de
comprobar el tipo de un valor o transformar un valor en uno de otro
tipo. También se puede usar el _casting_ de tipos para comprobar si un
tipo se ajusta a un protocolo.

### Una jerarquía de clases para el casting de tipos

Vamos a comenzar construyendo una jerarquía de clases y subclases con
las que trabajar. Utilizaremos el _casting_ de tipos para comprobar el
tipo de una instancia particular de una clase y para convertir esa
instancia en otra clase dentro de la misma jerarquía.

En el primer fragmento de código definimos una clase nueva llamada
`MediaItem`. Esta clase proporciona la funcionalidad básica de
cualquier tipo de ítem que aparece en una biblioteca de medios
digitales. Específicamente, declara una propiedad `nombre` de tipo
`String` y un inicializador `init nombre` (suponemos que todos los
ítems, incluyendo películas y canciones, tendrán un nombre).

wzxhzdk:87

El siguiente fragmento define dos subclases de `MediaItem`. La primera
subclase, `Pelicula`, encapsula información adicional sobre una
película. Añade una propiedad `director` a la clase base `MediaItem`,
con su correspondiente inicializador. La segunda subclase, `Cancion`,
añade una propiedad `artista` y un inicializador a la clase base:

wzxhzdk:88

Por último, creamos un array constante llamado `biblioteca`, que
contienen dos instancias de `Pelicula` y tres instancias de
`Cancion`. 

wzxhzdk:89

Podríamos también dejar que el compilador infiera el tipo del
array. Es capaz de deducir que `Pelicula` y `Cancion` tienen una
superclase común `MediaItem`, por lo que **infiere que el tipo del
array es `[MediaItem]`**:

wzxhzdk:90

Los ítems almacenados en la biblioteca son todavía instancias de
`Pelicula` y `Cancion`. Sin embargo, si iteramos sobre los contenidos
de este array, los ítems que recibiremos tendrán el tipo `MediaItem` y
no `Pelicula` o `Cancion`. Para trabajar con ellos como su tipo
nativo, debemos chequear su tipo, y hacer un _downcast_ a su tipo
concreto.

### Comprobación del tipo

Podemos usar el _operador de comprobación_ (_check operator_) `is`
para comprobar si una instancia es de un cierto tipo subclase. El
operador de comprobación devuelve `true` si la instancia es del tipo
de la subclase y `false` si no.

Lo podemos comprobar en el siguiente ejemplo, en el que contamos las
instancias de películas y canciones en el array `biblioteca`:

wzxhzdk:91

El ejemplo itera por todos los ítems del array `biblioteca`. En cada
paso, el bucle `for-in` guarda en la constante `item` el siguiente
`MediaItem` del array.

La instrucción `item is Pelicula` devuelve `true` si el `MediaItem`
actual es una instancia de `Pelicula` y `false` en otro caso. De forma
similar, `item is Cancion` comprueba si el ítem es una instancia de
`Cancion`. Al final del bucle `for-in`, los valores de
`contadorPeliculas` y `contadorCanciones` contendrán una cuenta de
cuantas instancias `MediaItem` de cada tipo se han encontrado.


### Downcasting

Una constante o variable de un cierto tipo de clase puede referirse
(contener) a una instancia de una subclase. Cuando creemos que sucede
esto, podemos intentar hacer un _downcast_ al tipo de la subclase con
un operador de _cast_ (`as?` o `as!`). Como el _downcast_ puede
fallar, la versión condicional, `as?`, devuelve un valor opcional del
tipo al que estamos intentando hacer el _downcasting_. La versión
forzosa, `as!`, intenta el _downcast_ y fuerza la desenvoltura del
resultado en un única acción compuesta.

Debemos usar la versión condicional (`as?`) cuando no estamos seguros
si el _downcast_ tendrá éxito. Se devolverá un valor opcional y el
valor será `nil` si no es posible hacer el _downcast_. Esto permitirá
comprobar si ha habido un _downcast_ con éxito.

La otra versión (`as!`) se usa sólo cuando estamos seguros de que el
_downcast_ tendrá éxito. Esta versión del operador lanzará un error en
tiempo de ejecución si intentamos hacer un _downcast_ a un tipo
incorrecto.

El siguiente ejemplo itera sobre cada `MediaIyem` en `biblioteca`, e
imprime una descripción apropiada para cada ítem. Para hacerlo,
necesita acceder a cada ítem como una `Pelicula` o `Cancion` y no sólo
como una `MediaItem`. Esto es necesario para poder acceder a la
propiedad `director` o `artista` de una instancia de `Pelicula` o
`Cancion`.

En este ejemplo, cada ítem en el array podría ser un `Pelicula` o
podría ser una `Cancion`. No sabemos por anticipado la clase verdadera
de cada ítem, por lo que es apropiado usar la versión condicional
(`as?`) para comprobar el _downcast_ cada vez a lo largo del bucle:

wzxhzdk:92

El ejemplo comienza intentando hacer `downcast` del ítem a una
`Pelicula`. Debido a que es una instancia de `MediaItme`, es posible
que sea un `Pelicula` o una `Cancion`, o incluso el tipo base
`MediaItem`. Debido a esta incertidumbre, debemos usar la versión
`as?` para devolver un valor opcional. El resultado será una "Pelicula
opcional". Podemos desenvolver el valor `Pelicula` usando un `if let`
como vimos en el apartado de opcionales. Si tiene éxito el
_downcasting_, las propiedades de la película se pueden usar para
imprimir una descripción de la película llamando a los
correspondientes métodos de la clase `Pelicula`. Igual con `Cancion`.


### _Casting_ para `Any` 

El tipo `Any` puede representar una instancia de cualquier tipo,
incluyendo tipos función:

wzxhzdk:93

El array contiene dos valores `Int`, dos valores `Double`, un valor
`String`, una tupla del tipo `(Double, Double)`, la película
"Ghostbusters", y una clausura que toma un `String` y devuelve otro
`String`.

Puedes usar los operadores `is` y `as` en una sentencia `switch` para
descubrir en tiempo de ejecución el tipo específico de una constante o
variable de la que sólo se sabe que es de tipo `Any`:

wzxhzdk:94

### Comprobación de ajustarse a un protocolo

Podemos usar también los operadores anteriores `is` y `as` (y `as?` y
`as!`) para comprobar si una instancia se ajusta a un protocolo y para
hacer un _cast_ a un protocolo específico.

Veamos un ejemplo. Definimos el protocolo `TieneArea` con el único
requisito de una propiedad de lectura llamada `area` de tipo `Double`:

wzxhzdk:95

Definimos dos clases `Circulo` y `Pais` que se ajustan ambos al protocolo: 

wzxhzdk:96

La clase `Circulo` implementa el requisito como una propiedad
calculada, basada en la propiedad almacenada `radio`. La clase `Pais`
implementa el requisito directamente como una propiedad
almacenada. Ambas clases se ajustan correctamente al protocolo
`TieneArea`.

Definimos una clase `Animal` que no se ajusta al protocolo:

wzxhzdk:97

Las clases `Circulo`, `Pais` y `Animal` no tienen ninguna clase base
compartida. Sin embargo, todas son clases, por lo que las instancias
de los tres tipos pueden usarse para inicializar un array que almacena
valores de tipo `Any`:

wzxhzdk:98

Y ahora podemos iterar sobre el array de objetos, comprobando para
cada ítem si la instancia se ajusta al protocolo `TieneArea`:

wzxhzdk:99

Cuando un objeto en el array se ajusta al protocolo `TieneArea`, el
valor opcional devuelto por el operador `as?` se desenvuelve con un
ligado opcional en una constante llamada `objetoConArea`. Esta
constante tiene el tipo `TieneArea`, por lo que su propiedad `area`
podrá ser accedida e impresa.

Hay que notar que los objetos subyacentes no cambian en el proceso de
_casting_. Siguen siendo un `Circulo`, un `Pais` y un `Animal`. Sin
embargo, en el momento en se almacenan en la constante
`objetoConArea`, sólo se sabe que son del tipo `TieneArea`, por lo que
sólo podremos acceder a su propiedad `area`.


## Extensiones

Las _extensiones_ añaden nueva funcionalidad a una clase, estructura,
enumeración o protocolo. Esto incluye la posibilidad de extender tipos
para los que no tenemos acceso al código fuente original (esto se
conoce como _modelado retroactivo_).

Entre otras cosas, las extensiones pueden: 

- Añadir propiedades calculadas de instancia y de tipo
- Definir métodos de instancia y de tipo
- Proporcionar nuevos inicializadores
- Hacer que un tipo existente se ajuste a un protocolo


### Sintaxis

Para declarar una extensión hay que usar la palabra clave `extension`:

wzxhzdk:100

### Propiedades calculadas

Las extensiones pueden añadir propiedades calculadas de instancias y
de tipos. Como primer ejemplo, vamos a añadir a la clase persona la
propiedad calcula `mayorEdad`, un `Bool` que indica si la edad de la
persona es mayor o igual de 18:

wzxhzdk:101

Una vez definida esta extensión, hemos ampliado la clase con esta
nueva propiedad, sin tocar el código de la clase. Podemos preguntar si
una persona es mayor de edad:

wzxhzdk:102

Es posible incluso extender clases de las librerías estándar de
Swift, como `Int`, `Double`, `Array`, etc.

Por ejemplo, podemos añadir propiedades calculadas a la clase Double
para trabajar con unidades de distancia. Las siguientes propiedades
convierten una cantidad en las unidades correspondientes a su
equivalente en metros:


wzxhzdk:103

Estas propiedades calculadas expresan que un valor `Double` debería
considerarse como una cierta unidad de longitud. Aunque se implementan
como propiedades calculadas, los nombres de las propiedades pueden
añadirse a un literal en punto flotante con la sintaxis del punto,
como una forma de usar el valor del literal para ejecutar conversiones
de distancia.

Por ejemplo, cuando se escribe `11.km` se pide el valor de la
propiedad calculada `km` de la instancia `11`. La propiedad calculada
devuelve el resultado de multiplicar `11` por `1000`, esto es, los
metros correspondientes a 11 kilómetros.

De forma similar, hay 3.28084 pies en un metro, por lo que la
propiedad calculada `ft` divide el valor `Double` subyacente por
3.28084, para conventirlo de pies a metros.

Estas propiedades son propiedades calculadas de solo lectura, por lo
que se expresan sin la palabra clave `get`, por brevedad. Sus valores
devueltos son de tipo `Double`, y pueden usarse en cálculos
matemáticos en cualquier sitio que se acepte un `Double`:

wzxhzdk:104


### Inicializadores

Las extensiones pueden añadir nuevos inicializadores a tipos
existentes. Esto nos permite extender otros tipos para aceptar
nuestros propios tipos como parámetros de la inicialización, o para
proporcionar opciones adicionales que no estaban incluidos en la
implementación original del tipo.

El siguiente ejemplo define una estructura `Rectangulo` que representa
un rectángulo geométrico. Este ejemplo también define dos estructuras
auxiliares llamadas `Tamaño` y `Punto`, que proporcionan valores por
defecto de 0.0 a todas sus propiedades:

wzxhzdk:105

Debido a que la estructura `Rectangulo` proporciona valores por
defecto para todas sus propiedades, tiene un inicializador por defecto
que puede utilizarse para crear nuevas instancias. También podemos
inicializarlo asignando todas sus propieades:

wzxhzdk:106

Podemos extender la estructura `Rectangulo` para proporcionar un
inicializador adicional que toma un punto específico del centro y un
tamaño:

wzxhzdk:107

Este nuevo inicializador empieza por calcular un punto de origen
basado en el centro propuesto y en el tamaño. El inicializador llama
después al inicializador automático de la estructura
`init(origen:tamaño:)`, que almacena los nuevos valores de las
propiedades:

wzxhzdk:108

### Métodos

Las extensiones pueden añadir nuevos métodos de instancia y nuevos
métodos del tipo. 

Por ejemplo, podemos añadir el método `descripcion()` a la estructura `Persona`:

wzxhzdk:109

También podemos añadir métodos a clases y estructuras importadas. Por
ejemplo podemos añadir un nuevo método de
instancia llamado `repeticiones` al tipo `Int`:


wzxhzdk:110

El método `repeticiones(_:)` toma un único argumento de tipo `() ->
Void`, que indica una función que no tiene parámetros y no devuelve
ningún valor. Después de definir esta extensión, podemos llamar al
método `repeticiones(_:)` en cualquier número entero para ejecutar una
tarea un cierto número de veces:


wzxhzdk:111

Usando clausuras por la cola podemos hacer la llamada más concisa:

wzxhzdk:112

### Métodos de instancia mutadores

Los métodos de instancia añadidos con una extensión también pueden
modificar (o mutar) la propia instancia. Los métodos de las
estructuras y los enumerados que modifican `self` o sus propiedades
deben marcarse como `mutating`.

Por ejemplo: 

wzxhzdk:113


### Ajustar un tipo a un protocolo mediante una extensión


Una extensión puede extender un tipo existente para hacer que se
ajuste a uno o más protocolos. En este caso, los nombres de los
protocolos se escriben exactamente de la misma forma que en una clase
o estructura:


wzxhzdk:114

Las instancias del tipo adoptarán automáticamente el protocolo y se
ajustarán al protocolo con las propiedades y métodos añadidos por la
extensión.

Por ejemplo, este protocolo, llamado `RepresentableComoTexto` puede
ser implementado por cualquier tipo que tenga una forma de
representarse como texto. Esto puede ser una descripción de si mismo o
una versión de texto de su estado actual:

wzxhzdk:115

La clase `Dado` que vimos anteriormente puede extenderse para ajustarse al protocolo:

wzxhzdk:116

Esta extensión adopta el nuevo protocolo exactamente como si el `Dado`
lo hubiera proporcionado en su implementación original. El nombre del
protocolo se indica tras el nombre del tipo, separado por dos puntos,
y se proporciona una implementación entre llaves.

Cualquier instancia de un dado se puede tratar ahora como `RepresentableComoTexto`:

wzxhzdk:117

De forma similar, un `Rectangulo` también puede extenderse para
adoptar y ajustarse al protocolo:

wzxhzdk:118

### Declaración de la adopción de un protocolo con una extensión

Si un tipo ya se ajusta a todos los requisitos de un protocolo, pero
todavía no se ha declarado que se ajusta al protocolo, podemos hacer
que lo adopte con una extensión vacía:

wzxhzdk:119

Las instancias de `Hamster` pueden ahora usarse en cualquier sitio que
se requiera un tipo `RepresentableComoTexto`:

wzxhzdk:120

### Implementación de métodos de un protocolo

Podemos definir extensiones en los protocolos para proporcionar
implementaciones de métodos y propiedades a todos los tipos que se
ajustan a él. Esto permite definir conductas en los propios
protocolos, más que en cada tipo individual o en una función global.

Por ejemplo, el protocolo `GeneradorNumerosAleatorios` puede ser extendido
para proporcionar un método `boolAleatorio()`, que usa el resultado del
`random()` requerido para devolver un valor `Bool` aleatorio:

wzxhzdk:121

Al crear una extensión en el protocolo, todos los tipos que se ajustan
a él adquieren automáticamente esta implementación sin ninguna
modificación adicional.

wzxhzdk:122

El tipo que se ajusta al protocolo puede proporcionar su propia
implementación, que se usará en lugar de la proporcionada por la extensión.

### Restricción en las extensiones de un protocolo ####

En la definición de una extensión de un protocolo es posible definir
restricciones que deben cumplir los tipos que lo cumplen. Los métodos
y propiedades de la extensión sólo estarán disponibles en aquellos
tipos que cumplan estos requisitos.

Los requisitos se definen usando una cláusula genérica `where`.

Por ejemplo, podemos definir una extensión al protocolo `Collection`
que se aplique a cualquier colección cuyos elementos cumplen el
protocolo `Equatable`. De esta forma nos aseguramos de que los
operadores `==` y `!=` están definidos y podemos usarlos en la extensión:

wzxhzdk:123

El método `allEqual()` devuelve `true` si y sólo si todos los
elementos en la colección son iguales.

Un ejemplo:

wzxhzdk:124

Dado que ambos arrays cumplen el protocolo `Collection` y los enteros
cumplen el protocolo `Equatable` podemos usar el método `allEqual()`: 

wzxhzdk:125

En una colección de una clase que no cumple el protocolo
`Equatable` no se puede utilizar el método de la extensión:

wzxhzdk:126

## Funciones operadoras

Las clases y las estructuras pueden proporcionar sus propias
implementaciones de operadores existentes. Esto se conoce como
_sobrecarga_ de los operadores existentes.

En el siguiente ejemplo se muestra cómo implementar el operador de
suma (`+`) para una estructura. El operador suma es un operador
binario (tiene dos operandos) e infijo (aparece junto entre los dos
operandos). Definimos una estructura `Vector2D` para un vector de
posición de dos dimensiones:


wzxhzdk:127

La función operador se define como una función estática con un un
nombre de función que empareja con el operador a sobrecargar
(`+`). Debido a que la suma aritmética se define como un operador
binario, esta función operador toma dos parámetros de entrada de tipo
`Vector2D` y devuelve un único valor de salida, también de tipo
`Vector2D`.

En esta implementación, llamamos a los parámetros de entrada
`izquierdo` y `derecho` para representar las instancias de `Vector2D`
que estarán a la izquierda y a la derecha del operador `+`. La función
devuelve una nueva instancia de `Vector2D`, cuyas propiedades `x` e
`y` se inicializan con la suma de las propiedades `x` e `y` de las
instancias de `Vector2D` que se están sumando.

La función se define globalmente, más que como un método en la
estructura `Vector2D`, para que pueda usarse como un operador infijo
entre instancias existentes de `Vector2D`:


wzxhzdk:128

### Operadores prefijos y postfijos

El ejemplo anterior demuestra una implementación propia de un operador
binario infijo. Las clases y las estructuras pueden también
proporcionar implementaciones de los operadores unarios estándar. Los
operadores unarios operan sobre un único objetivo. Son prefijos se
preceden el objetivo (como `-a`) y postfijos si siguen su objetivo
(como en `b!`).

Para implementar un operador unario prefijo o postfijo se debe
escribir el modificador `prefix` o `postfix` antes de la palabra clave
`func` en la declaración de la función operador:

wzxhzdk:129

El ejemplo anterior implementa el operador unario negación (`-a`) para
instancias de `Vector2D`.

Por ejemplo:

wzxhzdk:130

### Operadores de equivalencia

Como ya hemos visto, las clases y estructuras construidas no tienen
una implementación por defecto de los operadores "igual a" (`==`) y
"no igual a" (`!=`). No es posible para Swift adivinar qué valores
serán "iguales" en nuestras clases, porque el significado de "igual"
depende del papel que esos tipos juegan en nuestro código.

Para poder usar los operadores de igualdad en nuestros propios tipos,
debemos proporcionar una implementación de la misma forma que para
otros operadores infijos.

Lo hacemos definiendo una extensión que cumple el protocolo
`Equatable`. De esta forma, como ya hemos visto anteriormente,
conseguimos la implementación por defecto del operador `!=`:

wzxhzdk:131

En el ejemplo anterior se implementa un operador "igual a" (`==`) que
comprueba si dos instancias de `Vector2D` tienen valores
equivalentes. En el contexto del `Vector2D` tiene sentido considerar
"igual" como "ambas instancias tienen los mismos valores x e y", por
lo que esta es la lógica usada por la implementación. 

La implementación por defecto del operador "no igual a" (`!=`),
simplemente devuelve el inversa del resultado del operador "igual a".

Ahora podemos usar estos operadores para chequear si dos instancias de
`Vector2D` son equivalentes:

wzxhzdk:132

## Genéricos

Veamos cómo podemos utilizar los genéricos con clases y estructuras.

Vamos a utilizar como ejemplo un tipo de dato muy sencillo: una pila
(_stack_) en la que se podrán añadir (_push_) y retirar (_pop_)
elementos.

La versión no genérica del tipo de dato es la siguiente, en la que se
implementa una pila de enteros.

wzxhzdk:133

La estructura usa un array para guardar los ítems y los métodos `push`
y `pop` añaden y retiran los elementos. 

El problema de esta estructura es su falta de genericidad; sólo puede
almacenar enteros.

Aquí está una versión genérica del mismo código:

wzxhzdk:134

El parámetro del tipo `Element` define un tipo genérico que se utiliza
como _placeholder_ del tipo real del que se declare la
estructura. Podemos ver que se utiliza en la definición de los
distintos elementos de la estructura. Por ejemplo, el array de ítems
es un array de `Element`s. Y los ítems añadidos y retirados de la pila
son también objetos de tipo `Element`.

Por ejemplo, podemos crear una pila de cadenas:

wzxhzdk:135

Y podemos retirar la última cadena de la pila:

wzxhzdk:136

### Extensión de un tipo genérico

Cuando se extiende un tipo genérico, no hace falta añadir el parámetro
del tipo entre `<>`. El tipo genérico está disponible a partir de la
definición original y se puede usar tal cual en el cuerpo de la
extensión.

Por ejemplo, podemos extender el tipo genérico `Stack` para añadir una
propiedad computable de sólo lectura que devuelva el tope de la pila:

wzxhzdk:137

En la extensión se utiliza el nombre genérico `Element` sin tener que
declararlo después de `Stack`, porque está definido en la estructura
original.

Ahora ya se puede acceder al tope de la pila sin retirar el elemento:

wzxhzdk:138

## Bibliografía

- Swift Language Guide
    - [Classes and Structures](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/ClassesAndStructures.html#//apple_ref/doc/uid/TP40014097-CH13-ID82)
    - [Properties](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254)
    - [Methods](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html#//apple_ref/doc/uid/TP40014097-CH15-ID234)
    - [Inheritance](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Inheritance.html#//apple_ref/doc/uid/TP40014097-CH17-ID193=)
    - [Initialization](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203)
    - [Protocolos](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267)
    - [Casting de tipos](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TypeCasting.html#//apple_ref/doc/uid/TP40014097-CH22-ID338)
    - [Extensiones](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151)
    - [Funciones operador](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AdvancedOperators.html#//apple_ref/doc/uid/TP40014097-CH27-ID28)
    - [Genéricos](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179)
-->

<hr />
<p>Lenguajes y Paradigmas de Programación, curso 2018–19<br />
© Departamento Ciencia de la Computación e Inteligencia Artificial, Universidad de Alicante<br />
Domingo Gallardo, Cristina Pomares, Antonio Botía, Francisco Martínez</p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../tema05-programacion-funcional-swift/tema05-programacion-funcional-swift.html" title="Tema 5: Programación funcional con Swift" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Anterior
                </span>
                Tema 5: Programación funcional con Swift
              </span>
            </div>
          </a>
        
        
          <a href="../../seminarios/seminario1-scheme/seminario1-scheme.html" title="Seminario de Scheme" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Siguiente
                </span>
                Seminario de Scheme
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.dc02f8ce.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
    
  </body>
</html>