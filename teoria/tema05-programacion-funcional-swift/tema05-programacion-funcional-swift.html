



<!DOCTYPE html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copiar al portapapeles">
      
        <meta name="lang:clipboard.copied" content="Copiado al portapapeles">
      
        <meta name="lang:search.language" content="es">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No se encontraron documentos">
      
        <meta name="lang:search.result.one" content="1 documento encontrado">
      
        <meta name="lang:search.result.other" content="# documentos encontrados">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-3.0.4">
    
    
      
        <title>Tema 5: Programación Funcional con Swift - LPP</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.451f80e5.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.22915126.css">
      
      
        
        
        <meta name="theme-color" content="#009688">
      
    
    
      <script src="../../assets/javascripts/modernizr.1aa3b519.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="teal" data-md-color-accent="teal">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="../../#tema-5-programacion-funcional-con-swift" tabindex="1" class="md-skip">
        Saltar a contenido
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="LPP" class="md-header-nav__button md-logo">
          
            <img src="../../imagenes/logo.png" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            
              <span class="md-header-nav__topic">
                LPP
              </span>
              <span class="md-header-nav__topic">
                Tema 5: Programación Funcional con Swift
              </span>
            
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          
            <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
            
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Teclee para comenzar búsqueda
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
          
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="LPP" class="md-nav__button md-logo">
      
        <img src="../../imagenes/logo.png" width="48" height="48">
      
    </a>
    LPP
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1">
    
    <label class="md-nav__link" for="nav-1">
      Teoría
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        Teoría
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../tema00-descripcion-asignatura/tema00-descripcion-asignatura.html" title="Descripción de la asignatura" class="md-nav__link">
      Descripción de la asignatura
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema01-historia-lenguajes-programacion/tema01-historia-lenguajes-programacion.html" title="Tema 1: Historia de los lenguajes de programación" class="md-nav__link">
      Tema 1: Historia de los lenguajes de programación
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema02-programacion-funcional/tema02-programacion-funcional.html" title="Tema 2: Programación funcional" class="md-nav__link">
      Tema 2: Programación funcional
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema03-procedimientos-recursivos/tema03-procedimientos-recursivos.html" title="Tema 3: Procedimientos recursivos" class="md-nav__link">
      Tema 3: Procedimientos recursivos
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../tema04-estructuras-recursivas/tema04-estructuras-recursivas.html" title="Tema 4: Estructuras recursivas" class="md-nav__link">
      Tema 4: Estructuras recursivas
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Seminarios
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Seminarios
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../seminarios/seminario1-scheme/seminario1-scheme.html" title="Seminario de Scheme" class="md-nav__link">
      Seminario de Scheme
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      Prácticas
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Prácticas
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica01/practica01.html" title="Práctica 1" class="md-nav__link">
      Práctica 1
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica02/practica02.html" title="Práctica 2" class="md-nav__link">
      Práctica 2
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica03/practica03.html" title="Práctica 3" class="md-nav__link">
      Práctica 3
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica04/practica04.html" title="Práctica 4" class="md-nav__link">
      Práctica 4
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../practicas/practica05/practica05.html" title="Práctica 5" class="md-nav__link">
      Práctica 5
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduccion" title="Introducción" class="md-nav__link">
    Introducción
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#funciones" title="Funciones" class="md-nav__link">
    Funciones
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#definicion-de-una-funcion-en-swift" title="Definición de una función en Swift" class="md-nav__link">
    Definición de una función en Swift
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#etiquetas-de-argumentos-y-nombres-de-parametros" title="Etiquetas de argumentos y nombres de parámetros" class="md-nav__link">
    Etiquetas de argumentos y nombres de parámetros
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parametros-y-valores-devueltos" title="Parámetros y valores devueltos" class="md-nav__link">
    Parámetros y valores devueltos
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tipos-funcion" title="Tipos función" class="md-nav__link">
    Tipos función
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#funciones-que-reciben-otras-funciones" title="Funciones que reciben otras funciones" class="md-nav__link">
    Funciones que reciben otras funciones
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#funciones-en-estructuras" title="Funciones en estructuras" class="md-nav__link">
    Funciones en estructuras
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#funciones-que-devuelven-otras-funciones" title="Funciones que devuelven otras funciones" class="md-nav__link">
    Funciones que devuelven otras funciones
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#recursion" title="Recursión" class="md-nav__link">
    Recursión
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tipos" title="Tipos" class="md-nav__link">
    Tipos
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#tipos-con-nombre" title="Tipos con nombre" class="md-nav__link">
    Tipos con nombre
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tipos-compuestos" title="Tipos compuestos" class="md-nav__link">
    Tipos compuestos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enumeraciones" title="Enumeraciones" class="md-nav__link">
    Enumeraciones
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#valores-brutos-de-enumeraciones" title="Valores brutos de enumeraciones" class="md-nav__link">
    Valores brutos de enumeraciones
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#valores-asociados-a-instancias-de-enumeraciones" title="Valores asociados a instancias de enumeraciones" class="md-nav__link">
    Valores asociados a instancias de enumeraciones
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#enumeraciones-recursivas" title="Enumeraciones recursivas" class="md-nav__link">
    Enumeraciones recursivas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#typealias" title="Typealias" class="md-nav__link">
    Typealias
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opcionales" title="Opcionales" class="md-nav__link">
    Opcionales
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sentencias-if-y-desenvoltura-forzosa" title="Sentencias if y desenvoltura forzosa" class="md-nav__link">
    Sentencias if y desenvoltura forzosa
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ligado-opcional" title="Ligado opcional" class="md-nav__link">
    Ligado opcional
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ejemplos-de-uso-de-opcionales" title="Ejemplos de uso de opcionales" class="md-nav__link">
    Ejemplos de uso de opcionales
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#inmutabilidad" title="Inmutabilidad" class="md-nav__link">
    Inmutabilidad
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#palabra-clave-let" title="Palabra clave let" class="md-nav__link">
    Palabra clave let
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#semantica-de-copia-en-estructuras" title="Semántica de copia en estructuras" class="md-nav__link">
    Semántica de copia en estructuras
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estructuras-mutables-y-let" title="Estructuras mutables y let" class="md-nav__link">
    Estructuras mutables y let
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tipos-valor-y-tipos-referencia" title="Tipos valor y tipos referencia" class="md-nav__link">
    Tipos valor y tipos referencia
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#clausuras" title="Clausuras" class="md-nav__link">
    Clausuras
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#expresiones-de-clausuras" title="Expresiones de clausuras" class="md-nav__link">
    Expresiones de clausuras
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#el-metodo-sortedby" title="El método sorted(by:)" class="md-nav__link">
    El método sorted(by:)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sintaxis-de-las-expresiones-de-clausura" title="Sintaxis de las expresiones de clausura" class="md-nav__link">
    Sintaxis de las expresiones de clausura
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#inferencia-del-tipo-por-el-contexto" title="Inferencia del tipo por el contexto" class="md-nav__link">
    Inferencia del tipo por el contexto
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#devoluciones-implicitas-en-clausuras-con-una-unica-expresion" title="Devoluciones implícitas en clausuras con una única expresión" class="md-nav__link">
    Devoluciones implícitas en clausuras con una única expresión
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#abreviaturas-en-los-nombres-de-los-argumentos" title="Abreviaturas en los nombres de los argumentos" class="md-nav__link">
    Abreviaturas en los nombres de los argumentos
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#funciones-operadoras" title="Funciones operadoras" class="md-nav__link">
    Funciones operadoras
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clausuras-al-final" title="Clausuras al final" class="md-nav__link">
    Clausuras al final
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#valores-capturados" title="Valores capturados" class="md-nav__link">
    Valores capturados
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mutacion-de-variables-capturadas" title="Mutación de variables capturadas" class="md-nav__link">
    Mutación de variables capturadas
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#las-clausuras-son-tipos-de-referencia" title="Las clausuras son tipos de referencia" class="md-nav__link">
    Las clausuras son tipos de referencia
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#funciones-de-orden-superior" title="Funciones de orden superior" class="md-nav__link">
    Funciones de orden superior
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#map" title="Map" class="md-nav__link">
    Map
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#filter" title="Filter" class="md-nav__link">
    Filter
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reduce" title="Reduce" class="md-nav__link">
    Reduce
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#combinacion-de-funciones-de-orden-superior" title="Combinación de funciones de orden superior" class="md-nav__link">
    Combinación de funciones de orden superior
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#genericos" title="Genéricos" class="md-nav__link">
    Genéricos
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bibliografia" title="Bibliografía" class="md-nav__link">
    Bibliografía
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#closures" title="Closures" class="md-nav__link">
    Closures
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="tema-5-programacion-funcional-con-swift">Tema 5: Programación Funcional con Swift<a class="headerlink" href="#tema-5-programacion-funcional-con-swift" title="Permanent link">&para;</a></h1>
<h2 id="introduccion">Introducción<a class="headerlink" href="#introduccion" title="Permanent link">&para;</a></h2>
<p>Te recomendamos que leas el
<a href="https://github.com/domingogallardo/apuntes-lpp/blob/master/seminarios/seminario2-swift/seminario2-swift.md">seminario de Swift</a>,
en el que se introduce el lenguaje y se explica cómo ejecutar
programas en este lenguaje:</p>
<ul>
<li><a href="https://github.com/domingogallardo/apuntes-lpp/blob/master/seminarios/seminario2-swift/seminario2-swift.md#-1-el-lenguaje-de-programación-swift">El lenguaje de programación Swift</a></li>
</ul>
<p>Swift es un lenguaje principalmente imperativo, pero en su diseño se
han introducido conceptos modernos de programación funcional,
extraídos de lenguajes como Rust o Haskell. </p>
<p>Como dice su creador <a href="http://nondot.org/sabre/">Chris Lattner</a>:</p>
<blockquote>
<p>El lenguaje Swift es el resultado de un esfuerzo incansable de un
equipo de expertos en lenguajes, gurús de documentación, ninjas de
optimización de compiladores [..]. Por supuesto, también se
benefició enormemente de las experiencias ganadas en muchos otros
lenguajes, tomando ideas de Objective-C, Rust, Haskell, Ruby,
Python, C#, CLU, y demasiados otros para ser enumerados.</p>
</blockquote>
<p>Vamos a repasar en este tema cómo se implementan en Swift conceptos
principalmente funcionales como:</p>
<ul>
<li>Valores inmutables</li>
<li>Funciones como objetos de primera clase y clasuras</li>
<li>Funciones de orden superior</li>
</ul>
<p>Repasamos rápidamente algunos conceptos básicos de programación
funcional, vistos en los primeros temas de la asignatura.</p>
<p>Programación Funcional:</p>
<blockquote>
<p>La Programación Funcional es un paradigma de programación que trata
la computación como la evaluación de funciones matemáticas y que
evita cambios de estado y datos mutables.</p>
</blockquote>
<p>Funciones matemáticas o puras:</p>
<blockquote>
<p>Las funciones matemáticas tienen la característica de que cuando las
invocas con el mismo argumento siempre te devolverán el mismo
resultado.</p>
</blockquote>
<p>Funciones como objetos de primera clase:</p>
<blockquote>
<p>En programación funcional, las funciones son objetos de primera
clase del lenguaje, similares a enteros o <em>strings</em>. Podemos pasar
funciones como argumentos en las denominadas <em>funciones de orden
superior</em> o devolver funciones creadas en tiempo de ejecución
(clausuras).</p>
</blockquote>
<h2 id="funciones">Funciones<a class="headerlink" href="#funciones" title="Permanent link">&para;</a></h2>
<h3 id="definicion-de-una-funcion-en-swift">Definición de una función en Swift<a class="headerlink" href="#definicion-de-una-funcion-en-swift" title="Permanent link">&para;</a></h3>
<p>Para definir una función en Swift se debe usar la palabra <code>func</code>,
definir el nombre de la función, sus parámetros y el tipo de
vuelto. El valor devuelto por la función se debe devolver usando la
palabra <code>return</code>.</p>
<p>Código de la función <code>saluda(nombre:)</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">saluda</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">saludo</span> <span class="p">=</span> <span class="s">&quot;Hola, &quot;</span> <span class="o">+</span> <span class="n">nombre</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span>
    <span class="k">return</span> <span class="n">saludo</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Para invocar a la función <code>saluda(nombre:)</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="bp">print</span><span class="p">(</span><span class="n">saluda</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span><span class="s">&quot;Ana&quot;</span><span class="p">))</span>
<span class="bp">print</span><span class="p">(</span><span class="n">saluda</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span><span class="s">&quot;Pedro&quot;</span><span class="p">))</span>
<span class="c1">// Imprime &quot;Hola, Ana!&quot;</span>
<span class="c1">// Imprime &quot;Hola, Pedro!&quot;</span>
</pre></div>
</td></tr></table>

<h3 id="etiquetas-de-argumentos-y-nombres-de-parametros">Etiquetas de argumentos y nombres de parámetros<a class="headerlink" href="#etiquetas-de-argumentos-y-nombres-de-parametros" title="Permanent link">&para;</a></h3>
<p>Cada parámetro de una función tiene una etiqueta del argumento y un
nombre de parámetro. La etiqueta del argumento se usa cuando se llama a
la función y el nombre del parámetro se usa internamente en su
implementación. Por defecto, los parámetros usan su nombre de
parámetro como etiqueta del argumento:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">unaFuncion</span><span class="p">(</span><span class="n">primerNombreParametro</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">segundoNombreParametro</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// En el cuerpo de la función, primerNombreParametro y</span>
    <span class="c1">// segundoNombreParametro se refieren a los valores de los</span>
    <span class="c1">// argumentos del primer y el segundo parámetro</span>
<span class="p">}</span>
<span class="n">unaFuncion</span><span class="p">(</span><span class="n">primerNombreParametro</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="n">segundoNombreParametro</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Es posible hacer distintos la etiqueta del argumento del nombre del
parámetro:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">saluda</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">de</span> <span class="n">ciudad</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Hola </span><span class="si">\(</span><span class="n">nombre</span><span class="si">)</span><span class="s">! Me alegro de que hayas podido visitarnos desde </span><span class="si">\(</span><span class="n">ciudad</span><span class="si">)</span><span class="s">.&quot;</span>
<span class="p">}</span>
<span class="bp">print</span><span class="p">(</span><span class="n">saluda</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="s">&quot;Bill&quot;</span><span class="p">,</span> <span class="n">de</span><span class="p">:</span> <span class="s">&quot;Cupertino&quot;</span><span class="p">))</span>
<span class="c1">// Imprime &quot;Hola Bill! Me alegro de que hayas podido visitarnos desde Cupertino.&quot;</span>
</pre></div>
</td></tr></table>

<p>Otro ejemplo, la siguiente función <code>concatena(palabra:con:)</code>: </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">concatena</span><span class="p">(</span><span class="n">palabra</span> <span class="n">str1</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">con</span> <span class="n">str2</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">str1</span><span class="o">+</span><span class="n">str2</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">concatena</span><span class="p">(</span><span class="n">palabra</span><span class="p">:</span><span class="s">&quot;Hola&quot;</span><span class="p">,</span> <span class="n">con</span><span class="p">:</span><span class="s">&quot;adios&quot;</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Si no se quiere una etiqueta del argumento para un parámetro, se puede
escribir un subrayado (<code>_</code>) en lugar de una etiqueta del argumento
explícita para ese parámetro:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">max</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span><span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">y</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">x</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">y</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="bp">max</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>

<span class="kd">func</span> <span class="nf">divide</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span><span class="nb">Double</span><span class="p">,</span> <span class="n">entre</span> <span class="n">y</span><span class="p">:</span> <span class="nb">Double</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Double</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">divide</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="n">entre</span><span class="p">:</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>El perfil de la función está formado por el nombre de la función, las
etiquetas de los argumentos y el tipo devuelto por la función. En la
documentación de las funciones usaremos las etiquetas separadas por
dos puntos. Por ejemplo, las funciones anteriores son <code>max(_:_:)</code> y
<code>divide(_:entre:)</code>.</p>
<h3 id="parametros-y-valores-devueltos">Parámetros y valores devueltos<a class="headerlink" href="#parametros-y-valores-devueltos" title="Permanent link">&para;</a></h3>
<p>Es posible definir funciones sin parámetros:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">diHolaMundo</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;hola, mundo&quot;</span>
<span class="p">}</span>
<span class="bp">print</span><span class="p">(</span><span class="n">diHolaMundo</span><span class="p">())</span>
<span class="c1">// Imprime &quot;hola, mundo&quot;</span>
</pre></div>
</td></tr></table>

<p>Podemos definir funciones sin valor devuelto. Por ejemplo, la
siguiente función <code>diAdios(nombre:)</code>. No hay que escribir flecha con el
tipo devuelto. Cuidado, no sería propiamente programación funcional.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">diAdios</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Adiós, </span><span class="si">\(</span><span class="n">nombre</span><span class="si">)</span><span class="s">!&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">diAdios</span><span class="p">(</span><span class="n">nombre</span><span class="p">:</span><span class="s">&quot;Dave&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;Adiós, Dave!&quot;</span>
</pre></div>
</td></tr></table>

<p>Es posible devolver múltiples valores, construyendo una tupla. Por
ejemplo, la siguiente función <code>minMax(array:)</code> busca el número más pequeño
y más grande de un array de enteros.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">minMax</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="bp">min</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="bp">max</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">minActual</span> <span class="p">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="kd">var</span> <span class="nv">maxActual</span> <span class="p">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">valor</span> <span class="k">in</span> <span class="n">array</span><span class="p">[</span><span class="mf">1.</span><span class="p">.&lt;</span><span class="n">array</span><span class="p">.</span><span class="bp">count</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">valor</span> <span class="o">&lt;</span> <span class="n">minActual</span> <span class="p">{</span>
            <span class="n">minActual</span> <span class="p">=</span> <span class="n">valor</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">valor</span> <span class="o">&gt;</span> <span class="n">maxActual</span> <span class="p">{</span>
            <span class="n">maxActual</span> <span class="p">=</span> <span class="n">valor</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">minActual</span><span class="p">,</span> <span class="n">maxActual</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Los valores de la tupla devuelta se etiquetan y se puede acceder por
esos nombres cuando se consulta el valor devuelto por la función:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">limites</span> <span class="p">=</span> <span class="n">minMax</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">109</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">71</span><span class="p">])</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;min es </span><span class="si">\(</span><span class="n">limites</span><span class="p">.</span><span class="bp">min</span><span class="si">)</span><span class="s"> y max es </span><span class="si">\(</span><span class="n">limites</span><span class="p">.</span><span class="bp">max</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;min es -6 y max es 109&quot;</span>
</pre></div>
</td></tr></table>

<h2 id="tipos-funcion">Tipos función<a class="headerlink" href="#tipos-funcion" title="Permanent link">&para;</a></h2>
<p>En Swift las funciones son objetos de primera clase y podemos
asignarlas a variables, pasarlas como parámetro o devolverlas como
resultado de otra función. Al ser un lenguaje fuertemente tipado, las
variables, parámetros o resultados deben ser objetos de tipo función.</p>
<p>Cada función tiene un tipo específico, definido por el tipo de sus
parámetros y el tipo del valor devuelto.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">sumaDosInts</span><span class="p">(</span><span class="kc">_</span> <span class="n">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">multiplicaDosInts</span><span class="p">(</span><span class="kc">_</span> <span class="n">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>El tipo de estas funciones es <code>(Int, Int) -&gt; Int</code>, que se puede leer como:</p>
<p>"Un tipo función que tiene dos parámetros, ambos de tipo <code>Int</code> y que
devuelve un valor de tipo <code>Int</code>".</p>
<p>En Swift se puede usar un tipo función de la misma forma que cualquier
otro tipo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">funcionMatematica</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">=</span> <span class="n">sumaDosInts</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Resultado: </span><span class="si">\(</span><span class="n">funcionMatematica</span><span class="si">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="si">))</span><span class="s">&quot;</span><span class="p">)</span>
<span class="n">funcionMatematica</span> <span class="p">=</span> <span class="n">multiplicaDosInts</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;Resultado: </span><span class="si">\(</span><span class="n">funcionMatematica</span><span class="si">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="si">))</span><span class="s">&quot;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<h3 id="funciones-que-reciben-otras-funciones">Funciones que reciben otras funciones<a class="headerlink" href="#funciones-que-reciben-otras-funciones" title="Permanent link">&para;</a></h3>
<p>Podemos usar un tipo función en parámetros de otras funciones:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">printResultado</span><span class="p">(</span><span class="n">funcion</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Resultado: </span><span class="si">\(</span><span class="n">funcionMatematica</span><span class="si">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="si">))</span><span class="s">&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="n">printResultado</span><span class="p">(</span><span class="n">funcion</span><span class="p">:</span> <span class="n">sumaDosInts</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// Prints &quot;Resultado: 8&quot;</span>
</pre></div>
</td></tr></table>

<p>La función <code>printResultado(funcion:_:_:)</code> toma como primer parámetro otra
función que recibe dos <code>Int</code> y devuelve un <code>Int</code>, y como segundo y
tercer parámetro dos <code>Int</code>.</p>
<p>Veamos otro ejemplo, que ya vimos en Scheme. Supongamos que queremos
calcular el sumatorio desde <code>a</code> hasta <code>b</code> en el que aplicamos una
función <code>f</code> a cada número que sumamos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>sumatorio(a, b, f) = f(a) + f(a+1) + f(a+2) + ... + f(b)
</pre></div>
</td></tr></table>

<p>Recordamos que se resuelve con la siguiente recursión:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>sumatorio(a, b, f) = f(a) + sumatorio(a+1, b, f)
sumatorio(a, b, f) = 0 si a &gt; b
</pre></div>
</td></tr></table>

<p>Veamos cómo se implementa en Swift: </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">sumatorio</span><span class="p">(</span><span class="n">desde</span> <span class="n">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">hasta</span> <span class="n">b</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="kd">func</span> <span class="nf">f</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">{</span> 
      <span class="k">return</span> <span class="mi">0</span> 
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">sumatorio</span><span class="p">(</span><span class="n">desde</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">hasta</span><span class="p">:</span> <span class="n">b</span><span class="p">,</span> <span class="kd">func</span><span class="p">:</span> <span class="n">f</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">identidad</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">x</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">doble</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">cuadrado</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">sumatorio</span><span class="p">(</span><span class="n">desde</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hasta</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="kd">func</span><span class="p">:</span> <span class="n">identidad</span><span class="p">))</span> <span class="c1">// Imprime 55</span>
<span class="bp">print</span><span class="p">(</span><span class="n">sumatorio</span><span class="p">(</span><span class="n">desde</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hasta</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="kd">func</span><span class="p">:</span> <span class="n">doble</span><span class="p">))</span> <span class="c1">// Imprime 110</span>
<span class="bp">print</span><span class="p">(</span><span class="n">sumatorio</span><span class="p">(</span><span class="n">desde</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hasta</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="kd">func</span><span class="p">:</span> <span class="n">cuadrado</span><span class="p">))</span> <span class="c1">// Imprime 385</span>
</pre></div>
</td></tr></table>

<h3 id="funciones-en-estructuras">Funciones en estructuras<a class="headerlink" href="#funciones-en-estructuras" title="Permanent link">&para;</a></h3>
<p>Como cualquier otro tipo Las funciones pueden también incluirse en
  estructuras de datos compuestas, como arrays:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">funciones</span> <span class="p">=</span> <span class="p">[</span><span class="n">identidad</span><span class="p">,</span> <span class="n">doble</span><span class="p">,</span> <span class="n">cuadrado</span><span class="p">]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">funciones</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="mi">10</span><span class="p">))</span> <span class="c1">// 10</span>
<span class="bp">print</span><span class="p">(</span><span class="n">funciones</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="mi">10</span><span class="p">))</span> <span class="c1">// 20 </span>
<span class="bp">print</span><span class="p">(</span><span class="n">funciones</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span><span class="mi">10</span><span class="p">))</span> <span class="c1">// 100</span>
</pre></div>
</td></tr></table>

<p>El tipo de la variable <code>funciones</code> sería <code>[(Int) -&gt; Int]</code>. </p>
<p>Al ser Swift fuertemente tipeado, no podríamos hacer un array con
distintos tipos de funciones. Por ejemplo el siguiente código daría un
error:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">suma</span><span class="p">(</span><span class="kc">_</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="kc">_</span> <span class="n">y</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="p">}</span>
<span class="c1">// La siguiente línea genera un error</span>
<span class="kd">var</span> <span class="nv">misFunciones</span> <span class="p">=</span> <span class="p">[</span><span class="n">doble</span><span class="p">,</span> <span class="n">cuadrado</span><span class="p">,</span> <span class="n">suma</span><span class="p">]</span>
<span class="c1">// error: heterogenous collection literal could only be inferred to</span>
<span class="c1">// &#39;[Any]&#39;; add explicit type annotation if this is intentional</span>
</pre></div>
</td></tr></table>

<h3 id="funciones-que-devuelven-otras-funciones">Funciones que devuelven otras funciones<a class="headerlink" href="#funciones-que-devuelven-otras-funciones" title="Permanent link">&para;</a></h3>
<p>Por último, veamos un ejemplo de funciones que devuelven otras
funciones.</p>
<p>Empecemos por un ejemplo sencillo de una función que devuelve otra que
suma 10:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">makeSumador10</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">suma10</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span><span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="mi">10</span><span class="p">}</span>
  <span class="k">return</span> <span class="n">suma10</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">f</span> <span class="p">=</span> <span class="n">makeSumador10</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">20</span><span class="p">))</span>
<span class="c1">// Imprime 30</span>
</pre></div>
</td></tr></table>

<p>Hay que hacer notar la declaración de la función <code>makeSumador10</code>. Es
una función que no recibe argumentos y que devuelve otra función del
tipo <code>(Int) -&gt; Int</code>, esto es, una función que recibe un entero y
devuelve otro entero.</p>
<p>Otro ejemplo, un poco más complicado:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">eligeFuncionPaso</span><span class="p">(</span><span class="n">menorQueCero</span><span class="p">:</span> <span class="nb">Bool</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">pasoAdelante</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
    <span class="kd">func</span> <span class="nf">pasoAtras</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">}</span>
    <span class="k">return</span> <span class="n">menorQueCero</span> <span class="p">?</span> <span class="n">pasoAdelante</span> <span class="p">:</span> <span class="n">pasoAtras</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nv">valorActual</span> <span class="p">=</span> <span class="o">-</span><span class="mi">4</span>
<span class="kd">let</span> <span class="nv">acercarseACero</span> <span class="p">=</span> <span class="n">eligeFuncionPaso</span><span class="p">(</span><span class="n">menorQueCero</span><span class="p">:</span> <span class="n">valorActual</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">// acercarseACero ahora se refiere a la función anidada pasoAdelante</span>
<span class="k">while</span> <span class="n">valorActual</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">\(</span><span class="n">valorActual</span><span class="si">)</span><span class="s">... &quot;</span><span class="p">)</span>
    <span class="n">valorActual</span> <span class="p">=</span> <span class="n">acercarseACero</span><span class="p">(</span><span class="n">valorActual</span><span class="p">)</span>
<span class="p">}</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;cero!&quot;</span><span class="p">)</span>
<span class="c1">// -4...</span>
<span class="c1">// -3...</span>
<span class="c1">// -2...</span>
<span class="c1">// -1...</span>
<span class="c1">// cero!</span>
</pre></div>
</td></tr></table>

<h2 id="recursion">Recursión<a class="headerlink" href="#recursion" title="Permanent link">&para;</a></h2>
<p>Ejemplos de funciones recursivas en Swift.</p>
<p>Recursión pura:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">suma</span><span class="p">(</span><span class="n">hasta</span> <span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="n">x</span> <span class="p">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">suma</span><span class="p">(</span><span class="n">hasta</span><span class="p">:</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">suma</span><span class="p">(</span><span class="n">hasta</span><span class="p">:</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Los arrays en Swift no funcionan exactamente como las listas de Scheme
(no son listas de parejas), pero podríamos obtener el primer elemento
y el resto de la siguiente forma.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">a</span> <span class="p">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">60</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">primero</span> <span class="p">=</span> <span class="n">a</span><span class="p">.</span><span class="bp">first</span><span class="p">!</span>
<span class="kd">let</span> <span class="nv">resto</span> <span class="p">=</span> <span class="n">a</span><span class="p">.</span><span class="bp">dropFirst</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<p>En <code>primero</code> se guarda el número 10. El símbolo <code>!</code> sirve para
<em>desenvolver el opcional</em> que devuelve <code>first</code> (veremos después este
concepto).</p>
<p>En <code>resto</code> se guarda un <code>ArraySlice</code> del 20 al 60. Es una vista de un
rango de elementos del array, en este caso el que va desde la posición
1 hasta la 5 (la posición inicial de un array es la 0).</p>
<p>Un <code>ArraySlice</code> en un un <code>Array</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">resto</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="bp">dropFirst</span><span class="p">())</span>
</pre></div>
</td></tr></table>

<p>De esta forma podemos definir la función recursiva que suma los
valores de un Array de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">sumaValores</span><span class="p">(</span><span class="kc">_</span> <span class="n">valores</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="kd">let</span> <span class="nv">primero</span> <span class="p">=</span> <span class="n">valores</span><span class="p">.</span><span class="bp">first</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nv">resto</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">valores</span><span class="p">.</span><span class="bp">dropFirst</span><span class="p">())</span>
      <span class="k">return</span> <span class="n">primero</span> <span class="o">+</span> <span class="n">sumaValores</span><span class="p">(</span><span class="n">resto</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">sumaValores</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]))</span> <span class="c1">// 36</span>
</pre></div>
</td></tr></table>

<p>Veremos que las colecciones en Swift implementan funciones de orden
superior como <code>map</code>, <code>filter</code>, etc.</p>
<p>Veremos también más adelante otras funciones recursivas cuando
definamos árboles en Swift.</p>
<h2 id="tipos">Tipos<a class="headerlink" href="#tipos" title="Permanent link">&para;</a></h2>
<p>Swift es un lenguaje fuertemente tipeado, a diferencia de
Scheme. Muchos otros lenguajes de programación funcional, como Haskell
o Clojure también lo son.</p>
<p>Entre las ventajas del uso de tipos está la detección de errores en
los programas en tiempo de compilación o las ayudas del entorno de
desarrollo para autocompletar código. Entre los inconvenientes se
encuentra la necesidad de ser más estrictos a la hora de definir los
parámetros y los valores devueltos por las funciones, lo que impide la
flexibilidad de Scheme.</p>
<p>Se utilizan tipos para definir los posibles valores de:</p>
<ul>
<li>variables</li>
<li>parámetros de funciones</li>
<li>valores devueltos por funciones</li>
</ul>
<p>Las definiciones de tipos van precedidas de dos puntos en las
variables y parámetros, o de una flecha (<code>-&gt;</code>) en la definición de los
tipos de los valores devueltos por una función:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">valorDouble</span> <span class="p">:</span> <span class="nb">Double</span> <span class="p">=</span> <span class="mf">3.0</span>
<span class="kd">let</span> <span class="nv">unaCadena</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="s">&quot;Hola&quot;</span>

<span class="kd">func</span> <span class="nf">calculaEstadisticas</span><span class="p">(</span><span class="n">valores</span><span class="p">:</span> <span class="nb">Array</span><span class="p">&lt;</span><span class="nb">Int</span><span class="p">&gt;)</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="bp">min</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="bp">max</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">media</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
   <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>En Swift existen dos clases de tipos: tipos con nombre y tipos compuestos. </p>
<h3 id="tipos-con-nombre">Tipos con nombre<a class="headerlink" href="#tipos-con-nombre" title="Permanent link">&para;</a></h3>
<p>Un tipo con nombre es un tipo al que se le puede dar un nombre
determinado cuando se define.</p>
<p>Definimos un tipo al definir:</p>
<ul>
<li>nombres de clases</li>
<li>nombres de estructuras</li>
<li>nombres de enumeraciones</li>
<li>nombres de protocolos </li>
</ul>
<p>Por ejemplo, instancias de una clase definida por el usuario llamada
<code>MiClase</code> tienen el tipo <code>MiClase</code>. Además de los tipos definidos por
el usuario, la biblioteca estándar de Swift tiene un gran número de
tipos predefinidos. A diferencia de otros lenguajes, estos tipos no
son parte del propio lenguaje sino que se definen en su mayoría como
estructuras implementadas en esta biblioteca estándar. Por ejemplo,
arrays, diccionarios o incluso los tipos más básicos como <code>String</code> o
<code>Int</code> están construidos en esa biblioteca.</p>
<h3 id="tipos-compuestos">Tipos compuestos<a class="headerlink" href="#tipos-compuestos" title="Permanent link">&para;</a></h3>
<p>Los tipos compuestos son tipos sin nombre. En Swift se definen dos:
tuplas y tipos función. Un tipo compuesto puede tener tipos con nombre
y otros tipos compuestos. Por ejemplo la tupla <code>(Int, (Int, Int))</code>
contiene dos elementos: el primero es el tipo con nombre <code>Int</code> y el
segundo el tipo compuesto que define la tupla <code>(Int, Int)</code>. Los tipos
función los hemos visto previamente.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">tupla</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Hola&quot;</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">otraTupla</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="s">&quot;Adios&quot;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">sumaTupla</span><span class="p">(</span><span class="n">tupla</span> <span class="n">t1</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">),</span> <span class="n">con</span> <span class="n">t2</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">))</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">t1</span><span class="p">.</span><span class="mi">0</span> <span class="o">+</span> <span class="n">t2</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">t1</span><span class="p">.</span><span class="mi">1</span> <span class="o">+</span> <span class="n">t2</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">sumaTupla</span><span class="p">(</span><span class="n">tupla</span><span class="p">:</span> <span class="p">(</span><span class="n">tupla</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">tupla</span><span class="p">.</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">con</span><span class="p">:</span> <span class="p">(</span><span class="n">otraTupla</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="n">otraTupla</span><span class="p">.</span><span class="mi">1</span><span class="p">)))</span>

<span class="c1">// Imprime (7, 11)</span>
</pre></div>
</td></tr></table>

<h3 id="enumeraciones">Enumeraciones<a class="headerlink" href="#enumeraciones" title="Permanent link">&para;</a></h3>
<p>Las enumeraciones definen un tipo con un valor restringido de posibles
valores:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="nc">Direccion</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">norte</span>
    <span class="k">case</span> <span class="n">sur</span>
    <span class="k">case</span> <span class="n">este</span>
    <span class="k">case</span> <span class="n">oeste</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Cualquier variable del tipo <code>Direccion</code> solo puede tener uno de los
cuatro valores definidos. Se obtiene el valor escribiendo el nombre de
la enumeración, un punto y el valor definido. Si el tipo de
enumeración se puede inferir no es necesario escribirlo.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">hemosGirado</span> <span class="p">=</span> <span class="kc">true</span>
<span class="kd">var</span> <span class="nv">direccionActual</span> <span class="p">=</span> <span class="n">Direccion</span><span class="p">.</span><span class="n">norte</span>
<span class="k">if</span> <span class="n">hemosGirado</span> <span class="p">{</span>
   <span class="n">direccionActual</span> <span class="p">=</span> <span class="p">.</span><span class="n">sur</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>En sentencias switch:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">direccionAIr</span> <span class="p">=</span> <span class="n">Direccion</span><span class="p">.</span><span class="n">sur</span>
<span class="k">switch</span> <span class="n">direccionAIr</span> <span class="p">{</span>
<span class="k">case</span> <span class="p">.</span><span class="n">norte</span><span class="p">:</span>
   <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Nos vamos al norte&quot;</span><span class="p">)</span>
<span class="k">case</span> <span class="p">.</span><span class="n">sur</span><span class="p">:</span>
   <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Cuidado con los pinguinos&quot;</span><span class="p">)</span>
<span class="k">case</span> <span class="p">.</span><span class="n">este</span><span class="p">:</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Donde nace el sol&quot;</span><span class="p">)</span>
<span class="k">case</span> <span class="p">.</span><span class="n">oeste</span><span class="p">:</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Donde el cielo es azul&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Imprime &quot;Cuidado con los pinguinos&quot;</span>
</pre></div>
</td></tr></table>

<p>Otro ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="nc">Planeta</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">mercurio</span><span class="p">,</span> <span class="n">venus</span><span class="p">,</span> <span class="n">tierra</span><span class="p">,</span> <span class="n">marte</span><span class="p">,</span> <span class="n">jupiter</span><span class="p">,</span> <span class="n">saturno</span><span class="p">,</span> <span class="n">urano</span><span class="p">,</span> <span class="n">neptuno</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="valores-brutos-de-enumeraciones">Valores brutos de enumeraciones<a class="headerlink" href="#valores-brutos-de-enumeraciones" title="Permanent link">&para;</a></h3>
<p>Es posible asignar a las constantes del enumerado un valor concreto de
un tipo subyacente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="nc">CaracterControlASCII</span><span class="p">:</span> <span class="nb">Character</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">tab</span> <span class="p">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span>
    <span class="k">case</span> <span class="n">lineFeed</span> <span class="p">=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
    <span class="k">case</span> <span class="n">carriageReturn</span> <span class="p">=</span> <span class="s">&quot;</span><span class="se">\r</span><span class="s">&quot;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Se puede devolver el valor bruto de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>let nuevaLinea = CaracterControlASCII.LineFeed.rawValue
</pre></div>
</td></tr></table>

<p>También se puede hacer de forma implícita cuando el tipo subyacente es
<code>Int</code>, dando un valor a la primera constante:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="nc">Planeta</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">mercurio</span><span class="p">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">venus</span><span class="p">,</span> <span class="n">tierra</span><span class="p">,</span> <span class="n">marte</span><span class="p">,</span> <span class="n">jupiter</span><span class="p">,</span> <span class="n">saturno</span><span class="p">,</span> <span class="n">urano</span><span class="p">,</span> <span class="n">neptuno</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">posicionTierra</span> <span class="p">=</span> <span class="n">Planeta</span><span class="p">.</span><span class="n">tierra</span><span class="p">.</span><span class="n">rawValue</span>
<span class="c1">// posicionTierra es 3</span>
</pre></div>
</td></tr></table>

<p>Por último, se puede definir como tipo subyacente <code>String</code> y los
valores brutos de las constantes serán sus nombres convertidos a
cadenas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="nc">Direccion</span><span class="p">:</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">norte</span><span class="p">,</span> <span class="n">sur</span><span class="p">,</span> <span class="n">este</span><span class="p">,</span> <span class="n">oeste</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">direccionAtardecer</span> <span class="p">=</span> <span class="n">Direccion</span><span class="p">.</span><span class="n">oeste</span><span class="p">.</span><span class="n">rawValue</span>
<span class="c1">// direccionAtardecer es &quot;oeste&quot;</span>
</pre></div>
</td></tr></table>

<p>Cuando se definen valores brutos es posible inicializar el enumerado
de una forma similar a una estructura o una clase pasando el valor
bruto. Devuelve el valor enumerado correspondiente o <code>nil</code> (un
opcional):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">posiblePlaneta</span> <span class="p">=</span> <span class="n">Planeta</span><span class="p">(</span><span class="n">rawValue</span><span class="p">:</span> <span class="mi">7</span><span class="p">)</span>
<span class="c1">// posiblePlaneta es de tipo Planeta? y es igual a Planeta.urano</span>
</pre></div>
</td></tr></table>

<h3 id="valores-asociados-a-instancias-de-enumeraciones">Valores asociados a instancias de enumeraciones<a class="headerlink" href="#valores-asociados-a-instancias-de-enumeraciones" title="Permanent link">&para;</a></h3>
<p>En otros lenguajes de programación se llaman <em>uniones etiquetadas</em> o
<em>variantes</em>. Permiten asociar valores de otro tipo a las opciones del
enumerado.</p>
<p>Una instancia de un caso de enumeración puede tener valores asociados
con la instancia. Instancias del mismo caso de enumeración pueden
tener asociados valores diferentes. Se proporciona el valor asociado
cuando se crea la instancia. Los valores asociados y los valores
brutos son distintos: el valor bruto de un caso de enumeración es el
mismo para todas las instancias, mientras que el valor asociado se
proporciona cuando se define el valor concreto de la enumeración.</p>
<p>Veamos un ejemplo, en el que usamos un enum para definir posibles
valores de un código de barras, en el que incluimos dos posibles tipos
de código de barras: el código de barras lineal (denominado UPC) y el
código QR:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">enum</span> <span class="nc">CodigoBarras</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">upc</span><span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">qrCode</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Se lee de la siguiente forma: “Definimos un tipo enumerado llamado
<code>CodigoBarras</code>, que puede tomar como valor un <code>upc</code> (código de barras
lineal) con un valor asociado de tipo <code>(Int, Int, Int, Int)</code> (los 4
números que hay en los códigos de barras lineales) o un valor <code>qrCode</code>
con valor asociado de tipo <code>String</code>". Esta definición no proporciona
valores concretos de <code>Int</code> o <code>String</code>, sino que define el <em>tipo</em> de
valores asociados que las constantes y variables pueden almacenar
cuando son de tipo <code>CodigoBarras.upc</code> o <code>CodigoBarras.qrCode</code>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">codigoBarrasProducto</span> <span class="p">=</span> <span class="n">CodigoBarras</span><span class="p">.</span><span class="n">upc</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">85909</span><span class="p">,</span> <span class="mi">51226</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">codigoBarrasProducto</span> <span class="p">=</span> <span class="p">.</span><span class="n">qrCode</span><span class="p">(</span><span class="s">&quot;ABCDEFGHIJKLMNOP&quot;</span><span class="p">)</span>

<span class="k">switch</span> <span class="n">codigoBarrasProducto</span> <span class="p">{</span>
<span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">upc</span><span class="p">(</span><span class="n">sistemaNumeracion</span><span class="p">,</span> <span class="n">fabricante</span><span class="p">,</span> <span class="n">producto</span><span class="p">,</span> <span class="n">control</span><span class="p">):</span>
   <span class="bp">print</span><span class="p">(</span><span class="s">&quot;UPC: </span><span class="si">\(</span><span class="n">sistemaNumeracion</span><span class="si">)</span><span class="s">, </span><span class="si">\(</span><span class="n">fabricante</span><span class="si">)</span><span class="s">, </span><span class="si">\(</span><span class="n">producto</span><span class="si">)</span><span class="s">, </span><span class="si">\(</span><span class="n">control</span><span class="si">)</span><span class="s">.&quot;</span><span class="p">)</span>
<span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">qrCode</span><span class="p">(</span><span class="n">codigoProducto</span><span class="p">):</span>
   <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Código QR: </span><span class="si">\(</span><span class="n">codigoProducto</span><span class="si">)</span><span class="s">.&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Imprime  &quot;Código QR : ABCDEFGHIJKLMNOP.&quot;</span>
</pre></div>
</td></tr></table>

<h3 id="enumeraciones-recursivas">Enumeraciones recursivas<a class="headerlink" href="#enumeraciones-recursivas" title="Permanent link">&para;</a></h3>
<p>Es posible combinar las características de las enumeraciones con valor
con la recursión para crear enumeraciones recursivas. Hay que preceder
la palabra clave <code>enum</code> con <code>indirect</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kr">indirect</span> <span class="kd">enum</span> <span class="nc">ExpresionAritmetica</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">numero</span><span class="p">(</span><span class="nb">Int</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">suma</span><span class="p">(</span><span class="n">ExpresionAritmetica</span><span class="p">,</span> <span class="n">ExpresionAritmetica</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">multiplicacion</span><span class="p">(</span><span class="n">ExpresionAritmetica</span><span class="p">,</span> <span class="n">ExpresionAritmetica</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">cinco</span> <span class="p">=</span> <span class="n">ExpresionAritmetica</span><span class="p">.</span><span class="n">numero</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">cuatro</span> <span class="p">=</span> <span class="n">ExpresionAritmetica</span><span class="p">.</span><span class="n">numero</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">suma</span> <span class="p">=</span> <span class="n">ExpresionAritmetica</span><span class="p">.</span><span class="n">suma</span><span class="p">(</span><span class="n">cinco</span><span class="p">,</span> <span class="n">cuatro</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">producto</span> <span class="p">=</span> <span class="n">ExpresionAritmetica</span><span class="p">.</span><span class="n">multiplicacion</span><span class="p">(</span><span class="n">suma</span><span class="p">,</span> <span class="n">ExpresionAritmetica</span><span class="p">.</span><span class="n">numero</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Es muy cómodo manejar enumeraciones recursivas de forma recursiva:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">evalua</span><span class="p">(</span><span class="n">expresion</span><span class="p">:</span> <span class="n">ExpresionAritmetica</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">expresion</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">numero</span><span class="p">(</span><span class="n">valor</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">valor</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">suma</span><span class="p">(</span><span class="n">izquierda</span><span class="p">,</span> <span class="n">derecha</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">evalua</span><span class="p">(</span><span class="n">expresion</span><span class="p">:</span> <span class="n">izquierda</span><span class="p">)</span> <span class="o">+</span> <span class="n">evalua</span><span class="p">(</span><span class="n">expresion</span><span class="p">:</span> <span class="n">derecha</span><span class="p">)</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">multiplicacion</span><span class="p">(</span><span class="n">izquierda</span><span class="p">,</span> <span class="n">derecha</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">evalua</span><span class="p">(</span><span class="n">expresion</span><span class="p">:</span> <span class="n">izquierda</span><span class="p">)</span> <span class="o">*</span> <span class="n">evalua</span><span class="p">(</span><span class="n">expresion</span><span class="p">:</span> <span class="n">derecha</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">evalua</span><span class="p">(</span><span class="n">expresion</span><span class="p">:</span> <span class="n">producto</span><span class="p">))</span>
<span class="c1">// Imprime 18</span>
</pre></div>
</td></tr></table>

<p>Otro ejemplo de enums recursivos, para definir un tipo de datos
<code>Lista</code> basado en parejas (similar a Scheme):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kr">indirect</span> <span class="kd">enum</span> <span class="nc">Lista</span><span class="p">{</span>
 <span class="k">case</span> <span class="n">vacia</span>
 <span class="k">case</span> <span class="n">cons</span><span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="n">Lista</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">suma</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">Lista</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
   <span class="k">switch</span> <span class="n">lista</span> <span class="p">{</span>
   <span class="k">case</span>  <span class="p">.</span><span class="n">vacia</span><span class="p">:</span>
     <span class="k">return</span> <span class="mi">0</span>
   <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">cons</span><span class="p">(</span><span class="n">car</span><span class="p">,</span> <span class="n">cdr</span><span class="p">):</span>
     <span class="k">return</span> <span class="n">car</span> <span class="o">+</span> <span class="n">suma</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">cdr</span><span class="p">)</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">z</span><span class="p">:</span> <span class="n">Lista</span> <span class="p">=</span> <span class="p">.</span><span class="n">cons</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="p">.</span><span class="n">cons</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="p">.</span><span class="n">vacia</span><span class="p">))</span>

<span class="bp">print</span><span class="p">(</span><span class="n">suma</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">z</span><span class="p">))</span>
<span class="c1">// Imprime 30</span>
</pre></div>
</td></tr></table>

<p>Podemos definir también una función recursiva <code>makeLista(array:[Int])</code>
que devuelve una lista a partir de una array de enteros:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">make</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="n">Lista</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">primero</span> <span class="p">=</span> <span class="n">lista</span><span class="p">.</span><span class="bp">first</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">resto</span> <span class="p">=</span> <span class="nb">Array</span><span class="p">(</span><span class="n">lista</span><span class="p">.</span><span class="bp">dropFirst</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">Lista</span><span class="p">.</span><span class="n">cons</span><span class="p">(</span><span class="n">primero</span><span class="p">,</span> <span class="n">make</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">resto</span><span class="p">))</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">Lista</span><span class="p">.</span><span class="n">vacia</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">lista</span> <span class="p">=</span> <span class="n">make</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>

<span class="bp">print</span><span class="p">(</span><span class="n">suma</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">lista</span><span class="p">))</span>
<span class="c1">// Imprime 15</span>
</pre></div>
</td></tr></table>

<h3 id="typealias">Typealias<a class="headerlink" href="#typealias" title="Permanent link">&para;</a></h3>
<p>En Swift se define la palabra clave <code>typealias</code> para darle un nombre
asignado a cualquier otro tipo. Ambos tipos son iguales a todos los
efectos (es únicamente azúcar sintáctico).</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">typealias</span> <span class="n">Resultado</span> <span class="p">=</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span>

<span class="kd">enum</span> <span class="nc">Quiniela</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">uno</span><span class="p">,</span> <span class="n">equis</span><span class="p">,</span> <span class="n">dos</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">quiniela</span><span class="p">(</span><span class="n">resultado</span><span class="p">:</span> <span class="n">Resultado</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Quiniela</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="n">resultado</span> <span class="p">{</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">(</span><span class="n">goles1</span><span class="p">,</span> <span class="n">goles2</span><span class="p">)</span> <span class="k">where</span> <span class="n">goles1</span> <span class="o">&lt;</span> <span class="n">goles2</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">.</span><span class="n">dos</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="p">(</span><span class="n">goles1</span><span class="p">,</span> <span class="n">goles2</span><span class="p">)</span> <span class="k">where</span> <span class="n">goles1</span> <span class="o">&gt;</span> <span class="n">goles2</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">.</span><span class="n">uno</span>
    <span class="k">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">.</span><span class="n">equis</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="bp">print</span><span class="p">(</span><span class="n">quiniela</span><span class="p">(</span><span class="n">resultado</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)))</span>
<span class="c1">// Imprime Dos</span>
<span class="bp">print</span><span class="p">(</span><span class="n">quiniela</span><span class="p">(</span><span class="n">resultado</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
<span class="c1">// Imprime Equis</span>
</pre></div>
</td></tr></table>

<h2 id="opcionales">Opcionales<a class="headerlink" href="#opcionales" title="Permanent link">&para;</a></h2>
<p>En Swift el valor nulo se representa con <code>nil</code> (equivalente a <code>null</code>
en Java). No podemos asignar <code>nil</code> a una variable de un tipo dado:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// La siguiente línea daría un error en tiempo de compilación</span>
<span class="c1">// let cadena: String = nil</span>
</pre></div>
</td></tr></table>

<p>Los tipos opcionales de Swift permiten asignar a variables o bien un
valor propio del tipo o bien <code>nil</code>, de forma que podemos expresar
situaciones en las que:</p>
<ul>
<li>Hay un valor y es igual que <em>x</em></li>
</ul>
<p>o</p>
<ul>
<li>No hay ningún valor</li>
</ul>
<p>Podemos definir como opcional variables, parámetros o valores
devueltos por funciones.</p>
<p>Por ejemplo, el tipo <code>Int</code> de Swift tiene un inicializador que intenta
convertir un valor <code>String</code> a un valor <code>Int</code>. Sin embargo, no toda
cadena puede convertirse a un número. Por ejemplo, la cadena <code>"123"</code>
se debería convertir al número 123, pero la cadena <code>"Hola, mundo"</code> no
tiene un valor numérico al que convertirse.</p>
<p>El siguiente ejemplo muestra la forma correcta de usar el inicializador:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">posibleNumero</span> <span class="p">=</span> <span class="s">&quot;123&quot;</span>
<span class="kd">let</span> <span class="nv">numeroConvertido</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">(</span><span class="n">posibleNumero</span><span class="p">)</span>
<span class="n">posibleNumero</span> <span class="p">=</span> <span class="s">&quot;Hola mundo&quot;</span>
<span class="kd">let</span> <span class="nv">conversionErronea</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">(</span><span class="n">posibleNumero</span><span class="p">)</span>
<span class="c1">// numeroConvertido y conversionErronea son de tipo &quot;Int?&quot;, o &quot;Int opcional&quot;</span>
<span class="c1">// El primero contiene un número y el segundo nil</span>
</pre></div>
</td></tr></table>

<p>Debido a que el inicializador puede fallar, devuelve un <code>Int</code>
<em>opcional</em>, en lugar de un <code>Int</code>. Un <code>Int</code> opcional se escribe como
<code>Int?</code>.</p>
<p>Para definir una variable como sin valor debemos asignarle el valor
especial <code>nil</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">codigoRespuestaServidor</span><span class="p">:</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">=</span> <span class="mi">404</span>
<span class="c1">// codigoRespuestaServidor contine un valor Int de 404</span>
<span class="n">codigoRespuestaServidor</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="c1">// codigoRespuestaServidor ahora no contiene ningún valor</span>
</pre></div>
</td></tr></table>

<p>Una variable opcional sin asignar ningún valor se inicializa
automáticamente a <code>nil</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">respuestaEncuesta</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span>
<span class="c1">// respuestaEncuesta es inicializado automáticamente a nil</span>
</pre></div>
</td></tr></table>

<h3 id="sentencias-if-y-desenvoltura-forzosa">Sentencias <code>if</code> y <em>desenvoltura forzosa</em><a class="headerlink" href="#sentencias-if-y-desenvoltura-forzosa" title="Permanent link">&para;</a></h3>
<p>Se puede usar un <code>if</code> para comprobar si un valor opcional es distinto
de <code>nil</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">if</span> <span class="n">numeroConvertido</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;numeroConvertido contiene algún valor entero.&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Imprime &quot;numeroConvertido contiene algún valor entero.&quot;</span>
</pre></div>
</td></tr></table>

<p>Si estamos seguros de que el opcional contiene un valor,
podemos acceder a él usando un signo de exclamación (<code>!</code>). Quiere
decir "Sé que hay este opcional tiene un valor concreto; por favor
úsalo". Esto se conoce como <em>desenvoltura forzosa</em> (<em>forced
unwrapping</em>) del valor opcional:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">if</span> <span class="n">numeroConvertido</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nv">numero</span> <span class="p">=</span> <span class="n">numeroConvertido</span><span class="p">!</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;numeroConvertido tiene un valor entero de </span><span class="si">\(</span><span class="n">numero</span><span class="si">)</span><span class="s">.&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Imprime &quot;numeroConvertido tiene un valor entero de 123.&quot;</span>
</pre></div>
</td></tr></table>

<p>Si se desenvuelve un opcional que contiene un <code>nil</code> se causa un error
en tiempo de ejecución:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">x</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">(</span><span class="s">&quot;Hola&quot;</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">y</span> <span class="p">=</span> <span class="n">x</span><span class="p">!</span> <span class="o">+</span> <span class="mi">100</span>
<span class="c1">// La sentencia anterior provoca un error en tiempo de ejecución</span>
</pre></div>
</td></tr></table>

<h3 id="ligado-opcional">Ligado opcional<a class="headerlink" href="#ligado-opcional" title="Permanent link">&para;</a></h3>
<p>Es posible comprobar si un opcional tiene valor y asignar su valor a
otra variable al mismo tiempo con una construcción llamada <em>ligado
opcional</em> (<em>optional binding</em>):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">if</span> <span class="kd">let</span> <span class="nv">numeroVerdadero</span> <span class="p">=</span> <span class="nb">Int</span><span class="p">(</span><span class="n">posibleNumero</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="si">\(</span><span class="n">posibleNumero</span><span class="si">)</span><span class="se">\&quot;</span><span class="s"> tiene un valor entero de </span><span class="si">\(</span><span class="n">numeroVerdadero</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="si">\(</span><span class="n">posibleNumero</span><span class="si">)</span><span class="se">\&quot;</span><span class="s"> no ha podido convertirse en un entero&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// Imprime &quot;&quot;123&quot; tiene un valor entero de 123&quot;</span>
</pre></div>
</td></tr></table>

<p>Podemos leer el código anterior de la siguiente forma: "Si el <code>Int</code>
opcional devuelto por <code>Int(posibleNumero)</code> contiene un valor, define
la constante <code>numeroVerdadero</code> con el valor contenido en el opcional".</p>
<p>Si tenemos <strong>varios opcionales</strong> es posible comprobar que todos ellos son
distintos de <code>nil</code> usando varios <code>let</code> en el mismo <code>if</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">x1</span><span class="p">:</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">=</span> <span class="n">pedirNumUsuario</span><span class="p">()</span>
<span class="kd">var</span> <span class="nv">x2</span><span class="p">:</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">=</span> <span class="n">pedirNumUsuario</span><span class="p">()</span>
<span class="kd">var</span> <span class="nv">x3</span><span class="p">:</span> <span class="nb">Int</span><span class="p">?</span> <span class="p">=</span> <span class="n">pedirNumUsuario</span><span class="p">()</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">dato1</span> <span class="p">=</span> <span class="n">x1</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">dato2</span> <span class="p">=</span> <span class="n">x2</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">dato3</span> <span class="p">=</span> <span class="n">x3</span> <span class="p">{</span>
   <span class="kd">let</span> <span class="nv">suma</span> <span class="p">=</span> <span class="n">dato1</span><span class="o">+</span><span class="n">dato2</span><span class="o">+</span><span class="n">dato3</span>
   <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Ningún nil y la suma de todos los datos es: </span><span class="si">\(</span><span class="n">suma</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
   <span class="bp">print</span><span class="p">(</span><span class="s">&quot;Algún dato del usuario es nil&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="ejemplos-de-uso-de-opcionales">Ejemplos de uso de opcionales<a class="headerlink" href="#ejemplos-de-uso-de-opcionales" title="Permanent link">&para;</a></h3>
<p>Como ejemplo de uso de opcionales adaptamos el ejemplo anterior de la
función <code>minMax</code> para que pueda recibir un array vacío, en cuyo caso
devolverá <code>nil</code>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">minMax</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">])</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="bp">min</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="bp">max</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)?</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">array</span><span class="p">.</span><span class="bp">isEmpty</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">nil</span> <span class="p">}</span>
    <span class="kd">var</span> <span class="nv">minActual</span> <span class="p">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="kd">var</span> <span class="nv">maxActual</span> <span class="p">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">valor</span> <span class="k">in</span> <span class="n">array</span><span class="p">[</span><span class="mf">1.</span><span class="p">.&lt;</span><span class="n">array</span><span class="p">.</span><span class="bp">count</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">valor</span> <span class="o">&lt;</span> <span class="n">minActual</span> <span class="p">{</span>
            <span class="n">minActual</span> <span class="p">=</span> <span class="n">valor</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">valor</span> <span class="o">&gt;</span> <span class="n">maxActual</span> <span class="p">{</span>
            <span class="n">maxActual</span> <span class="p">=</span> <span class="n">valor</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">minActual</span><span class="p">,</span> <span class="n">maxActual</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Una vez obtenidos, la variable <code>limites</code> devuelta es también un
opcional, y para obtener los valores deberemos desenvolver el resultado:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">limites</span> <span class="p">=</span> <span class="n">minMax</span><span class="p">(</span><span class="n">array</span><span class="p">:[</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="bp">print</span><span class="p">(</span><span class="s">&quot;min es </span><span class="si">\(</span><span class="n">limites</span><span class="p">!.</span><span class="bp">min</span><span class="si">)</span><span class="s"> y max es </span><span class="si">\(</span><span class="n">limites</span><span class="p">!.</span><span class="bp">max</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="c1">// Imprime &quot;min es -6 y max es 109&quot;</span>
</pre></div>
</td></tr></table>

<p>En el caso anterior sabemos que <code>limites</code> va a devolver un valor
(porque llamamos a <code>minMax</code> con un array con elementos), por lo que
podemos desenvolverlo sin temor de provocar un error. </p>
<p>Sin embargo, en el ejemplo siguiente no es recomendable hacer una
desenvoltura forzosa, porque no sabemos si <code>minMax</code> va a devolver
<code>nil</code> o no:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">valores</span> <span class="p">=</span> <span class="n">pedirNums</span><span class="p">()</span> <span class="c1">// La función pedirNums() pide una lista de </span>
                          <span class="c1">// números por la entrada estándar y</span>
                          <span class="c1">// devuelve un [Int] (que puede estar vacío)</span>
<span class="k">if</span> <span class="kd">let</span> <span class="nv">limites</span> <span class="p">=</span> <span class="n">minMax</span><span class="p">(</span><span class="n">valores</span><span class="p">)</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;min es </span><span class="si">\(</span><span class="n">limites</span><span class="p">.</span><span class="bp">min</span><span class="si">)</span><span class="s"> y max es </span><span class="si">\(</span><span class="n">limites</span><span class="p">.</span><span class="bp">max</span><span class="si">)</span><span class="s">&quot;</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="s">&quot;No hay números&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Otro ejemplo, una segunda versión del enum <code>Lista</code>, en el que
utilizamos un único <code>case</code>, pero dando la posibilidad de que el <code>cdr</code>
de la lista sea <code>nil</code> haciéndolo opcional:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kr">indirect</span> <span class="kd">enum</span> <span class="nc">Lista</span><span class="p">{</span>
    <span class="k">case</span> <span class="n">cons</span><span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="n">Lista</span><span class="p">?)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">suma</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">Lista</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">lista</span> <span class="p">{</span>
        <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">cons</span><span class="p">(</span><span class="n">car</span><span class="p">,</span> <span class="n">cdr</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cdr</span> <span class="p">==</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">car</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">car</span> <span class="o">+</span> <span class="n">suma</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">cdr</span><span class="p">!)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">z</span><span class="p">:</span> <span class="n">Lista</span> <span class="p">=</span> <span class="p">.</span><span class="n">cons</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="p">.</span><span class="n">cons</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))</span>
<span class="bp">print</span><span class="p">(</span><span class="n">suma</span><span class="p">(</span><span class="n">lista</span><span class="p">:</span> <span class="n">z</span><span class="p">))</span>
<span class="c1">/// Devuelve 30</span>
</pre></div>
</td></tr></table>

<h2 id="inmutabilidad">Inmutabilidad<a class="headerlink" href="#inmutabilidad" title="Permanent link">&para;</a></h2>
<p>Una de las características funcionales importantes de Swift es el
énfasis en la inmutabilidad para reforzar la seguridad del
lenguaje. Veamos algunas características relacionadas con esto.</p>
<h3 id="palabra-clave-let">Palabra clave let<a class="headerlink" href="#palabra-clave-let" title="Permanent link">&para;</a></h3>
<p>La palabra clave <code>let</code> permite definir constantes. El valor asignado
puede no conocerse en tiempo de compilación:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">maximoNumeroDeIntentosDeLogin</span> <span class="p">=</span> <span class="mi">10</span>
<span class="kd">let</span> <span class="nv">respuesta</span><span class="p">:</span> <span class="nb">String</span> <span class="p">=</span> <span class="n">respuestaUsuario</span><span class="p">.</span><span class="n">respuesta</span><span class="p">()</span>
</pre></div>
</td></tr></table>

<h3 id="semantica-de-copia-en-estructuras">Semántica de copia en estructuras<a class="headerlink" href="#semantica-de-copia-en-estructuras" title="Permanent link">&para;</a></h3>
<p>Una forma de evitar los efectos laterales es definir una semántica de
copia en la asignación. En Swift la semántica de una asignación
depende del tipo de objeto. Las estructuras (<em>structs</em>) tienen
<strong>semántica de copia</strong>. Veremos más adelante que las clases tienen una
<strong>semántica de referencia</strong>.</p>
<p>El la
<a href="https://developer.apple.com/library/ios/documentation/General/Reference/SwiftStandardLibraryReference/index.html#//apple_ref/doc/uid/TP40014608">biblioteca estándar de Swift</a>
la mayor parte de los tipos definidos son estructuras. Los tipos
básicos de Swift como <code>Int</code>, <code>Double</code>, <code>Bool</code>, <code>String</code>, etc. son
todos ellos estructuras y, por tanto, tienen semántica de copia.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">str1</span> <span class="p">=</span> <span class="s">&quot;Hola&quot;</span>
<span class="kd">var</span> <span class="nv">str2</span> <span class="p">=</span> <span class="n">str1</span>
<span class="n">str1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;Adios&quot;</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">str1</span><span class="p">)</span> <span class="c1">// Imprime &quot;HolaAdios&quot;</span>
<span class="bp">print</span><span class="p">(</span><span class="n">str2</span><span class="p">)</span> <span class="c1">// Imprime &quot;Hola&quot;</span>
</pre></div>
</td></tr></table>

<p>Los arrays también son estructuras y, por tanto, también tienen
semántica de copia:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">array1</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="kd">var</span> <span class="nv">array2</span> <span class="p">=</span> <span class="n">array1</span>
<span class="n">array1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">10</span>
<span class="bp">print</span><span class="p">(</span><span class="n">array1</span><span class="p">)</span> <span class="c1">// [10, 2, 3, 4]</span>
<span class="bp">print</span><span class="p">(</span><span class="n">array2</span><span class="p">)</span> <span class="c1">// [1, 2, 3, 4]</span>
</pre></div>
</td></tr></table>

<p>A diferencia de otros lenguajes como Java, los parámetros de una
función siempre son inmutables y se pasan por copia. Por ejemplo, el
siguiente código sería un error:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>func concat(_ str1: String, con str2: String) -&gt; String {
  // str1.append(str2) -&gt; error
  return str1
}
</pre></div>
</td></tr></table>

<p>A pesar de tener una semántica de copia, la asignación de un array de
una variable a otra o el paso de un array como parámetro de una
función no realiza una copia de todo el array. El compilador de Swift
optimiza estas sentencias y sólo realiza la copia en el momento en que
hay una modificación de una de las variables que comparten el array.</p>
<h3 id="estructuras-mutables-y-let">Estructuras mutables y <code>let</code><a class="headerlink" href="#estructuras-mutables-y-let" title="Permanent link">&para;</a></h3>
<p>Si definimos un valor de una estructura con un <code>let</code> ese valor será
inmutable y no podrá modificarse, a pesar de que el <code>Struct</code> tenga
métodos que mutan sus valores.</p>
<p>Por ejemplo, hemos visto que el método <code>append(_:)</code> de un
<code>String</code> modifica la propia cadena. Si definimos una cadena con <code>let</code>
no podremos modificarla:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">cadenaMutable</span> <span class="p">=</span> <span class="s">&quot;Hola&quot;</span>
<span class="kd">let</span> <span class="nv">cadenaInmutable</span> <span class="p">=</span> <span class="s">&quot;Adios&quot;</span>
<span class="n">cadenaMutable</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">cadenaInmutable</span><span class="p">)</span> <span class="c1">// cadenaMutable es &quot;HolaAdios&quot;</span>
<span class="c1">// cadenaInmutable.append(&quot;Adios&quot;)</span>
<span class="c1">// La sentencia anterior genera un error:</span>
<span class="c1">// &quot;cannot use mutating member on immutable value: &#39;cadenaInmutable&#39; is a &#39;let&#39; constant&quot;</span>
</pre></div>
</td></tr></table>

<h3 id="tipos-valor-y-tipos-referencia">Tipos valor y tipos referencia<a class="headerlink" href="#tipos-valor-y-tipos-referencia" title="Permanent link">&para;</a></h3>
<p>Un <em>tipo valor</em> es un tipo que tiene semántica de copia en las
asignaciones y cuando se pasan como parámetro en llamadas a funciones.</p>
<p>Los tipos valor son muy útiles porque evitan los efectos laterales en
los programas y simplifican el comportamiento del compilador en la
gestión de memoria. Al no existir referencias, se simplifica
enormemente la gestión de memoria de estas estructuras. No es
necesario llevar la cuenta de qué referencias apuntan a un determinado
valor, sino que se puede liberar la memoria en cuanto se elimina el
ámbito actual.</p>
<p>Frente a un tipo valor, un tipo de referencia es aquel en los que los
valores se asignan a variables con una semántica de referencia. Cuando
se realizan varias asignaciones de una misma instancia a distintas
variables todas ellas guardan una referencia a la misma instancia. Si
la instancia se modifica, todas las variables reflejarán el nuevo
valor. Veremos que en Swift todas las instancias de clases tienen esta semántica.</p>
<p>En Swift las estructuras son tipos valor y las clases tipos de
referencia. Comentaremos más diferencias en el tema de programación
orientada a objetos.</p>
<h2 id="clausuras">Clausuras<a class="headerlink" href="#clausuras" title="Permanent link">&para;</a></h2>
<p>Ya hemos visto previamente que en Swift las funciones son objetos de
primera clase del lenguaje y que es posible definir funciones y
pasarlas como parámetro de otras funciones. </p>
<p>También es posible construir clausuras, funciones definidas en el
ámbito de otras funcionas y devueltas como resultados.</p>
<p>Veremos primero cómo definir de forma compacta funciones que se pasan
como parámetro de otras, utilizando <em>expresiones de clausuras</em>. Y
después veremos cómo las clausuras definidas en el interior de otras
funciones capturan las variables definidas en el ámbito de la función principal.</p>
<h3 id="expresiones-de-clausuras">Expresiones de clausuras<a class="headerlink" href="#expresiones-de-clausuras" title="Permanent link">&para;</a></h3>
<p>Swift permite definir expresiones compactas con las que construir
estas funciones que se pasan como parámetro de otras funciones. Se
denominan <em>expresiones de clausuras</em> (<em>closure expressions</em>). Estas
expresiones proporcionan optimizaciones de sintaxis para escribir
clausuras de forma concisa y clara. Vamos a ver las distintas
optimizaciones utilizando como ejemplo el método <code>sorted(by:)</code>.</p>
<h3 id="el-metodo-sortedby">El método <code>sorted(by:)</code><a class="headerlink" href="#el-metodo-sortedby" title="Permanent link">&para;</a></h3>
<p>La biblioteca stándar de Swift define un método <code>sorted()</code> que
devuelve los elementos ordenados de un
<a href="https://developer.apple.com/reference/swift/array">Array</a>. El array
original no se modifica. La comparación entre los elementos se realiza
usando el comparador <code>&lt;</code>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>let estudiantes = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]
let ordenados = estudiantes.sorted()
print(ordenados)
// Prints &quot;[&quot;Abena&quot;, &quot;Akosua&quot;, &quot;Kofi&quot;, &quot;Kweku&quot;, &quot;Peter&quot;]&quot;
</pre></div>
</td></tr></table>

<p>Esta función es similar a las que hay en muchos lenguajes. El único
aspecto funcional es que el array original no se modifica, sino que la
ordenación construye un nuevo array (existe una función alternativa
mutable que se denomina <code>sort()</code>). </p>
<p>Lo interesante relacionado con las clausuras está en la función
<code>sorted(by:)</code>. En esta función se utiliza una clausura como parámetro
para modificar la comparación entre elementos y resultar en una
ordenación distinta. Es una de las distintas funciones de orden
superior que se definen en las colecciones (más adelante veremos
otras).</p>
<p>El perfil de la función <code>sorted(by:)</code> es:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>func sorted(by areInIncreasingOrder: (Element, Element) -&gt; Bool)
</pre></div>
</td></tr></table>

<p>El parámetro es una función de dos parámetros (del tipo de los
elementos del array) que devuelve un booleano indicando si el primer
parámetro va antes que el segundo en el array ordenado. La clausura de
ordenación devuelve <code>true</code> si el primer valor debería aparecer antes
del segundo valor y <code>false</code> en otro caso.</p>
<p>Por ejemplo, podríamos ordenar un array de cadenas en orden alfabético
inverso. </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">primeroMayor</span><span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nv">estudiantes</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;Kofi&quot;</span><span class="p">,</span> <span class="s">&quot;Abena&quot;</span><span class="p">,</span> <span class="s">&quot;Peter&quot;</span><span class="p">,</span> <span class="s">&quot;Kweku&quot;</span><span class="p">,</span> <span class="s">&quot;Akosua&quot;</span><span class="p">]</span>
<span class="kd">let</span> <span class="nv">alreves</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="n">primeroMayor</span><span class="p">)</span>
<span class="bp">print</span><span class="p">(</span><span class="n">alreves</span><span class="p">)</span>
<span class="c1">// Imprime [&quot;Peter&quot;, &quot;Kweku&quot;, &quot;Kofi&quot;, &quot;Akosua&quot;, &quot;Abena&quot;]</span>
</pre></div>
</td></tr></table>

<p>Si la primera cadena (<code>s1</code>) es mayor que la segunda cadena (<code>s2</code>), la
función <code>primeroMayor(s1:s2:)</code> devolverá <code>true</code>, indicando que <code>s1</code>
debería aparecer antes que <code>s2</code> en el array ordenado. La ordenación
mayor o menor se refiere a la ordenación alfabética, al estar tratando
con caracteres.</p>
<p>La versión anterior esta es una forma bastante complicada de escribir
lo que básicamente es una función de una única expresión (<code>a &gt; b</code>). En
este ejemplo, sería preferible escribir la clausura de ordenación
<em>inline</em>, utilizando la sintaxis de expresiones de clausuras.</p>
<h3 id="sintaxis-de-las-expresiones-de-clausura">Sintaxis de las expresiones de clausura<a class="headerlink" href="#sintaxis-de-las-expresiones-de-clausura" title="Permanent link">&para;</a></h3>
<p>La sintaxis de las expresiones de clausura tiene la siguiente forma
general:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>{ ( &lt;parametros&gt;) -&gt; &lt;tipo devuelto&gt; in
   &lt;sentencias&gt;
}
</pre></div>
</td></tr></table>

<p>Si aplicamos esta sintaxis al ejemplo anterior:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">alreves</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="k">in</span>
    <span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span>
<span class="p">})</span>
</pre></div>
</td></tr></table>

<p>Hay que hacer notar que la declaración de los parámetros y el tipo
devuelto por esta clausura <em>inline</em> es idéntica a la declaración de la
función <code>primeroMayor(s1:s2:)</code>. En ambos casos, se escribe como <code>(s1:
String, s2: String) -&gt; Bool</code>. Sin embargo, en la expresión de clausura
los parámetros y el tipo devuelto se escribe dentro de las llaves, no
fuera.</p>
<p>El comienzo del cuerpo de la clausura se introduce por la palabra
clave <code>in</code>. Esta palabra clave indica que la definición de los
parámetros y del tipo devuelto por la clausura ha terminado, y que el
cuerpo de la clausura va a comenzar.</p>
<p>Como el cuerpo de la clausura es corto, podemos incluso escribirlo en
una única línea:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">alreves</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="p">{</span> <span class="p">(</span><span class="n">s1</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">s2</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="k">in</span> <span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span> <span class="p">}</span> <span class="p">)</span>
</pre></div>
</td></tr></table>

<h3 id="inferencia-del-tipo-por-el-contexto">Inferencia del tipo por el contexto<a class="headerlink" href="#inferencia-del-tipo-por-el-contexto" title="Permanent link">&para;</a></h3>
<p>Como la clausura de ordenación se pasa como argumento de un método,
Swift puede inferir los tipos de sus parámetros y el tipo del valor
que devuelve. El método <code>sorted(by:)</code> se llama sobre un array de cadenas,
por lo que su argumento debe ser una función del tipo <code>(String,
String) -&gt; Bool</code>. Esto significa que los tipos <code>(String, String)</code> y
<code>Bool</code> no necesitan escribirse como parte de la definición de la
expresión de la clausura. Debido a que todos los tipos pueden ser
inferidos, la flecha del tipo devuelto y los paréntesis alrededor de
los nombres de los parámetros también pueden omitirse:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">alreves</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="p">{</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="k">in</span> <span class="k">return</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span> <span class="p">}</span> <span class="p">)</span>
</pre></div>
</td></tr></table>

<h3 id="devoluciones-implicitas-en-clausuras-con-una-unica-expresion">Devoluciones implícitas en clausuras con una única expresión<a class="headerlink" href="#devoluciones-implicitas-en-clausuras-con-una-unica-expresion" title="Permanent link">&para;</a></h3>
<p>En clausuras con una única expresión podemos omitir también la palabra
clave <code>return</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">alreves</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="p">{</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="k">in</span> <span class="n">s1</span> <span class="o">&gt;</span> <span class="n">s2</span> <span class="p">}</span> <span class="p">)</span>
</pre></div>
</td></tr></table>

<h3 id="abreviaturas-en-los-nombres-de-los-argumentos">Abreviaturas en los nombres de los argumentos<a class="headerlink" href="#abreviaturas-en-los-nombres-de-los-argumentos" title="Permanent link">&para;</a></h3>
<p>Swift proporciona automáticamente abreviaturas para los nombres de
argumentos de las clausuras <em>inline</em> que pueden usarse para referirse
a los valores de los argumentos de la clausura usando los nombres
<code>$0</code>, <code>$1</code>, <code>$2</code>, etc.</p>
<p>Si se usa estos argumentos abreviados, se puede omitir la definición de la lista de los argumentos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">alreves</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span> <span class="p">)</span>
</pre></div>
</td></tr></table>

<h3 id="funciones-operadoras">Funciones operadoras<a class="headerlink" href="#funciones-operadoras" title="Permanent link">&para;</a></h3>
<p>Incluso hay una forma aun más corta de escribir la expresión de
clausura anterior.  Swift define una implementación específica de
cadenas del operador mayor-que (<code>&gt;</code>) como una función que tiene dos
parámetros de tipo <code>String</code> y devuelve un <code>Bool</code>. Esto es exactamente
lo que necesita el método <code>sorted(by:)</code>. Podemos, por tanto, pasar
simplemente este operador mayor-que, y Swift inferirá que queremos
usar el específico de cadenas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">alreves</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span><span class="p">(</span><span class="n">by</span><span class="p">:</span> <span class="o">&gt;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<h3 id="clausuras-al-final">Clausuras al final<a class="headerlink" href="#clausuras-al-final" title="Permanent link">&para;</a></h3>
<p>Si necesitamos pasar una expresión de clausura a una función como el
argumento final de la clausura y la expresión es larga, puede ser útil
escribirla en su lugar como una clausura al final (<em>trailing
closure</em>). Una clausura al final es una expresión de clausura que se
escribe fuera de (y después de) los paréntesis de la función a la que
se le pasa como parámetro:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">alreves</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span><span class="p">()</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Cuando se proporciona una expresión de clausura como único argumento de
una función o método y se pasa como una clausura al final, no es
necesario escribir los paréntesis tras el nombre de la función:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">alreves</span> <span class="p">=</span> <span class="n">estudiantes</span><span class="p">.</span><span class="bp">sorted</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&gt;</span> <span class="nv">$1</span> <span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Las clausuras al final son útiles sobre todo cuando la clausura es
suficientemente larga que no es posible escribirla <em>inline</em> en una
única línea. Como ejemplo, el tipo <code>Array</code> de Swift tiene el método
<code>map(_:)</code> que toma una expresión de clausura como único argumento (en
el siguiente apartado hablaremos de esta y otras funciones de orden
superior). La clausura se llama una vez para cada elemento del array y
devuelve un valor transformado (posiblemente de otro tipo) para ese
elemento.</p>
<p>Después de aplicar la clausura proporcionada a cada elemento del
array, el método <code>map(_:)</code> devuelve una array nuevo que contiene todos
los nuevos valores transformados, en el mismo orden que sus valores
correspondientes en el array original.</p>
<p>Por ejemplo, podemos usar el método <code>map(_:)</code> con una clausura al
final para convertir un array de valores <code>Int</code> en un array de valores
<code>String</code>. El array <code>[16, 58, 510]</code> se usa para crear el array</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">digitos</span> <span class="p">=</span> <span class="p">[</span>
    <span class="mi">0</span><span class="p">:</span> <span class="s">&quot;Cero&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s">&quot;Uno&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s">&quot;Dos&quot;</span><span class="p">,</span>   <span class="mi">3</span><span class="p">:</span> <span class="s">&quot;Tres&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="s">&quot;Cuatro&quot;</span><span class="p">,</span>
    <span class="mi">5</span><span class="p">:</span> <span class="s">&quot;Cinco&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">:</span> <span class="s">&quot;Seis&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">:</span> <span class="s">&quot;Siete&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">:</span> <span class="s">&quot;Ocho&quot;</span><span class="p">,</span> <span class="mi">9</span><span class="p">:</span> <span class="s">&quot;Nueve&quot;</span>
<span class="p">]</span>
<span class="kd">let</span> <span class="nv">numeros</span> <span class="p">=</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">510</span><span class="p">]</span>
</pre></div>
</td></tr></table>

<p>El código de arriba crea un diccionario que relaciona los dígitos
enteros con sus nombres en castellano y un array de enteros que se
convertirán en cadenas.</p>
<p>Ahora podemos usar el array de nombres para crear un array de valores
<code>String</code>, pasando una expresión de clausura al método <code>map(_:)</code> del
array como una clausura al final:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">cadenas</span> <span class="p">=</span> <span class="n">numeros</span><span class="p">.</span><span class="bp">map</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">numero</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">String</span> <span class="k">in</span>
    <span class="kd">var</span> <span class="nv">numero</span> <span class="p">=</span> <span class="n">numero</span>
    <span class="kd">var</span> <span class="nv">salida</span> <span class="p">=</span> <span class="s">&quot;&quot;</span>
    <span class="k">while</span> <span class="n">numero</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="n">salida</span> <span class="p">=</span> <span class="n">digitos</span><span class="p">[</span><span class="n">numero</span> <span class="o">%</span> <span class="mi">10</span><span class="p">]</span><span class="o">!</span> <span class="o">+</span> <span class="n">salida</span>
        <span class="n">numero</span> <span class="o">/=</span> <span class="mi">10</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">salida</span>
<span class="p">}</span>
<span class="bp">print</span><span class="p">(</span><span class="n">cadenas</span><span class="p">)</span>
<span class="c1">// las cadenas se infieren de tipo [String]</span>
<span class="c1">// imprime [&quot;UnoSeis&quot;, &quot;CincoOcho&quot;, &quot;CincoUnoCero&quot;]</span>
</pre></div>
</td></tr></table>

<p>El método <code>map(_:)</code> llama a la expresión de clausura una vez por cada
elemento del array. La variable <code>numero</code> se incializa con el valor
<code>numero</code> del parámetro de la clausura para poder modificarlo dentro
del cuerpo de la clausura (los parámetros de las funciones y las
clausuras son siempre constanes). El bucle <code>while</code> usa el diccionario
de dígitos para construir la cadena correspondiente al valor <code>Int</code>.</p>
<h3 id="valores-capturados">Valores capturados<a class="headerlink" href="#valores-capturados" title="Permanent link">&para;</a></h3>
<p>Una clausura puede capturar constantes y variables del contexto en el
que se define. La clausura puede referirse y modificar esos valores
dentro de su cuerpo, incluso si ya no existe el ámbito (<em>scope</em>)
original en el que se definieron estas constantes y variables.</p>
<p>En Swift, la forma más sencilla de una clausura que captura valores es
una función anidada (<em>nested function</em>) escrita en el cuerpo de otra
función. Una función anidada puede capturar cualquiera de los
argumentos de su función exterior y también puede capturar cualquier
constante y variable definida dentro de la función exterior.</p>
<p>Veamos un ejemplo similar al que vimos en Scheme. La función
<code>construyeIncrementador</code> contiene una función anidada llamada
<code>incrementador</code>. Esta función captura dos valores de su contexto:
<code>totalAcumulado</code> y <code>cantidad</code>. Después de capturar estos valores,
<code>incrementador</code> es devuelto por <code>construyeIncrementador</code> como una
clausura que incrementa <code>totalAcumulado</code> en <code>cantidad</code> cada vez que se
llama.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">construyeIncrementador</span><span class="p">(</span><span class="n">incremento</span> <span class="n">cantidad</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">totalAcumulado</span> <span class="p">=</span> <span class="mi">0</span>
    <span class="kd">func</span> <span class="nf">incrementador</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="n">totalAcumulado</span> <span class="o">+=</span> <span class="n">cantidad</span>
        <span class="k">return</span> <span class="n">totalAcumulado</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">incrementador</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>El tipo devuelto de <code>construyeIncrementador</code> es <code>() -&gt; Int</code>. Esto
significa que devuelve una función que no tiene parámetros y que
devuelve un <code>Int</code> cada vez que es llamada.</p>
<p>La función <code>construyeIncrementador(incremento:)</code> tiene un único
parámetro <code>Int</code> con nombre externo <code>incremento</code> y nombre local
<code>cantidad</code>. El argumento pasado a este parámetro especifica cuánto
será incrementado <code>totalAcumulado</code> cada vez que se llama a la función
<code>incrementador</code> devuelta. La función <code>construyeIncrementador</code> define
una función anidada llamada <code>incrementador</code>, que realiza el incremento
real. Esta función simplemente añade <code>cantidad</code> a <code>totalAcumulado</code>, y
devuelve el resultado.</p>
<p>Si la consideramos aislada, la función anidada <code>incrementador()</code>
podría parecer extraña:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">incrementador</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="n">totalAcumulado</span> <span class="o">+=</span> <span class="n">cantidad</span>
    <span class="k">return</span> <span class="n">totalAcumulado</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>La función no tiene ningún parámetro, y sin embargo se refiere a
<code>totalAcumulado</code> y a <code>cantidad</code> en su cuerpo. Lo puede hacer porque ha
capturado una referencia a estas variables de la función de alrededor
y las usa en su propio cuerpo. Al capturar estas referencias las
variables <code>totalAcumulado</code> y <code>cantidad</code> no desaparecen cuando termina
la llamada a <code>construyeIncrementador</code>. Estas variables también estarán
disponibles la próxima vez que se llame la función <code>incrementador</code>.</p>
<p>Aquí hay un ejemplo de <code>construyeIncrementador</code> en acción:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">incrementaDiez</span> <span class="p">=</span> <span class="n">construyeIncrementador</span><span class="p">(</span><span class="n">incremento</span><span class="p">:</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Este ejemplo define una constante llamada <code>incrementaDiez</code> para
referenciar la función <code>incrementador</code> que devuelve
<code>construyeIncrementador</code>. Esta función añade 10 a la variable
<code>totalAcumulado</code> cada vez que se es llamada. Si llamamos a la función
más de una vez podemos comprobar su conducta en acción:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">incrementaDiez</span><span class="p">()</span>
<span class="c1">// devuelve 10</span>
<span class="n">incrementaDiez</span><span class="p">()</span>
<span class="c1">// devuelve 20</span>
<span class="n">incrementaDiez</span><span class="p">()</span>
<span class="c1">// devuelve 30</span>
</pre></div>
</td></tr></table>

<p>Si creamos un segundo incrementador, tendrá sus propias referencias a
un variable <code>totalAcumulado</code> nueva, distinta de la anterior:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">incrementaSiete</span> <span class="p">=</span> <span class="n">construyeIncrementador</span><span class="p">(</span><span class="n">incremento</span><span class="p">:</span> <span class="mi">7</span><span class="p">)</span>
<span class="n">incrementaSiete</span><span class="p">()</span>
<span class="c1">// devuelve 7</span>
</pre></div>
</td></tr></table>

<p>Si llamamos a la función <code>incrementador</code> original (<code>incrementaDiez</code>)
vemos que sigue incrementando su propia variable <code>totalAcumulado</code> y
que no se ve afectada por la variable capturada por <code>incrementaSiete</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">incrementaDiez</span><span class="p">()</span>
<span class="c1">// devuelve 40</span>
</pre></div>
</td></tr></table>

<h3 id="mutacion-de-variables-capturadas">Mutación de variables capturadas<a class="headerlink" href="#mutacion-de-variables-capturadas" title="Permanent link">&para;</a></h3>
<p>Las clausuras también pueden modificar el valor de las variables
capturadas. Veamos un ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">1</span>

<span class="kd">func</span> <span class="nf">construyeFunc</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">x</span> <span class="p">=</span> <span class="mi">10</span>

    <span class="kd">func</span> <span class="nf">prueba</span><span class="p">(</span><span class="kc">_</span> <span class="n">a</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="p">{</span>
        <span class="n">x</span> <span class="p">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">prueba</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">f</span> <span class="p">=</span> <span class="n">construyeFunc</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="c1">// Imprime 20</span>
<span class="bp">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="c1">// Imprime 30</span>
<span class="kd">let</span> <span class="nv">g</span> <span class="p">=</span> <span class="n">construyeFunc</span><span class="p">()</span>
<span class="bp">print</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span> <span class="c1">// Imprime 20</span>
<span class="bp">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="c1">// Imprime 1</span>
</pre></div>
</td></tr></table>

<p>La clausura <code>prueba</code> <strong>captura la variable <code>x</code> definida en el ámbito
de <code>construyeFunc</code></strong> y la utiliza en su cuerpo. La variable capturada
queda ligada a la clausura y es utilizada cada vez que la clausura se
invoca.</p>
<p>En la primera invocación a la clausura se pasa como parámetro <code>a</code> el
valor 10, que se suma a la variable capturada. De esta forma la
variable capturada pasa a valer 20.</p>
<p>En la segunda invocación a la clausura el valor de <code>x</code> será 20, por lo
que devolverá 30.</p>
<p>La segunda vez que llamamos a <code>construyeFunc</code> se crea un nuevo ámbito
local con una nueva variable <code>x</code> que se inicializa a 10. Esa nueva
variable es el que captura la nueva clausura que se devuelve. Por eso
al invocarla (en la llamada <code>g(10)</code>) se devuelve 20.</p>
<h3 id="las-clausuras-son-tipos-de-referencia">Las clausuras son tipos de referencia<a class="headerlink" href="#las-clausuras-son-tipos-de-referencia" title="Permanent link">&para;</a></h3>
<p>En el ejemplo anterior, <code>incrementaSiete</code> e <code>incrementaDiez</code> son
constantes, pero las clausuras a las que estas constantes se refieren
pueden incrementar la variable <code>totalAcumulado</code> que han
capturado. Esto es porque funciones y clausuras son tipos referencia.</p>
<p>Siempre que asignamos una función o una clausura a una constante o una
variable, estamos realmente estableciendo que la constante o variable
es una referencia a la función o la clausura. En el ejemplo anterior,
es la elección de la clausura a la que referencia <code>incrementaDiez</code> la
que es constante, no los contenidos propios de la clausura.</p>
<p>Esto también significa que si asignamos una clausura a dos constantes
o variables distintas, ambas constantes o variables se referirán a la
misma clausura:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">tambienIncrementaDiez</span> <span class="p">=</span> <span class="n">incrementaDiez</span>
<span class="n">tambienIncrementaDiez</span><span class="p">()</span>
<span class="c1">// devuelve 50</span>
</pre></div>
</td></tr></table>

<h2 id="funciones-de-orden-superior">Funciones de orden superior<a class="headerlink" href="#funciones-de-orden-superior" title="Permanent link">&para;</a></h2>
<p>Una de las características funcionales que más hemos usado para
trabajar con listas en Scheme son las funciones de orden superior como
<code>map</code>, <code>filter</code> o <code>fold-right</code>. Swift tiene definidas funciones
equivalentes para trabajar con colecciones. Se denominan <code>map</code>,
<code>filter</code> y <code>reduce</code>. Todas ellas aceptan expresiones de clausura como
argumento.</p>
<h3 id="map">Map<a class="headerlink" href="#map" title="Permanent link">&para;</a></h3>
<p>El método <code>map</code> se define en el protocolo
<a href="https://developer.apple.com/library/ios/documentation/Swift/Reference/Swift_CollectionType_Protocol/index.html#//apple_ref/swift/intfm/CollectionType/s:FEsPs14CollectionType3mapurFzFzWx9Generator7Element_qd__GSaqd___"><code>CollectionType</code></a>
y es adoptado por múltiples estructuras como <code>Array</code>, <code>Dictionary</code>,
<code>Set</code> o <code>String.CharacterView</code>.</p>
<p>El método <code>map</code> recibe como parámetro una función unaria <code>transform</code>
del tipo de los elementos de la colección y que devuelve otro elemento
(puede ser del mismo o de distinto tipo que los elementos de la
colección). Devuelve un array que contiene el resultado de aplicar
<code>transform</code> a cada elemento del array original.</p>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">numeros</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">](</span><span class="mf">0.</span><span class="p">..</span><span class="mi">5</span><span class="p">)</span>
<span class="n">numeros</span><span class="p">.</span><span class="bp">map</span> <span class="p">{</span><span class="nv">$0</span> <span class="o">*</span> <span class="nv">$0</span><span class="p">}</span>
<span class="c1">// devuelve [0, 1, 4, 9, 16, 25]</span>
</pre></div>
</td></tr></table>

<p>Otro ejemplo, en el que usamos <code>map</code> para implementar la función
<code>sumaParejas(parejas: [(Int, Int)]) -&gt; [Int]</code> que devuelve recibe el
array <code>parejas</code> de tuplas de dos enteros y devuelve un array con el
resultado de sumar los dos elementos de cada pareja:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">suma</span><span class="p">(</span><span class="n">parejas</span><span class="p">:</span> <span class="p">[(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)])</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">parejas</span><span class="p">.</span><span class="bp">map</span><span class="p">({(</span><span class="n">pareja</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">))</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="k">in</span>
                        <span class="k">return</span> <span class="n">pareja</span><span class="p">.</span><span class="mi">0</span> <span class="o">+</span> <span class="n">pareja</span><span class="p">.</span><span class="mi">1</span><span class="p">})</span>
<span class="p">}</span>
<span class="n">suma</span><span class="p">(</span><span class="n">parejas</span><span class="p">:[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="c1">// devuelve [2, 4, 6, 8]</span>
</pre></div>
</td></tr></table>

<p>Podemos usar en el cuerpo de la expresión de clausura de <code>map</code> una
variable capturada. Por ejemplo en la siguiente función
<code>incrementaValores(_:con:)</code> que suma <code>con</code> a todos los números de un
array que se le pasa por parámetro:</p>
<p><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">incrementa</span><span class="p">(</span><span class="n">valores</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">],</span> <span class="n">con</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">valores</span><span class="p">.</span><span class="bp">map</span><span class="p">({(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="k">in</span>
                        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">con</span><span class="p">})</span>
<span class="p">}</span>
<span class="n">incrementa</span><span class="p">(</span><span class="n">valores</span><span class="p">:[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="n">con</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// devuelve [15, 25, 35]</span>
</pre></div>
</td></tr></table>
La versión abreviada de la expresión de clausura es:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">incrementa</span><span class="p">(</span><span class="n">valores</span><span class="p">:</span> <span class="p">[</span><span class="nb">Int</span><span class="p">],</span> <span class="n">con</span> <span class="n">inc</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="nb">Int</span><span class="p">]</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">valores</span><span class="p">.</span><span class="bp">map</span> <span class="p">{</span><span class="nv">$0</span> <span class="o">+</span> <span class="n">inc</span><span class="p">}</span>
<span class="p">}</span>
<span class="n">incrementa</span><span class="p">(</span><span class="n">valores</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span> <span class="n">con</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// devuelve [15, 25, 35]</span>
</pre></div>
</td></tr></table>

<h3 id="filter">Filter<a class="headerlink" href="#filter" title="Permanent link">&para;</a></h3>
<p>La función <code>filter</code> recibe una clausura de un argumento que devuelve
un booleano. La función devuelve una colección con los elementos de la
colección para los que la clausura devuelve <em>true</em>. </p>
<p>Ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">numeros</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">](</span><span class="mf">0.</span><span class="p">..</span><span class="mi">10</span><span class="p">)</span>
<span class="n">numeros</span><span class="p">.</span><span class="bp">filter</span> <span class="p">{</span><span class="nv">$0</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">==</span> <span class="mi">0</span><span class="p">}</span>
<span class="c1">// devuelve [0, 2, 4, 6, 8, 10]</span>
</pre></div>
</td></tr></table>

<h3 id="reduce">Reduce<a class="headerlink" href="#reduce" title="Permanent link">&para;</a></h3>
<p>Similar al <em>fold</em> de Scheme:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">numeros</span> <span class="p">=</span> <span class="p">[</span><span class="nb">Int</span><span class="p">](</span><span class="mf">0.</span><span class="p">..</span><span class="mi">10</span><span class="p">)</span>
<span class="n">numeros</span><span class="p">.</span><span class="bp">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">+</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>La función combina los elementos de la colección usando la función de
combinación que se pasa como parámetro. La función que se pasa como
parámetro recibe dos parámetros: el primero es el resultado de la
combinación y el segundo se coge de la colección. </p>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">cadenas</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;Patatas&quot;</span><span class="p">,</span> <span class="s">&quot;Arroz&quot;</span><span class="p">,</span> <span class="s">&quot;Huevos&quot;</span><span class="p">]</span>
<span class="n">cadenas</span><span class="p">.</span><span class="bp">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">{(</span><span class="n">i</span><span class="p">:</span> <span class="nb">Int</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="k">in</span>
                      <span class="n">c</span><span class="p">.</span><span class="bp">count</span> <span class="o">+</span> <span class="n">i</span> <span class="p">})</span>
<span class="c1">// devuelve 18</span>
</pre></div>
</td></tr></table>

<p>Es posible simplificar la notación anterior:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">cadenas</span><span class="p">.</span><span class="bp">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">{</span><span class="nv">$1</span><span class="p">.</span><span class="bp">count</span> <span class="o">+</span> <span class="nv">$0</span><span class="p">})</span>
</pre></div>
</td></tr></table>

<p>También se puede utilizar la notación de clausura al final:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">cadenas</span><span class="p">.</span><span class="bp">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="nv">$1</span><span class="p">.</span><span class="bp">count</span> <span class="o">+</span> <span class="nv">$0</span><span class="p">}</span>
</pre></div>
</td></tr></table>

<p>La combinación se hace de izquierda a derecha:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">cadenas</span> <span class="p">=</span> <span class="p">[</span><span class="s">&quot;Patatas&quot;</span><span class="p">,</span> <span class="s">&quot;Arroz&quot;</span><span class="p">,</span> <span class="s">&quot;Huevos&quot;</span><span class="p">]</span>
<span class="n">cadenas</span><span class="p">.</span><span class="bp">reduce</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="o">+</span><span class="p">)</span>
<span class="c1">// devuelve &quot;PatatasArrozHuevos&quot;</span>
</pre></div>
</td></tr></table>

<h3 id="combinacion-de-funciones-de-orden-superior">Combinación de funciones de orden superior<a class="headerlink" href="#combinacion-de-funciones-de-orden-superior" title="Permanent link">&para;</a></h3>
<p>Cuando el resultado de aplicar una función de orden superior a una
colección es otra colección es posible aplicar otra función de
orden superior a este resultado.</p>
<p>Por ejemplo, la siguiente sentencia devuelve todos los números pares
del array inicial elevados al cuadrado:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">numeros</span> <span class="p">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="n">numeros</span><span class="p">.</span><span class="bp">filter</span><span class="p">{</span><span class="nv">$0</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">==</span> <span class="mi">0</span><span class="p">}.</span><span class="bp">map</span><span class="p">{</span><span class="nv">$0</span><span class="o">*</span><span class="nv">$0</span><span class="p">}</span>
<span class="c1">// Devuelve el array [4,16,36,64,100]</span>
</pre></div>
</td></tr></table>

<p>Y la siguiente devuelve la suma números mayores de 100:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">numeros</span> <span class="p">=</span> <span class="p">[</span><span class="mi">103</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">330</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">532</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">125</span><span class="p">]</span>
<span class="n">numeros</span><span class="p">.</span><span class="bp">filter</span><span class="p">{</span><span class="nv">$0</span> <span class="o">&gt;=</span> <span class="mi">100</span><span class="p">}.</span><span class="bp">reduce</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">+</span><span class="p">)</span>
<span class="c1">// Devuelve 1090</span>
</pre></div>
</td></tr></table>

<h2 id="genericos">Genéricos<a class="headerlink" href="#genericos" title="Permanent link">&para;</a></h2>
<p>Empecemos con un ejemplo sencillo. Supongamos la siguiente función
<code>intercambia(_:)</code> que recibe una tupla <code>(Int, String)</code> y devuelve una
tupla <code>(String, Int)</code> con los valores intercambiados.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">intercambia</span><span class="p">(</span><span class="kc">_</span> <span class="n">tupla</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">String</span><span class="p">))</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">let</span> <span class="nv">tuplaNueva</span> <span class="p">=</span> <span class="p">(</span><span class="n">tupla</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span> <span class="n">tupla</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
   <span class="k">return</span> <span class="n">tuplaNueva</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">tupla</span> <span class="p">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&quot;Hola&quot;</span><span class="p">)</span>
<span class="n">intercambia</span><span class="p">(</span><span class="n">tupla</span><span class="p">)</span>
<span class="c1">// devuelve (&quot;Hola&quot;, 10)</span>
</pre></div>
</td></tr></table>

<p>La función es interesante, pero sólo recibe tuplas cuya primera
componente es un <code>Int</code> y su segunda componente es un
<code>String</code>. Supongamos que queremos hacer la misma función para
intercambiar elementos de una tupla <code>(Int, Int)</code>. Tendríamos que usar
el mismo código, pero cambiando los tipos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">intercambia</span><span class="p">(</span><span class="kc">_</span> <span class="n">tupla</span><span class="p">:</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">))</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="nb">Int</span><span class="p">,</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">let</span> <span class="nv">tuplaNueva</span> <span class="p">=</span> <span class="p">(</span><span class="n">tupla</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span> <span class="n">tupla</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
   <span class="k">return</span> <span class="n">tuplaNueva</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">tupla</span> <span class="p">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">intercambia</span><span class="p">(</span><span class="n">tupla</span><span class="p">)</span>
<span class="c1">// devuelve (20, 10)</span>
</pre></div>
</td></tr></table>

<p>El código es el mismo, lo único distinto son los tipos. ¿Podríamos
<strong>generalizar</strong> las funciones anteriores para hacer que el código
pueda trabajar con cualquier tipo? La respuesta es sí, usando
<strong>función genérica</strong>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">func</span> <span class="nf">intercambia</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">tupla</span><span class="p">:</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">))</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">let</span> <span class="nv">tuplaNueva</span> <span class="p">=</span> <span class="p">(</span><span class="n">tupla</span><span class="p">.</span><span class="mi">1</span><span class="p">,</span> <span class="n">tupla</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
   <span class="k">return</span> <span class="n">tuplaNueva</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>El cuerpo de la función es idéntico a la función anterior. La
diferencia es que en la versión genérica se usan <em>placeholders</em> (los
símbolos <code>A</code> y <code>B</code>) en lugar de tipos concretos. Son tipos genéricos,
que se definen usando un identificador entre símbolos de <code>&lt;</code> y
<code>&gt;</code>. Los tipos reales que se van a usar en la función se determinan en
cada invocación a la función, dependiendo del tipo del parámetro que
se utiliza en la llamada:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">let</span> <span class="nv">tupla</span> <span class="p">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">&quot;Hola&quot;</span><span class="p">)</span>
<span class="n">intercambia</span><span class="p">(</span><span class="n">tupla</span><span class="p">)</span>
<span class="c1">// devuelve (&quot;Hola&quot;, 10)</span>
<span class="kd">let</span> <span class="nv">tupla2</span> <span class="p">=</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">intercambia</span><span class="p">(</span><span class="n">tupla2</span><span class="p">)</span>
<span class="c1">// devuelve (10, 20)</span>
<span class="kd">let</span> <span class="nv">tupla3</span> <span class="p">=</span> <span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="mf">10.5</span><span class="p">)</span>
<span class="n">intercambia</span><span class="p">(</span><span class="n">tupla3</span><span class="p">)</span>
<span class="c1">// devuelve (10.5, true)</span>
</pre></div>
</td></tr></table>

<p>En el primer ejemplo, los tipos <code>A</code> y <code>B</code> se infieren como <code>Int</code> y
<code>String</code>. En el segundo ejemplo como <code>Int</code> e <code>Int</code>. Y en el tercero
como <code>Bool</code> y <code>Double</code>.</p>
<p>Los tipos genéricos se pueden usar en la definición de todos los
elementos de Swift: funciones, enums, estructuras, clases, protocolos
o extensiones. Terminamos con un ejemplo en el que incluimos muchos
conceptos vistos en este tema. Se trata de la implementación en Swift
de listas al estilo Scheme, con las funciones <code>car</code>, <code>cdr</code> y <code>vacia</code>
usando un enum recursivo con un tipo genérico que permite generalizar
el tipo de elementos de la lista.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kr">indirect</span> <span class="kd">enum</span> <span class="nc">Lista</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
     <span class="k">case</span> <span class="n">vacia</span>
     <span class="k">case</span> <span class="n">cons</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">Lista</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">car</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">lista</span><span class="p">:</span> <span class="n">Lista</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span> <span class="p">-&gt;</span> <span class="n">T</span><span class="p">?</span> <span class="p">{</span>
   <span class="k">switch</span> <span class="n">lista</span> <span class="p">{</span>
      <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">cons</span><span class="p">(</span><span class="n">primero</span><span class="p">,</span> <span class="kc">_</span><span class="p">):</span>
         <span class="k">return</span> <span class="n">primero</span>
      <span class="k">case</span> <span class="p">.</span><span class="n">vacia</span><span class="p">:</span>
         <span class="k">return</span> <span class="kc">nil</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">cdr</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">lista</span><span class="p">:</span> <span class="n">Lista</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span> <span class="p">-&gt;</span> <span class="n">Lista</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;?</span> <span class="p">{</span>
   <span class="k">switch</span> <span class="n">lista</span> <span class="p">{</span>
      <span class="k">case</span> <span class="kd">let</span> <span class="p">.</span><span class="n">cons</span><span class="p">(</span><span class="kc">_</span><span class="p">,</span> <span class="n">resto</span><span class="p">):</span>
         <span class="k">return</span> <span class="n">resto</span>
      <span class="k">case</span> <span class="p">.</span><span class="n">vacia</span><span class="p">:</span>
         <span class="k">return</span> <span class="kc">nil</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">vacia</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">lista</span><span class="p">:</span> <span class="n">Lista</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
   <span class="k">switch</span> <span class="n">lista</span> <span class="p">{</span>
      <span class="k">case</span> <span class="p">.</span><span class="n">vacia</span><span class="p">:</span>
         <span class="k">return</span> <span class="kc">true</span>
      <span class="k">default</span><span class="p">:</span>
         <span class="k">return</span> <span class="kc">false</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nv">lista</span> <span class="p">:</span> <span class="n">Lista</span> <span class="p">=</span> <span class="p">.</span><span class="n">cons</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="p">.</span><span class="n">cons</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="p">.</span><span class="n">cons</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="p">.</span><span class="n">vacia</span><span class="p">)))</span>

<span class="bp">print</span><span class="p">(</span><span class="n">car</span><span class="p">(</span><span class="n">lista</span><span class="p">)</span><span class="o">!</span><span class="p">)</span> <span class="c1">// Imprime 20</span>
<span class="bp">print</span><span class="p">(</span><span class="n">car</span><span class="p">(</span><span class="n">cdr</span><span class="p">(</span><span class="n">lista</span><span class="p">)</span><span class="o">!</span><span class="p">)</span><span class="o">!</span><span class="p">)</span> <span class="c1">// Imprime 30</span>
<span class="bp">print</span><span class="p">(</span><span class="n">car</span><span class="p">(</span><span class="n">cdr</span><span class="p">(</span><span class="n">cdr</span><span class="p">(</span><span class="n">lista</span><span class="p">)</span><span class="o">!</span><span class="p">)</span><span class="o">!</span><span class="p">)</span><span class="o">!</span><span class="p">)</span> <span class="c1">// Imprime 40</span>
<span class="bp">print</span><span class="p">(</span><span class="n">vacia</span><span class="p">(</span><span class="n">cdr</span><span class="p">(</span><span class="n">cdr</span><span class="p">(</span><span class="n">cdr</span><span class="p">(</span><span class="n">lista</span><span class="p">)</span><span class="o">!</span><span class="p">)</span><span class="o">!</span><span class="p">)</span><span class="o">!</span><span class="p">))</span> <span class="c1">// Imprime true</span>
</pre></div>
</td></tr></table>

<h2 id="bibliografia">Bibliografía<a class="headerlink" href="#bibliografia" title="Permanent link">&para;</a></h2>
<ul>
<li>Swift Language Guide<ul>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309">The Basics</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/CollectionTypes.html#//apple_ref/doc/uid/TP40014097-CH8-ID105">Collection Types</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html#//apple_ref/doc/uid/TP40014097-CH10-ID158">Functions</a></li>
<li>
<h2 id="closures"><a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID94">Closures</a><a class="headerlink" href="#closures" title="Permanent link">&para;</a></h2>
<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145">Enumerations</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179">Generics</a></li>
</ul>
</li>
<li><a href="https://developer.apple.com/library/ios/documentation/General/Reference/SwiftStandardLibraryReference/">Biblioteca estándar de Swift</a></li>
</ul>
<hr />
<p>Lenguajes y Paradigmas de Programación, curso 2018–19<br />
© Departamento Ciencia de la Computación e Inteligencia Artificial, Universidad de Alicante<br />
Domingo Gallardo, Cristina Pomares, Antonio Botía, Francisco Martínez</p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
        
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.583bbe55.js"></script>
      
        
        
          
          <script src="../../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
              
              
                <script src="../../assets/javascripts/lunr/lunr.es.js"></script>
              
            
          
          
        
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
    
    
      
    
  </body>
</html>