



<!DOCTYPE html>
<html lang="es" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copiar al portapapeles">
      
        <meta name="lang:clipboard.copied" content="Copiado al portapapeles">
      
        <meta name="lang:search.language" content="es">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No se encontraron documentos">
      
        <meta name="lang:search.result.one" content="1 documento encontrado">
      
        <meta name="lang:search.result.other" content="# documentos encontrados">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-3.0.4">
    
    
      
        <title>Tema 2: Programación funcional - LPP</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.451f80e5.css">
      
        <link rel="stylesheet" href="../../assets/stylesheets/application-palette.22915126.css">
      
      
        
        
        <meta name="theme-color" content="#fb8c00">
      
    
    
      <script src="../../assets/javascripts/modernizr.1aa3b519.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="orange" data-md-color-accent="deep-orange">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="../../#tema-2-programacion-funcional" tabindex="1" class="md-skip">
        Saltar a contenido
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="LPP" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            
              <span class="md-header-nav__topic">
                LPP
              </span>
              <span class="md-header-nav__topic">
                Tema 2: Programación funcional
              </span>
            
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          
            <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
            
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Búsqueda" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Teclee para comenzar búsqueda
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
          
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="LPP" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    LPP
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1">
    
    <label class="md-nav__link" for="nav-1">
      Teoría
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        Teoría
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../tema00-descripcion-asignatura/tema00-descripcion-asignatura.html" title="Descripción de la asignatura" class="md-nav__link">
      Descripción de la asignatura
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Tabla de contenidos</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#contenidos" title="Contenidos" class="md-nav__link">
    Contenidos
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#bibliografia-sicp" title="Bibliografía - SICP" class="md-nav__link">
    Bibliografía - SICP
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#111-definicion-y-caracteristicas" title="1.1.1 Definición y características" class="md-nav__link">
    1.1.1 Definición y características
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#111-origenes-historicos" title="1.1.1 Orígenes históricos" class="md-nav__link">
    1.1.1 Orígenes históricos
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#112-historia-y-caracteristicas-del-lisp" title="1.1.2 Historia y características del Lisp" class="md-nav__link">
    1.1.2 Historia y características del Lisp
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#113-lenguajes-de-programacion-funcional" title="1.1.3 Lenguajes de programación funcional" class="md-nav__link">
    1.1.3 Lenguajes de programación funcional
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#114-aplicaciones-practicas-de-la-programacion-funcional" title="1.1.4. Aplicaciones prácticas de la programación funcional" class="md-nav__link">
    1.1.4. Aplicaciones prácticas de la programación funcional
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#programacion-de-sistemas-concurrentes" title="Programación de sistemas concurrentes" class="md-nav__link">
    Programación de sistemas concurrentes
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#definicion-y-composicion-de-operaciones-sobre-streams" title="Definición y composición de operaciones sobre streams" class="md-nav__link">
    Definición y composición de operaciones sobre streams
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#programacion-evolutiva" title="Programación evolutiva" class="md-nav__link">
    Programación evolutiva
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="tema-2-programacion-funcional">Tema 2: Programación funcional<a class="headerlink" href="#tema-2-programacion-funcional" title="Permanent link">&para;</a></h1>
<h2 id="contenidos">Contenidos<a class="headerlink" href="#contenidos" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="#1">1. El paradigma de Programación Funcional</a><ul>
<li><a href="#1-1">1.1 Pasado y presente del paradigma funcional</a></li>
<li><a href="#1-2">1.2. Programación declarativa vs. imperativa</a></li>
<li><a href="#1-3">1.3. Evaluación de expresiones</a></li>
<li><a href="#1-4">1.4. Modelo de computación de sustitución</a></li>
</ul>
</li>
<li><a href="#2">2. Scheme como lenguaje de programación funcional</a><ul>
<li><a href="#2-1">2.1. Funciones y formas especiales</a></li>
<li><a href="#2-2">2.2. Formas especiales en Scheme: <code>define</code>, <code>if</code>, <code>cond</code></a></li>
<li><a href="#2-3">2.3. Forma especial <code>quote</code> y símbolos</a></li>
<li><a href="#2-4">2.4. Listas</a></li>
<li><a href="#2-5">2.5. Recursión</a></li>
<li><a href="#2-6">2.6. Recursión y listas</a></li>
</ul>
</li>
<li><a href="#3">3. Tipos de datos compuestos en Scheme</a><ul>
<li><a href="#3-1">3.1. El tipo de dato pareja</a></li>
<li><a href="#3-2">3.2. Las parejas son objetos de primera clase</a></li>
<li><a href="#3-3">3.3.  Diagramas <em>caja-y-puntero</em></a></li>
</ul>
</li>
<li><a href="#4">4. Listas en Scheme</a><ul>
<li><a href="#4-1">4.1. Implementación de listas en Scheme</a></li>
<li><a href="#4-2">4.2. Listas con elementos compuestos</a></li>
<li><a href="#4-3">4.3. Funciones recursivas sobre listas</a></li>
<li><a href="#4-4">4.4. Funciones con número variable de argumentos</a></li>
</ul>
</li>
<li><a href="#5">5. Funciones como tipos de datos de primera clase</a><ul>
<li><a href="#5-1">5.1. Forma especial <code>lambda</code></a></li>
<li><a href="#5-2">5.2. Funciones como argumentos de otras funciones</a></li>
<li><a href="#5-3">5.3. Funciones que devuelven otras funciones</a></li>
<li><a href="#5-4">5.4. Funciones en estructuras de datos</a></li>
<li><a href="#5-5">5.5. Funciones de orden superior</a></li>
</ul>
</li>
</ul>
<h2 id="bibliografia-sicp">Bibliografía - SICP<a class="headerlink" href="#bibliografia-sicp" title="Permanent link">&para;</a></h2>
<p>En este tema explicamos conceptos de los siguientes capítulos del
libro <em>Structure and Intepretation of Computer Programs</em>:</p>
<ul>
<li><a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1.1">1.1.1 - Expressions</a></li>
<li><a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1.2">1.1.2 - Naming and environment</a></li>
<li><a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1.3">1.1.3 - Evaluating combinations</a></li>
<li><a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1.4">1.1.4 - Compound procedures</a></li>
<li><a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1.5">1.1.5 - The Substitution Model for Procedure Application</a></li>
<li><a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html#%_sec_1.1.6">1.1.6 - Conditional Expressions and Predicates</a></li>
<li><a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-12.html#%_sec_1.3">1.3 - Formulating Abstractions with Higher-Order Procedures</a></li>
<li><a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2">2.2 - Hierarchical Data and the Closure Property</a> (Introducción de la sección)</li>
<li><a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.1">2.2.1 - Representing Sequences</a></li>
<li><a href="https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-16.html#%_sec_2.3.1">2.3.1 - Quotation</a></li>
</ul>
<h2 id="1-el-paradigma-de-programacion-funcional"><a name="1"></a> 1. El paradigma de Programación Funcional<a class="headerlink" href="#1-el-paradigma-de-programacion-funcional" title="Permanent link">&para;</a></h2>
<h3 id="11-pasado-y-presente-del-paradigma-funcional"><a name="1-1"></a> 1.1. Pasado y presente del paradigma funcional<a class="headerlink" href="#11-pasado-y-presente-del-paradigma-funcional" title="Permanent link">&para;</a></h3>
<h4 id="111-definicion-y-caracteristicas">1.1.1 Definición y características<a class="headerlink" href="#111-definicion-y-caracteristicas" title="Permanent link">&para;</a></h4>
<p>En una definición muy breve y concisa la programación funcional define
un <strong>programa</strong> como:</p>
<blockquote>
<p>Un conjunto de funciones matemáticas que convierten
unas entradas en unas salidas, sin ningún estado interno y ningún
efecto lateral.</p>
</blockquote>
<p>Hablaremos más adelante de la no existencia de estado interno
(variables en las que se guardan y se modifican valores) y de la ausencia
de efectos laterales. Avancemos que estas son también características
de la <strong>programación declarativa</strong>. En este sentido, la programación
funcional es un tipo concreto de programación declarativa.</p>
<p>Las características principales del paradigma funcional son:</p>
<ul>
<li>Definiciones de funciones matemáticas puras, sin estado interno ni
  efectos laterales</li>
<li>Valores inmutables</li>
<li>Uso profuso de la recursión en la definición de las funciones</li>
<li>Uso de listas como estructuras de datos fundamentales</li>
<li>Funciones como tipos de datos primitivos: expresiones lambda y
  funciones de orden superior</li>
</ul>
<p>Explicaremos estas propiedades a continuación.</p>
<h4 id="111-origenes-historicos">1.1.1 Orígenes históricos<a class="headerlink" href="#111-origenes-historicos" title="Permanent link">&para;</a></h4>
<p>En los años 30, junto con la máquina de Turing, se propusieron
distintos modelos computacionales que formalizaban el concepto de
<em>algoritmo</em>. Uno de estos modelos fue el denominado
<a href="https://en.wikipedia.org/wiki/Lambda_calculus"><em>Cálculo lambda</em></a>
propuesto por Alonzo Church en los años 30 y basado en la evaluación
de expresiones matemáticas. En este formalismo se expresan los
algoritmos mediante funciones matemáticas en las que puede ser usada
la recursión. Una función matemática recibe parámetros de entrada y
devuelve un valor. La evaluación de la función se realiza evaluando
sus expresiones matemáticas mediante la sustitución de los parámetros
formales por los valores reales que se utilizan en la invocación.</p>
<p>Turing demostró que este modelo matemático era equivalente al su
máquina, demostrando que es posible construir una maquina equivalente
a cualquier función lambda existente, una máquina que devuelva
exactamente los mismos resultados que la función lambda. El hecho de
que ambos modelos computacionales sean equivalentes significa que
cualquier cualquier algoritmo que podamos definir con una máquina de
Turing, puede ser definido también con una función del cálculo
lambda. Y viceversa: cualquier función definida con el cálculo lambda
puede ser implementada por alguna máquina de Turing.</p>
<p>El cálculo lambda es un formalismo matemático, basado en operaciones
abstractas. Dos décadas después, cuando los primeros computadores
electrónicos estaban empezando a utilizarse en grandes empresas y en
universidades, este formalismo dio origen a algo mucho más tangible y
práctico: un lenguaje de alto nivel, mucho más expresivo que el
ensamblador, con el que expresar operaciones y funciones <strong>que pueden
ser definidas y evaluadas en el computador</strong>.</p>
<h4 id="112-historia-y-caracteristicas-del-lisp">1.1.2 Historia y características del Lisp<a class="headerlink" href="#112-historia-y-caracteristicas-del-lisp" title="Permanent link">&para;</a></h4>
<ul>
<li><a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a> es
  el primer lenguaje de programación de alto nivel basado en el
  paradigma funcional.</li>
<li>Creado en 1958 por John McCarthy.</li>
<li>Lisp fue en su época un lenguaje revolucionario que introdujo nuevos
  conceptos de programación no existentes entonces: funciones como
  objetos primitivos, funciones de orden superior, polimorfismo,
  listas, recursión, símbolos, homogeneidad de datos y programas,
  bucle REPL (<em>Read-Eval-Print Loop</em>)</li>
<li>La herencia del Lisp llega a lenguajes derivados de él (Scheme,
  Golden Common Lisp) y a nuevos lenguajes de paradigmas no
  estrictamente funcionales, como C#, Python, Ruby, Objective-C o
  Scala.</li>
</ul>
<p>Lisp fue el primer lenguaje de programación interpretado, con muchas
características dinámicas que se ejecutan en tiempo de ejecución
(<em>run-time</em>). Entre estas características podemos destacar la gestión
de la memoria (creación y destrucción <strong>automática</strong> de memoria reservada
para datos), la detección de excepciones y errores en tiempo de
ejecución o la creación en tiempo de ejecución de funciones anónimas
(expresiones <em>lambda</em>). Todas estas características se ejecutan
mediante un <em>sistema de tiempo de ejecución</em> (<em>rutime system</em>)
presente en la ejecución de los programas. A partir del Lisp
muchos otros lenguajes han usado estas características de
interpretación o de sistemas de tiempo de ejecución. Por ejemplo,
lenguajes como BASIC, Python, Ruby o JavaScript son lenguajes
interpretados. Y lenguajes como Java o C# tienen una avanzada
plataforma de tiempo de ejecución con soporte para la gestión de la
memoria dinámica (<em>recolección de basura</em>,
<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)"><em>garbage collection</em></a>)
o la
<a href="https://en.wikipedia.org/wiki/Just-in-time_compilation">compilación <em>just in time</em></a>.</p>
<p>Lisp no es un lenguaje exclusivamente funcional. Lisp se diseñó con el
objetivo de ser un lenguaje de alto nivel capaz de resolver problemas
prácticos de Inteligencia Artificial, no con la idea de ser un
lenguaje formal basado un único modelo de computación. Por ello en
Lisp (y en Scheme) existen primitivas que se salen del paradigma
funcional puro y permiten programar de formar imperativa (no
declarativa), usando mutación de estado y pasos de ejecución. </p>
<p>Sin embargo, durante la primera parte de la asignatura en la que
estudiaremos la programación funcional, no utilizaremos las
instrucciones imperativas de Scheme sino que escribiremos código
exclusivamente funcional.</p>
<h4 id="113-lenguajes-de-programacion-funcional">1.1.3 Lenguajes de programación funcional<a class="headerlink" href="#113-lenguajes-de-programacion-funcional" title="Permanent link">&para;</a></h4>
<p>En los años 60 la programación funcional definida por el Lisp fue
dominante en departamentos de investigación en Inteligencia Artificial
(MIT por ejemplo). En los años 70, 80 y 90 se fue relegando cada vez
más a los nichos académicos y de investigación; en la empresa se
impusieron los lenguajes imperativos y orientados a objetos.</p>
<p>En la primera década del 2000 han aparecido lenguajes que evolucionan
de Lisp y que resaltan sus aspectos funcionales, aunque actualizando
su sintaxis. Destacamos entre ellos:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Clojure">Clojure</a></li>
<li><a href="https://en.wikipedia.org/wiki/Erlang_(programming_language)">Erlang</a></li>
</ul>
<p>También hay una tendencia desde mediados de la década de 2000 de
incluir aspectos funcionales como las <em>expresiones lambda</em> o las
funciones de orden superior en lenguajes imperativos orientados a
objetos, dando lugar a lenguajes <em>multi-paradigma</em>:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Ruby_(programming_language)">Ruby</a></li>
<li><a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a></li>
<li><a href="https://en.wikipedia.org/wiki/Groovy_(programming_language)">Groovy</a></li>
<li><a href="https://en.wikipedia.org/wiki/Scala_(programming_language)">Scala</a></li>
<li><a href="https://en.wikipedia.org/wiki/Swift_(programming_language)">Swift</a></li>
</ul>
<p>Por último, en la década del 2010 también se ha hecho popular un
lenguaje <strong>exclusivamente funcional</strong> como
<a href="https://en.wikipedia.org/wiki/Haskell_(programming_language)">Haskell</a>. Este
lenguaje, a diferencia de Scheme y de otros lenguajes multi-paradigma,
no tienen ningún elemento imperativo y consigue que todas sus
expresiones sean puramente funcionales.</p>
<h4 id="114-aplicaciones-practicas-de-la-programacion-funcional">1.1.4. Aplicaciones prácticas de la programación funcional<a class="headerlink" href="#114-aplicaciones-practicas-de-la-programacion-funcional" title="Permanent link">&para;</a></h4>
<p>En la actualidad el paradigma funcional es un <strong>paradigma de moda</strong>,
como se puede comprobar observando la cantidad de artículos, charlas y
blogs en los que se habla de él, así como la cantidad de lenguajes que
están aplicando sus conceptos. Por ejemplo, solo como muestra,
mostramos a continuación algunos enlaces a charlas y artículos
interesantes publicados recientemente sobre programación funcional:</p>
<ul>
<li>Lupo Montero - <a href="https://medium.com/laboratoria-how-to/introducción-a-la-programación-funcional-en-javascript-parte-1-e0b1d0b2142e">Introducción a la programación funcional en
  JavaScript</a> (Blog)</li>
<li>Andrés Marzal - <a href="https://www.youtube.com/watch?v=YU2i3L-euB0">Por qué deberías aprender programación funcional ya
  mismo</a> (Charla en YouTube)</li>
<li>Mary Rose Cook - <a href="https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming">A practical introduction to functional
programming</a> (Blog)</li>
<li>Ben Christensen - <a href="https://www.infoq.com/presentations/Netflix-API-rxjava-hystrix">Functional Reactive Programming in the Netflix
  API</a>
  (Charla en InfoQ)</li>
</ul>
<p>El auge reciente de estos lenguajes y del paradigma funcional se debe
a varios factores, entre ellos que es un paradigma que facilita:</p>
<ul>
<li>la programación de sistemas concurrentes, con múltiples hilos de
  ejecución o con múltiples computadores ejecutando procesos
  conectados concurrentes.</li>
<li>la definición y composición de múltiples operaciones sobre <em>streams</em>
  de forma muy concisa y compacta, aplicable a la programación de
  sistemas distribuidos en Internet.</li>
<li>la programación interactiva y evolutiva.</li>
</ul>
<h5 id="programacion-de-sistemas-concurrentes">Programación de sistemas concurrentes<a class="headerlink" href="#programacion-de-sistemas-concurrentes" title="Permanent link">&para;</a></h5>
<p>Veremos más adelante que una de las características principales de la
programación funcional es que no se usa la <em>mutación</em> (no se modifican
los valores asignados a variables ni parámetros). Esta propiedad lo
hace un paradigma excelente para implementar programas concurrentes,
en los que existen múltiples hilos de ejecución. La programación de
sistemas concurrentes es muy complicada con el paradigma imperativo
tradicional, en el que la modificación del estado de una variable
compartida por más de un hilo puede provocar <em>condiciones de carrera</em>
y errores difícilmente localizables y reproducibles.</p>
<p>Como dice <a href="https://twitter.com/BartoszMilewski">Bartosz Milewski</a>,
investigador y teórico de ciencia de computación, en su
<a href="https://www.quora.com/Why-do-software-engineers-like-functional-programming/answer/Bartosz-Milewski">respuesta en Quora</a>
a la pregunta <em>¿por qué a los ingenieros de software les gusta la
programación funcional?</em>:</p>
<blockquote>
<p>Porque es la única forma práctica de escribir programas
concurrentes. Intentar escribir programas concurrentes en lenguajes
imperativos, no sólo es difícil, sino que lleva a <em>bugs</em> que son muy
difíciles de descubrir, reproducir y arreglar. En los lenguajes
imperativos y, en particular, en los lenguajes orientados a objetos
se ocultan las mutaciones y se comparten datos sin darse cuenta, por
lo que son extremadamente propensos a los errores de concurrencia
producidos por las condiciones de carrera.</p>
</blockquote>
<h5 id="definicion-y-composicion-de-operaciones-sobre-streams">Definición y composición de operaciones sobre streams<a class="headerlink" href="#definicion-y-composicion-de-operaciones-sobre-streams" title="Permanent link">&para;</a></h5>
<p>El paradigma funcional ha originado un estilo de programación sobre
<em>streams</em> de datos, en el que se concatenan operaciones como <code>filter</code>
o <code>map</code> para definir de forma sencilla procesos y transformaciones
asíncronas aplicables a los elementos del <em>stream</em>. Este estilo de
programación ha hecho posible nuevas ideas de programación, como la
programación <em>reactiva</em>, basada en eventos, o los <em>futuros</em> o
<em>promesas</em> muy utilizados en lenguajes muy populares como JavaScript
para realizar peticiones asíncronas a servicios web.</p>
<p>Por ejemplo, en el artículo
<a href="http://zeroturnaround.com/rebellabs/exploring-the-virtues-of-microservices-with-play-and-akka/">Exploring the virtues of microservices with Play and Akka</a>
se explica con detalle las ventajas del uso de lenguajes y primitivas
para trabajar con sistemas asíncronos basados en eventos en servicios
como Tumblr o Netflix.</p>
<p>Otro ejemplo es el
<a href="http://highscalability.com/blog/2012/2/13/tumblr-architecture-15-billion-page-views-a-month-and-harder.html">uso de Scala en Tumblr</a>
con el que se consigue crear código que no tiene estado compartido y
que es fácilmente paralelizable entre los más de 800 servidores
necesarios para atender picos de más de 40.000 peticiones por segundo:</p>
<blockquote>
<p>"Scala promueve que no haya estado compartido. El estado mutable se
evita usando sentencias en Scala. No se usan máquinas de estado de
larga duración. El estado se saca de la base de datos, se usa, y se
escribe de nuevo en la base de datos. La ventaja principal es que
los desarrolladores no tienen que preocuparse sobre hilos o
bloqueos.</p>
</blockquote>
<h5 id="programacion-evolutiva">Programación evolutiva<a class="headerlink" href="#programacion-evolutiva" title="Permanent link">&para;</a></h5>
<p>En la metodología de programación denominada <em>programación evolutiva</em>
o <em>iterativa</em> los programas complejos se construyen a base de ir
definiendo y probando elementos computacionales cada vez más
complicados. Los lenguajes de programación funcional encajan
perfectamente en esta forma de construir programas.</p>
<p>Como Abelson y Sussman comentan en el SICP:</p>
<blockquote>
<p>En general, los objetos computacionales pueden tener estructuras muy
complejas, y sería extremadamente inconveniente tener que recordar y
repetir sus detalles cada vez que queremos usarlas. En lugar de
ello, se construyen programas complejos componiendo, paso a paso,
objetos computacionales de creciente complejidad.</p>
<p>El intérprete hace esta construcción paso-a-paso de los programas
particularmente conveniente porque las asociaciones nombre-objeto se
pueden crear de forma incremental en interacciones sucesivas. Esta
característica favorece el desarrollo y prueba incremental de
programas, y es en gran medida responsable del hecho de que un
programa Lisp consiste normalmente de un gran número de
procedimientos relativamente simples.</p>
</blockquote>
<p>No hay que confundir una metodología de programación con un paradigma
de programación. Una metodología de programación proporciona
sugerencias sobre cómo debemos diseñar, desarrollar y mantener una
aplicación que va a ser usada por usuarios finales. La programación
funcional se puede usar con múltiples metodologías de
programación, debido a que los programas resultantes son muy claros,
expresivos y fáciles de probar.</p>
<h3 id="12-programacion-declarativa-vs-imperativa"><a name="1-2"></a> 1.2. Programación declarativa vs. imperativa<a class="headerlink" href="#12-programacion-declarativa-vs-imperativa" title="Permanent link">&para;</a></h3>
<p>Hemos dicho que la programación funcional es un estilo de programación
declarativa, frente a la programación tradicional de los lenguajes
denominados imperativos. Vamos a explicar esto un poco más.</p>
<h4 id="121-programacion-declarativa">1.2.1 Programación declarativa<a class="headerlink" href="#121-programacion-declarativa" title="Permanent link">&para;</a></h4>
<p>Empecemos con lo que conocemos todos: un <strong>programa imperativo</strong>. Se trata
de un conjunto de instrucciones que se ejecutan una tras otra (pasos
de ejecución) de forma secuencial. En la ejecución de estas
instrucciones se van cambiando los valores de las variables y,
dependiendo de estos valores, se modifica el flujo de control de la
ejecución del programa. </p>
<p>Para entender el funcionamiento de un programa imperativo debemos
imaginar toda la evolución del programa, los pasos que se ejecutan y
cuál es el flujo de control en función de los cambios de los valores
en las variables.</p>
<p>En la <strong>programación declarativa</strong>, sin embargo, utilizamos un
paradigma totalmente distinto. Hablamos de <em>programación declarativa</em>
para referirnos a lenguajes de programación (o sentencias de código)
en los que se <em>declaran</em> los valores, objetivos o características de
los elementos del programa y en cuya ejecución no existe mutación
(modificación de valores de variables) ni secuencias de pasos de
ejecución.</p>
<p>De esta forma, la ejecución de un programa declarativo tiene que ver
más con algún modelo formal o matemático que con un programa
tradicional imperativo.  Define un conjunto de reglas y definiciones
<em>de estilo matemático</em>. </p>
<p>Un ejemplo claro de programación declarativa es una <strong>hoja de
cálculo</strong>. Las celdas contiene valores o expresiones matemáticas que se
actualizan automáticamente cuando cambiamos los valores de entrada. La
relación entre valores y resultados es totalmente matemática y para su
cálculo no tenemos que tener en cuenta pasos de ejecución. Evidente,
por debajo de la hoja de cálculo existe un programa que realiza el
su cálculo de la hoja, pero cuando estamos usándola no nos
preocupa esa implementación. Podemos no preocuparnos de ella y usar
únicamente el modelo matemático definido en la hoja.</p>
<p>En la programación funcional se cumplen estas características, porque
se definen funciones en las que se realizan unas operaciones sobre
unos parámetros de entrada y se devuelve un valor, sin modificar ningún
estado del programa ni utilizar pasos de ejecución definidos como
tales.</p>
<p>El siguiente ejemplo es una <strong>declaración</strong> en Scheme de una función
que toma como entrada un número y devuelve su cuadrado:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">cuadrado</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>La llamada a la función con un parámetro concreto devuelve el
resultado de evaluar su definición. Debemos pensar que esta evaluación
se hace de forma instantánea, sin realizar pasos de ejecución ni
mutación de valores en variables auxiliares.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">cuadrado</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">; devuelve 16</span>
</pre></div>
</td></tr></table>

<p>La programación declarativa no es exclusiva de los lenguajes
funcionales. Existen muchos lenguajes no funcionales con
características declarativas. Por ejemplo Prolog, en el que un
programa se define como un conjunto de reglas lógicas y su ejecución
realiza una deducción lógica matemática que devuelve un resultado. En
dicha ejecución no son relevantes los pasos internos que realiza el
sistema sino las relaciones lógicas entre los datos y los resultados
finales.</p>
<h4 id="122-programacion-imperativa">1.2.2 Programación imperativa<a class="headerlink" href="#122-programacion-imperativa" title="Permanent link">&para;</a></h4>
<p>Repasemos un algunas características propias de la programación
imperativa <strong>que no existen en la programación funcional</strong>. Son
características a las que estamos muy habituados porque son propias de
los lenguajes más populares y con los que hemos aprendido a
programar (C, C++, Java, python, etc.)</p>
<ul>
<li>Pasos de ejecución y mutación</li>
<li>Efectos laterales</li>
<li>Estado local mutable en las funciones</li>
</ul>
<p>Veremos que, aunque parece imposible, es posible programar sin
utilizar estas características. Lo demuestran lenguajes lenguajes de
programación funcional como Haskell, Clojure o el propio Scheme.</p>
<h5 id="pasos-de-ejecucion-y-mutacion">Pasos de ejecución y mutación<a class="headerlink" href="#pasos-de-ejecucion-y-mutacion" title="Permanent link">&para;</a></h5>
<p>El estilo de programación imperativa se basa en pasos de ejecución que
modifican el estado de variables:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</pre></div>
</td></tr></table>

<p>La expresión <code>x = x + 1</code> es una expresión de
<a href="https://en.wikipedia.org/w/index.php?title=Assignment_(computer_science)&amp;redirect=no">asignación</a>
que modifica el valor anterior de una variable por un nuevo valor. El
<em>estado</em> de las variables (su valor) cambia con la ejecución de los
pasos del programa.</p>
<p>A esta asignación que modifica un valor ya existente se le denomina
<em>asignación destructiva</em> o <em>mutación</em>.</p>
<p>En programación imperativa también se puede modificar (mutar) el valor
de componentes de estructuras de datos, como posiciones de un array,
de una lista o de un diccionario.</p>
<h5 id="mutacion-y-efectos-laterales">Mutación y efectos laterales<a class="headerlink" href="#mutacion-y-efectos-laterales" title="Permanent link">&para;</a></h5>
<p>En programación imperativa es habitual también trabajar con referencias
y hacer que más de un identificador referencie el mismo valor. Esto
produce la posibilidad de que la modificación (mutación) del valor a
través de uno de los identificadores produzca un <strong>efecto lateral</strong>
(<em>side effect</em> en inglés) en el que el valor de un identificador
cambia sin ejecutar ninguna expresión en la que se utilice
explícitamente el propio identificador.</p>
<p>Por ejemplo, en la mayoría de lenguajes orientados a objetos los
identificadores guardan referencias a objetos. De forma que si
asignamos un objeto a más de un identificador, todos los
identificadores están accediendo al mismo objeto. Si mutamos algún valor
del objeto a través de un identificador provocamos un efecto lateral
en los otros identificadores.</p>
<p>Por ejemplo, lo siguiente es un ejemplo de una <strong>mutación</strong> en
programación imperativa, en la que se modifican los atributos de un
objeto en Java:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Point2D</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="o">(</span><span class="mf">3.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">);</span> <span class="c1">// creamos un punto 2D con coordX=3.0 y coordY=2.0</span>
<span class="n">p1</span><span class="o">.</span><span class="na">getCoordX</span><span class="o">();</span> <span class="c1">// la coord x de p2 es 3.0</span>
<span class="n">p1</span><span class="o">.</span><span class="na">setCoordX</span><span class="o">(</span><span class="mf">10.0</span><span class="o">);</span>
<span class="n">p1</span><span class="o">.</span><span class="na">getCoordX</span><span class="o">();</span> <span class="c1">// la coord x de p1 es 10.0</span>
</pre></div>
</td></tr></table>

<p>Si el objeto está asignado a más de una variable tendremos el <strong>efecto
lateral</strong>
(<em><a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">side effect</a></em>)
en el que el dato guardado en una variable cambia después de una
sentencia en la que no se ha usado esa variable:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Point2D</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point2D</span><span class="o">(</span><span class="mf">3.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">);</span> <span class="c1">// la coord x de p1 es 3.0</span>
<span class="n">p1</span><span class="o">.</span><span class="na">getCoordX</span><span class="o">();</span> <span class="c1">// la coord x de p1 es 3.0</span>
<span class="n">Point2D</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="o">;</span>
<span class="n">p2</span><span class="o">.</span><span class="na">setCoordX</span><span class="o">(</span><span class="mf">10.0</span><span class="o">);</span>
<span class="n">p1</span><span class="o">.</span><span class="na">getCoordX</span><span class="o">();</span> <span class="c1">// la coord x de p1 es 10.0, sin que ninguna sentencia haya modificado directamente p1</span>
</pre></div>
</td></tr></table>

<p>En programación funcional, por contra, <strong>las definiciones son
inmutables</strong>, una vez asignado un valor a un identificador no se puede
modificar éste. En programación funcional se entienden las variables
como variables matemáticas, no como referencias a una posiciones de
memoria que puede ser modificada. Los valores son inmutables y no
existen efectos laterales.</p>
<p>Por ejemplo, la forma especial <code>define</code> en Scheme crea un nuevo
identificador y le da el valor definido de forma permanente. Si
escribimos el siguiente código en un programa en Scheme R6RS:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="o">#</span><span class="nv">lang</span> <span class="nv">r6rs</span>
<span class="p">(</span><span class="nf">import</span> <span class="p">(</span><span class="nf">rnrs</span> <span class="nv">base</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">12</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">200</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>tendremos el siguiente error:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>module: duplicate definition for identifier in: a
</pre></div>
</td></tr></table>

<p><em>Nota</em>: en el intérprete REPL del DrRacket sí que podemos definir más
 de una vez la misma función o identificador. Se ha diseñado así para
 facilitar el uso del intérprete para la prueba de expresiones en
 Scheme.</p>
<p>En los lenguajes de programación es habitual mezclar sentencias
imperativas y sentencias declarativas. Por ejemplo, en el siguiente
código Java las líneas 1 y 3 las podríamos considerar declarativas y
las 2 y 4 imperativas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>1. int x = 1;
2. x = x+1;
3. int y = x+1;
4. y = x;
</pre></div>
</td></tr></table>

<h5 id="estado-local">Estado local<a class="headerlink" href="#estado-local" title="Permanent link">&para;</a></h5>
<p>Otra característica de la programación imperativa es lo que se
denomina <strong>estado local mutable</strong> en funciones, procedimientos o
métodos. Se trata la posibilidad de que una invocación a un método o
una función modifique un cierto estado y de forma que la siguiente
invocación devuelva un valor distinto. Es una característica básica de
la programación orientada a objetos, donde los objetos guardan valores
que se modifican con la invocaciones a sus métodos.</p>
<p>Por ejemplo, en Java, podemos definir un contador que incrementa su
valor: </p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Contador</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">c</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Contador</span><span class="o">(</span><span class="kt">int</span> <span class="n">valorInicial</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">valorInicial</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">valor</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">c</span><span class="o">++;</span>
        <span class="k">return</span> <span class="n">c</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>

<p>Cada llamada al método <code>valor()</code> devolverá un valor distinto:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Contador</span> <span class="n">cont</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Contador</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
<span class="n">cont</span><span class="o">.</span><span class="na">valor</span><span class="o">();</span> <span class="c1">// 11</span>
<span class="n">cont</span><span class="o">.</span><span class="na">valor</span><span class="o">();</span> <span class="c1">// 12</span>
<span class="n">cont</span><span class="o">.</span><span class="na">valor</span><span class="o">();</span> <span class="c1">// 13</span>
</pre></div>
</td></tr></table>

<p>También se pueden definir funciones con estado local mutable en C:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">function</span> <span class="nf">contador</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">c</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>Cada llamada a la función <code>contador()</code> devolverá un valor distinto:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">contador</span><span class="p">()</span> <span class="p">;;</span> <span class="mi">1</span>
<span class="nf">contador</span><span class="p">()</span> <span class="p">;;</span> <span class="mi">2</span>
<span class="nf">contador</span><span class="p">()</span> <span class="p">;;</span> <span class="mi">3</span>
</pre></div>
</td></tr></table>

<p>Por el contrario, los lenguajes funcionales tienen la propiedad de
<strong>transparencia referencial</strong>: es posible sustituir cualquier
aparición de una expresión por su resultado sin que cambia el
resultado final del programa. Dicho de otra forma, en programación
funcional, <strong>una función siempre devuelve el mismo valor cuando se le
llama con los mismos parámetros</strong>. Las funciones no modifican ningún
estado, no acceden a ninguna variable ni objeto global y modifican su
valor.</p>
<h5 id="resumen">Resumen<a class="headerlink" href="#resumen" title="Permanent link">&para;</a></h5>
<p>Un resumen de las características fundamentales de la programación
declarativa frente a la programación imperativa. En los siguientes
apartados explicaremos más estas características.</p>
<p><strong>Características de la programación declarativa</strong></p>
<ul>
<li>Variable = nombre dado a un valor (declaración)</li>
<li>No existe asignación ni cambio de estado</li>
<li>No existe mutación, se cumple la <em>transferencia referencial</em>: dentro
  de un mismo ámbito todas las ocurrencias de una variable y las
  llamadas a funciones devuelven el mismo valor</li>
</ul>
<p><strong>Características de la programación imperativa</strong></p>
<ul>
<li>Variable = nombre de una zona de memoria</li>
<li>Asignación</li>
<li>Referencias</li>
<li>Pasos de ejecución</li>
</ul>
<h3 id="13-evaluacion-de-expresiones-y-definicion-de-funciones"><a name="1-3"></a> 1.3 Evaluación de expresiones y definición de funciones<a class="headerlink" href="#13-evaluacion-de-expresiones-y-definicion-de-funciones" title="Permanent link">&para;</a></h3>
<p>En la asignatura usaremos Scheme como primer lenguaje en el que
exploraremos la programación funcional.</p>
<p>En el seminario de Scheme que se imparte en prácticas se estudiará en
más profundidad los conceptos más importantes del lenguaje: tipos de
datos, operadores, estructuras de control, intérprete, etc.</p>
<h4 id="131-evaluacion-de-expresiones">1.3.1 Evaluación de expresiones<a class="headerlink" href="#131-evaluacion-de-expresiones" title="Permanent link">&para;</a></h4>
<p>Empezamos este apartado viendo cómo se definen y evalúan expresiones
Scheme. Y después veremos cómo construir nuevas funciones.</p>
<p>Scheme es un lenguaje que viene del Lisp. Una de sus características
principales es que las expresiones se construyen utilizando
paréntesis.</p>
<p>Ejemplos de expresiones en Scheme, junto con el resultado de su
ejecución:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="mi">2</span> <span class="c1">; ⇒ 2</span>
<span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; ⇒ 5</span>
<span class="p">(</span><span class="nf">+</span><span class="p">)</span> <span class="c1">; ⇒ 0</span>
<span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span> <span class="c1">; ⇒ 17</span>
<span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="mi">3</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">; ⇒ 8</span>
</pre></div>
</td></tr></table>

<p>En programación funcional en lugar de decir "ejecutar una expresión"
se dice "<strong>evaluar una expresión</strong>", para reforzar la idea de que se
tratan de expresiones matemáticas que <strong>siempre devuelven uno y sólo un
resultado</strong>.</p>
<p>Las expresiones se definen con una notación prefija: el primer
elemento después del paréntesis de apertura es el <strong>operador</strong> de la
expresión y el resto de elementos (hasta el paréntesis de cierre) son
sus operandos.</p>
<ul>
<li>
<p>Por ejemplo, en la expresión <code>(+ 2 4 5 6)</code> el operador es el símbolo
<code>+</code> que representa función <em>suma</em> y los operandos son los números 2,
4, 5 y 6.</p>
</li>
<li>
<p>Puede haber expresiones que no tengan operandos, como el ejemplo
<code>(+)</code>, cuya evaluación devuelve 0.</p>
</li>
</ul>
<p>Una idea fundamental de Lisp y Scheme es que los paréntesis se evalúan
de dentro a fuera. Por ejemplo, la expresión </p>
<p><code>(+ (* 2 3) (- 3 (/ 12 3)))</code></p>
<p>que devuelve 5, se evalúa así:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="mi">3</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">12</span> <span class="mi">3</span><span class="p">)))</span> <span class="err">⇒</span>
<span class="p">(</span><span class="nb">+ </span><span class="mi">6</span> <span class="p">(</span><span class="nb">- </span><span class="mi">3</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">12</span> <span class="mi">3</span><span class="p">)))</span> <span class="err">⇒</span>
<span class="p">(</span><span class="nb">+ </span><span class="mi">6</span> <span class="p">(</span><span class="nb">- </span><span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="err">⇒</span>
<span class="p">(</span><span class="nb">+ </span><span class="mi">6</span> <span class="mi">-1</span><span class="p">)</span> <span class="err">⇒</span>
<span class="mi">5</span>
</pre></div>
</td></tr></table>

<p>La evaluación de cada expresión devuelve un valor que se utiliza para
continuar calculando la expresión exterior. En el caso anterior</p>
<ul>
<li>primero se evalúa la expresión <code>(* 2 3)</code> que devuelve 6,</li>
<li>después se evalúa <code>(/ 12 3)</code> que devuelve 4,</li>
<li>después se evalúa <code>(- 3 4)</code> que devuelve -1</li>
<li>y por último se evalúa <code>(+ 6 -1)</code> que devuelve 5</li>
</ul>
<p>Cuando se evalúa una expresión en el intérprete de Scheme el 
resultado aparece en la siguiente línea. </p>
<h4 id="132-definicion-de-funciones">1.3.2 Definición de funciones<a class="headerlink" href="#132-definicion-de-funciones" title="Permanent link">&para;</a></h4>
<p>En programación funcional las funciones son similares a las funciones
matemáticas: reciben parámetros y devuelven siempre un único resultado
de operar con esos parámetros.</p>
<p>Por ejemplo, podemos definir la función <code>(cuadrado x)</code> que devuelve el
cuadrado de un número que pasamos como parámetro:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">cuadrado</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>El cuerpo de la función es una expresión que se evaluará con el valor
que se pase como parámetro. En el caso anterior la expresión es <code>(* x
x)</code> y multiplicará el parámetro por si mismo.</p>
<p>Hay que hacer notar que en Scheme no existe la palabra clave <code>return</code>,
sino que las funciones siempre se definen con una única expresión cuya
evaluación es el resultado que se devuelve.</p>
<p>Una vez definida la función <code>cuadrado</code> podemos usarla de la misma
forma que las funciones primitivas de Scheme:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">cuadrado</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">; ⇒ 100</span>
<span class="p">(</span><span class="nf">cuadrado</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">10</span> <span class="p">(</span><span class="nf">cuadrado</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="mi">4</span><span class="p">))))</span> <span class="c1">; ⇒ 2116</span>
</pre></div>
</td></tr></table>

<p>La evaluación de la última expresión se hace de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">cuadrado</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">10</span> <span class="p">(</span><span class="nf">cuadrado</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="mi">4</span><span class="p">))))</span> <span class="err">⇒</span>
<span class="p">(</span><span class="nf">cuadrado</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">10</span> <span class="p">(</span><span class="nf">cuadrado</span> <span class="mi">6</span><span class="p">)))</span> <span class="err">⇒</span>
<span class="p">(</span><span class="nf">cuadrado</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">10</span> <span class="mi">36</span><span class="p">))</span> <span class="err">⇒</span>
<span class="p">(</span><span class="nf">cuadrado</span> <span class="mi">46</span><span class="p">)</span> <span class="err">⇒</span>
<span class="mi">2116</span>
</pre></div>
</td></tr></table>

<p>Las funciones definidas se pueden utilizar a su vez para construir
otras funciones</p>
<p>Lo habitual en programación funcional es definir funciones muy
pequeñas e ir construyendo funciones cada vez de mayor nivel usando
las anteriores.</p>
<h5 id="ejemplo-tiempo-de-impacto">Ejemplo: tiempo de impacto<a class="headerlink" href="#ejemplo-tiempo-de-impacto" title="Permanent link">&para;</a></h5>
<p>Por ejemplo, supongamos que estamos programando un juego de guerra de
barcos y submarinos, en el que utilizamos las coordenadas del plano
para situar todos los elementos de nuestra flota.</p>
<p>Supongamos que necesitamos calcular el tiempo que tarda un torpedo en
llegar desde una posición <code>(x1, y1)</code> a otra <code>(x2, y2)</code>. Suponemos que
la velocidad del torpedo es otro parámetro <code>v</code>. </p>
<p>¿Cómo calcularíamos este tiempo de impacto?</p>
<p>La forma menos correcta de hacerlo es definir todo el cálculo en una
única expresión. Como en programación funcional las funciones deben
definirse con una única expresión deberíamos poner todo el cálculo en
forma de expresiones anidadas, unas dentro de otras. Eso crearía una
función que calcularía bien el resultado, pero que sería muy difícil
de leer y entender para un compañero (o para nosotros mismos, cuando
pasen unos meses):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">;</span>
<span class="c1">; Definición incorrecta: muy poco legible</span>
<span class="c1">;</span>
<span class="c1">; La función tiempo-impacto1 devuelve el tiempo que tarda</span>
<span class="c1">; en llegar un torpedo a la velocidad v desde la posición</span>
<span class="c1">; (x1, y1) a la posición (x2, y2)</span>
<span class="c1">;</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">tiempo-impacto</span> <span class="nv">x1</span> <span class="nv">y1</span> <span class="nv">x2</span> <span class="nv">y2</span> <span class="nv">v</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">sqrt </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">- </span><span class="nv">x2</span> <span class="nv">x1</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x2</span> <span class="nv">x1</span><span class="p">))</span>
               <span class="p">(</span><span class="nb">* </span><span class="p">(</span><span class="nb">- </span><span class="nv">y2</span> <span class="nv">y1</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">y2</span> <span class="nv">y1</span><span class="p">))))</span>
    <span class="nv">v</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>La función anterior haría bien el cálculo pero sería muy complicada de
modificar y de entender.</p>
<p>La forma más correcta de definir la función sería usando varias
funciones auxiliares. Fíjate que es muy importante también poner los
nombres correctos a cada función, para entender qué hace. Scheme es un
lenguaje débilmente tipado y no tenemos la ayuda de los tipos que nos
dan más contexto de qué es cada parámetro y qué devuelve la función.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">;</span>
<span class="c1">; Definición correcta, modular y legible</span>
<span class="c1">;</span>
<span class="c1">; La función &#39;tiempo-impacto&#39; devuelve el tiempo que tarda</span>
<span class="c1">; en llegar un torpedo a la velocidad v desde la posición</span>
<span class="c1">; (x1, y1) a la posición (x2, y2)</span>
<span class="c1">;</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">tiempo-impacto</span> <span class="nv">x1</span> <span class="nv">y1</span> <span class="nv">x2</span> <span class="nv">y2</span> <span class="nv">velocidad</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">tiempo</span> <span class="p">(</span><span class="nf">distancia</span> <span class="nv">x1</span> <span class="nv">y1</span> <span class="nv">x2</span> <span class="nv">y2</span><span class="p">)</span> <span class="nv">velocidad</span><span class="p">))</span>
<span class="c1">;</span>
<span class="c1">;</span>
<span class="c1">; La función &#39;tiempo&#39; devuelve el tiempo que </span>
<span class="c1">; tarde en recorrer un móvil una distancia d a un velocidad v</span>
<span class="c1">;</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">tiempo</span> <span class="nv">distancia</span> <span class="nv">velocidad</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">/ </span><span class="nv">distancia</span> <span class="nv">velocidad</span><span class="p">))</span>

<span class="c1">;</span>
<span class="c1">; La función &#39;distancia&#39; devuelve la distancia entre dos</span>
<span class="c1">; coordenadas (x1, y1) y (x2, y2)</span>
<span class="c1">;</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">distancia</span> <span class="nv">x1</span> <span class="nv">y1</span> <span class="nv">x2</span> <span class="nv">y2</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">sqrt </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">cuadrado</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x2</span> <span class="nv">x1</span><span class="p">))</span>
             <span class="p">(</span><span class="nf">cuadrado</span> <span class="p">(</span><span class="nb">- </span><span class="nv">y2</span> <span class="nv">y1</span><span class="p">)))))</span>

<span class="c1">;</span>
<span class="c1">; La función &#39;cuadrado&#39; devuelve el cuadrado de un número</span>
<span class="c1">;</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">cuadrado</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>En esta segunda versión definimos más funciones, pero cada una es
mucho más legible. Además las funciones como <code>cuadrado</code>, <code>distancia</code> o
<code>tiempo</code> las vamos a poder reutilizar para otros cálculos.</p>
<h4 id="133-funciones-puras">1.3.3 Funciones puras<a class="headerlink" href="#133-funciones-puras" title="Permanent link">&para;</a></h4>
<p>A diferencia de lo que hemos visto en programación imperativa, en
programación funcional no es posible definir funciones con estado
local. Las funciones que se definen son funciones matemáticas puras,
que cumplen las siguientes condiciones:</p>
<ul>
<li>No modifican los parámetros que se les pasa</li>
<li>Devuelven un único resultado</li>
<li>No tienen estado local ni el resultado depende de un estado exterior mutable</li>
</ul>
<p>Esta última propiedad es muy importante y quiere decir que la función
siempre devuelve el mismo valor cuando se le pasan los mismos
parámetros.</p>
<p>Las funciones puras son muy fáciles de entender porque no es necesario
tener en cuenta ningún contexto a la hora de describir su
funcionamiento. El valor devuelto únicamente depende de los parámetros
de entrada.</p>
<p>Por ejemplo, funciones matemáticas como suma, resta, cuadrado, sin,
cos, etc. cumplen esta propiedad.</p>
<h3 id="14-modelo-de-computacion-de-sustitucion"><a name="1-4"></a> 1.4. Modelo de computación de sustitución<a class="headerlink" href="#14-modelo-de-computacion-de-sustitucion" title="Permanent link">&para;</a></h3>
<p>Un modelo computacional es un formalismo (conjunto de reglas) que
definen el funcionamiento de un programa. En el caso de los lenguajes
funcionales basados en la evaluación de expresiones, el modelo
computacional define cuál será el resultado de evaluar una expresión.</p>
<p>El <strong>modelo de sustitución</strong> es un modelo muy sencillo que permite
definir la semántica de la evaluación de expresiones en lenguajes
funcionales como Scheme. Se basa en una versión simplificada de la
regla de reducción del cálculo lambda.</p>
<p>Es un modelo basado en la reescritura de unos términos por
otros. Aunque se trata de un modelo abstracto, sería posible escribir
un intérprete que, basándose en este modelo, evalúe expresiones
funcionales.</p>
<p>Supongamos un conjunto de definiciones en Scheme:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">doble</span> <span class="nv">x</span><span class="p">)</span> 
    <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">cuadrado</span> <span class="nv">y</span><span class="p">)</span> 
    <span class="p">(</span><span class="nb">* </span><span class="nv">y</span> <span class="nv">y</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">f</span> <span class="nv">z</span><span class="p">)</span> 
    <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">cuadrado</span> <span class="p">(</span><span class="nf">doble</span> <span class="nv">z</span><span class="p">))</span> <span class="mi">1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Supongamos que, una vez realizadas esas definiciones, se evalúa la
siguiente expresión:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>¿Cuál será su resultado? Si lo hacemos de forma intuitiva podemos
pensar que <code>37</code>. Si lo comprobamos en el intérprete de Scheme veremos
que devuelve 37. ¿Hemos seguido algunas reglas específicas? ¿Qué
reglas son las que sigue el intérprete? ¿Podríamos implementar
nosotros un intérprete similar? Sí, usando las reglas del modelo de
sustitución.</p>
<p>El modelo de sustitución define cuatro reglas sencillas para evaluar
una expresión. Llamemos a la expresión <em>e</em>. Las reglas son las
siguientes:</p>
<ol>
<li>Si <em>e</em> es un valor primitivo (por ejemplo, un número), devolvemos ese
   mismo valor.</li>
<li>Si <em>e</em> es un identificador, devolvemos su valor asociado con un
   <code>define</code> (se lanzará un error si no existe ese valor).</li>
<li>Si <em>e</em> es una expresión del tipo <em>(f arg1 ... argn)</em>, donde <em>f</em> es
   el nombre de una función primitiva (<code>+</code>, <code>-</code>, ...), evaluamos uno a
   uno los argumentos <em>arg1</em> ... <em>argn</em> (con estas mismas reglas) y
   evaluamos la función primitiva con los resultados.</li>
</ol>
<p>La regla 4 tiene dos variantes, dependiendo del orden de
evaluación que utilizamos.</p>
<p><strong>Orden aplicativo</strong></p>
<ol>
<li>Si <em>e</em> es una expresión del tipo <em>(f arg1 ... argn)</em>, donde <em>f</em> es
   el nombre de una función definida con un <code>define</code>, tenemos que
   evaluar primero los argumentos <em>arg1</em> ... <em>argn</em> y después
   <strong>sustituir <em>f</em> por su cuerpo</strong>, reemplazando cada parámetro formal
   de la función por el correspondiente argumento evaluado. Después
   evaluaremos la expresión resultante usando estas mismas reglas.</li>
</ol>
<p><strong>Orden normal</strong></p>
<ol>
<li>Si <em>e</em> es una expresión del tipo <em>(f arg1 ... argn)</em>, donde <em>f</em> es
   el nombre de una función definida con un <code>define</code>, tenemos que
   <strong>sustituir <em>f</em> por su cuerpo</strong>, reemplazando cada parámetro formal
   de la función por el correspondiente argumento sin evaluar. Después
   evaluar la expresión resultante usando estas mismas reglas.</li>
</ol>
<p>Ambas formas de evaluación darán el mismo resultado en programación
funcional. Scheme utiliza el orden aplicativo.</p>
<p>En el siguiente apartado veremos un ejemplo de ambos tipos de
evaluaciones. </p>
<h4 id="141-ejemplo">1.4.1 Ejemplo<a class="headerlink" href="#141-ejemplo" title="Permanent link">&para;</a></h4>
<p>En el orden aplicativo se realizan las evaluaciones antes de realizar
las sustituciones, lo que define una evaluación de <em>dentro a fuera</em> de
los paréntesis. Cuando se llega a una expresión primitiva se
evalúa.</p>
<p>En el orden normal se realizan todas las sustituciones hasta que se
tiene una larga expresión formada por expresiones primitivas; se
evalúa entonces.</p>
<p>Veamos cómo se evalúa el mismo ejemplo de ambas formas. Supongamos el
ejemplo anterior.</p>
<p>Definiciones:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">doble</span> <span class="nv">x</span><span class="p">)</span> 
    <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">cuadrado</span> <span class="nv">y</span><span class="p">)</span> 
    <span class="p">(</span><span class="nb">* </span><span class="nv">y</span> <span class="nv">y</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">f</span> <span class="nv">z</span><span class="p">)</span> 
    <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">cuadrado</span> <span class="p">(</span><span class="nf">doble</span> <span class="nv">z</span><span class="p">))</span> <span class="mi">1</span><span class="p">))</span>

<span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Expresión a evaluar:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Veamos el resultado de la evaluación usando el <strong>modelo de sustitución
aplicativo</strong>, aplicando paso a paso las reglas anteriores (en cada
línea pondremos entre paréntesis la regla que aplicamos):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>(f (+ a 1)) ⇒                ; Para evaluar f, evaluamos primero su argumento (+ a 1) (Regla 4)
                             ; y sustituimos a por 2 (Regla 2) 
(f (+ 2 1)) ⇒                ; Evaluamos (+ 2 1) (Reglas 2 y 3)
(f 3) ⇒                      ; (Regla 4)
(+ (cuadrado (doble 3)) 1) ⇒ ; Sustituimos (doble 3) (Regla 4)
(+ (cuadrado (+ 3 3)) 1) ⇒   ; Evaluamos (+ 3 3) (Reglas 2 y 3)
(+ (cuadrado 6) 1) ⇒         ; Sustitumos (cuadrado 6) (Regla 4)
(+ (* 6 6) 1) ⇒              ; Evaluamos (* 6 6) (Reglas 2 y 3)
(+ 36 1) ⇒                   ; Evaluamos (+ 36 1) (Reglas 2 y 3)
37
</pre></div>
</td></tr></table>

<p>Y veamos el resultado de usar el <strong>modelo de sustitución normal</strong>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>(f (+ a 1)) ⇒                      ; Sustituimos (f (+ a 1)) 
                                   ; por su definición, con z = (+ a 1) (Regla 4)
(+ (cuadrado (doble (+ a 1))) 1) ⇒ ; Sustituimos (cuadrado ...) (Regla 4)
(+ (* (doble (+ a 1))
      (doble (+ a 1))) 1)          ; Sustituimos (doble  ...) (Regla 4)
(+ (* (+ (+ a 1) (+ a 1))
      (+ (+ a 1) (+ a 1))) 1) ⇒    ; Evaluamos a (Regla 2)
(+ (* (+ (+ 2 1) (+ 2 1))
      (+ (+ 2 1) (+ 2 1))) 1) ⇒    ; Evaluamos (+ 2 1) (Regla 3)
(+ (* (+ 3 3)
      (+ 3 3)) 1) ⇒                ; Evaluamos (+ 3 3) (Regla 3)
(+ (* 6 6) 1) ⇒                    ; Evaluamos (* 6 6) (Regla 3)
(+ 36 1) ⇒                         ; Evaluamos (+ 36 1) (Regla 3)
37
</pre></div>
</td></tr></table>

<p>En programación funcional el resultado de evaluar una expresión es el
mismo independientemente del tipo de orden. Pero si estamos fuera del
paradigma funcional y las funciones tienen estado y cambian de valor
entre distintas invocaciones sí que importan si escogemos un orden.</p>
<p>Por ejemplo, supongamos una función <code>(random x)</code> que devuelve un
entero aleatorio entre 0 y <em>x</em>. Esta función no cumpliría el paradigma
funcional, porque devuelve un valor distinto con el mismo parámetro de
entrada.</p>
<p>Evaluamos las siguientes expresiones con orden aplicativo y normal,
para comprobar que el resultado es distinto</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">zero</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nf">zero</span> <span class="p">(</span><span class="nf">random</span> <span class="mi">10</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<h2 id="2-scheme-como-lenguaje-de-programacion-funcional"><a name="2"></a> 2. Scheme como lenguaje de programación funcional<a class="headerlink" href="#2-scheme-como-lenguaje-de-programacion-funcional" title="Permanent link">&para;</a></h2>
<p>Ya hemos visto cómo definir funciones y evaluar expresiones en
Scheme. Vamos continuar con ejemplos concretos de otras
características funcionales características funcionales de Scheme.</p>
<p>En concreto, veremos:</p>
<ul>
<li>Símbolos y primitiva <code>quote</code></li>
<li>Uso de listas</li>
<li>Definición de funciones recursivas en Scheme</li>
</ul>
<h3 id="21-funciones-y-formas-especiales"><a name=2-1></a>2.1 Funciones y formas especiales<a class="headerlink" href="#21-funciones-y-formas-especiales" title="Permanent link">&para;</a></h3>
<p>En el seminario de Scheme hemos visto un conjunto de primitivas que
podemos utilizar en Scheme.</p>
<p>Podemos clasificar las primitivas en <strong>funciones</strong> y <strong>formas
especiales</strong>. Las funciones se evalúan usando el modelo de sustitución
aplicativo ya visto:</p>
<ul>
<li>Primero se evalúan los argumentos y después se sustituye la llamada
  a la función por su cuerpo y se vuelve a evaluar la expresión
  resultante.</li>
<li>Las expresiones siempre se evalúan desde los paréntesis interiores a
  los exteriores.</li>
</ul>
<p>Las <em>formas especiales</em> son expresiones primitivas de Scheme que
tienen una forma de evaluarse propia, distinta de las funciones. </p>
<h3 id="22-formas-especiales-en-scheme-define-if-cond"><a name="2-2"></a>2.2. Formas especiales en Scheme: define, if, cond<a class="headerlink" href="#22-formas-especiales-en-scheme-define-if-cond" title="Permanent link">&para;</a></h3>
<p>Veamos la forma de evaluar las distintas formas especiales en
Scheme. En estas formas especiales no se aplica el modelo de
sustitución, al no ser invocaciones de funciones, sino que cada una se
evalúa de una forma diferente.</p>
<h4 id="221-forma-especial-define">2.2.1 Forma especial <code>define</code><a class="headerlink" href="#221-forma-especial-define" title="Permanent link">&para;</a></h4>
<p><strong>Sintaxis</strong></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">&lt;identificador&gt;</span> <span class="nv">&lt;expresi</span><span class="err">ó</span><span class="nv">n&gt;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p><strong>Evaluación</strong></p>
<ol>
<li>Evaluar <em>expresión</em></li>
<li>Asociar el valor resultante con el <em>identificador</em></li>
</ol>
<p><strong>Ejemplo</strong></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">base</span> <span class="mi">10</span><span class="p">)</span>   <span class="c1">; Asociamos a &#39;base&#39; el valor 10</span>
<span class="p">(</span><span class="k">define </span><span class="nv">altura</span> <span class="mi">12</span><span class="p">)</span> <span class="c1">; Asociamos a &#39;altura&#39; el valor 12</span>
<span class="p">(</span><span class="k">define </span><span class="nv">area</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">* </span><span class="nv">base</span> <span class="nv">altura</span><span class="p">)</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">; Asociamos a &#39;area&#39; el valor 60</span>
</pre></div>
</td></tr></table>

<h5 id="forma-especial-define-para-definir-funciones">Forma especial <code>define</code> para definir funciones<a class="headerlink" href="#forma-especial-define-para-definir-funciones" title="Permanent link">&para;</a></h5>
<p><strong>Sintaxis</strong></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>(define (&lt;nombre-funcion&gt; &lt;argumentos&gt;)
    &lt;cuerpo&gt;)
</pre></div>
</td></tr></table>

<p><strong>Evaluación</strong></p>
<p>La semana que viene veremos con más detalle la semántica, y
explicaremos la forma especial <code>lambda</code> que es la que realmente crea
la función. Hoy nos quedamos en la siguiente descripción de alto nivel
de la semántica:</p>
<ol>
<li>Crear la función con el <em>cuerpo</em></li>
<li>Dar a la función el nombre <em>nombre-función</em></li>
</ol>
<p><strong>Ejemplo</strong></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">factorial</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
        <span class="mi">1</span>
        <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="p">(</span><span class="nf">factorial</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)))))</span>
</pre></div>
</td></tr></table>

<h4 id="222-forma-especial-if">2.2.2. Forma especial <code>if</code><a class="headerlink" href="#222-forma-especial-if" title="Permanent link">&para;</a></h4>
<p><strong>Sintaxis</strong></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">if </span><span class="nv">&lt;condici</span><span class="err">ó</span><span class="nv">n&gt;</span> <span class="nv">&lt;expresi</span><span class="err">ó</span><span class="nv">n-true&gt;</span> <span class="nv">&lt;expresi</span><span class="err">ó</span><span class="nv">n-false&gt;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p><strong>Evaluación</strong></p>
<ol>
<li>Evaluar <em>condición</em></li>
<li>Si el resultado es <code>#t</code> evaluar la <em>expresión-true</em>, en otro
   caso, evaluar la <em>expresión-false</em></li>
</ol>
<p><strong>Ejemplo</strong></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="mi">10</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nb">substring </span><span class="s">&quot;Hola qué tal&quot;</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">12</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1">;; Evaluamos (&gt; 10 5). Como el resultado es #t, evaluamos </span>
<span class="c1">;; (substring &quot;Hola qué tal&quot; (+ 1 1) 4), que devuelve &quot;la&quot;</span>
</pre></div>
</td></tr></table>

<h4 id="223-forma-especial-cond">2.2.3. Forma especial <code>cond</code><a class="headerlink" href="#223-forma-especial-cond" title="Permanent link">&para;</a></h4>
<p><strong>Sintaxis</strong></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">cond</span><span class="err"> </span>
    <span class="p">(</span><span class="nf">&lt;exp-cond-1&gt;</span> <span class="nv">&lt;exp-consec-1&gt;</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">&lt;exp-cond-2&gt;</span> <span class="nv">&lt;exp-consec-2&gt;</span><span class="p">)</span>
    <span class="o">...</span>
    <span class="p">(</span><span class="k">else </span><span class="nv">&lt;exp-consec-else&gt;</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p><strong>Evaluación</strong></p>
<ol>
<li>Se evalúan de forma ordenada todas las expresiones hasta que una de
   ellas devuelva <code>#t</code></li>
<li>Si alguna expresión devuelve <code>#t</code>, se devuelve el valor del
   consecuente de esa expresión</li>
<li>Si ninguna expresión es cierta, se devuelve el valor resultante de
   evaluar el consecuente del <code>else</code></li>
</ol>
<p><strong>Ejemplo</strong></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">cond</span>
<span class="err">  </span> <span class="p">((</span><span class="nb">&gt; </span><span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="s">&quot;3 es mayor que 4&quot;</span><span class="p">)</span>
<span class="err">  </span> <span class="p">((</span><span class="nb">&lt; </span><span class="mi">2</span> <span class="mi">1</span><span class="p">)</span> <span class="s">&quot;2 es menor que 1&quot;</span><span class="p">)</span>
<span class="err">  </span> <span class="p">((</span><span class="nb">= </span><span class="mi">3</span> <span class="mi">1</span><span class="p">)</span> <span class="s">&quot;3 es igual que 1&quot;</span><span class="p">)</span>
<span class="err">  </span> <span class="p">((</span><span class="nb">&gt; </span><span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="s">&quot;3 es mayor que 2&quot;</span><span class="p">)</span>
<span class="err">  </span> <span class="p">(</span><span class="k">else </span><span class="s">&quot;ninguna condición es cierta&quot;</span><span class="p">))</span>

<span class="c1">;; Se evalúan una a una las expresiones (&gt; 3 4),</span>
<span class="c1">;; (&lt; 2 1), (= 3 1) y (&gt; 3 5). Como ninguna de ella</span>
<span class="c1">;; es cierta se devuelve la cadena &quot;ninguna condición es cierta&quot;.</span>
</pre></div>
</td></tr></table>

<h3 id="23-forma-especial-quote-y-simbolos"><a name="2-3"></a>2.3. Forma especial <code>quote</code> y símbolos<a class="headerlink" href="#23-forma-especial-quote-y-simbolos" title="Permanent link">&para;</a></h3>
<p><strong>Sintaxis</strong></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">quote </span><span class="nv">&lt;identificador&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="k">quote </span><span class="nv">&lt;expresion&gt;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p><strong>Evaluación</strong></p>
<ul>
<li>Se devuelve el identificador o la expresión <strong>sin evaluar</strong>. Si la
  expresión es compuesta (entre paréntesis), se devuelve una lista. La
  expresión puede ser cualquier expresión correcta de Scheme. </li>
<li>Se abrevia en con el carácter <code>'</code>.</li>
</ul>
<p><strong>Ejemplo</strong></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">quote </span><span class="nv">x</span><span class="p">)</span> <span class="c1">; el símbolo x</span>
<span class="ss">&#39;hola</span> <span class="c1">; el símbolo hola</span>
</pre></div>
</td></tr></table>

<p>A diferencia de los lenguajes imperativos, Scheme trata a los
<em>identificadores</em> (nombres que se les da a las variables) como datos
del lenguaje de tipo <strong>symbol</strong>. En el paradigma funcional a los
identificadores se les denomina <em>símbolos</em>.</p>
<p>Los símbolos son distintos de las cadenas. Una cadena es un tipo de
dato <strong>compuesto</strong> y se guardan en memoria todos y cada uno de los
caracteres que la forman. Sin embargo, los símbolos son tipos
atómicos, que se representan en memoria con un único valor determinado
por el <em>código hash</em> del identificador.</p>
<p>Ejemplos de funciones Scheme con símbolos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="mi">12</span><span class="p">)</span>
<span class="p">(</span><span class="nb">symbol? </span><span class="ss">&#39;x</span><span class="p">)</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="nb">symbol? </span><span class="nv">x</span><span class="p">)</span> <span class="c1">; ⇒ #f ¿Por qué?</span>
<span class="p">(</span><span class="nb">symbol? </span><span class="ss">&#39;hola-que&lt;&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="ss">&#39;hola-que&lt;&gt;</span><span class="p">)</span>
<span class="ss">&#39;ma</span><span class="err">ñ</span><span class="nv">ana</span>
<span class="ss">&#39;l</span><span class="err">á</span><span class="nv">piz</span> <span class="c1">; aunque sea posible, no vamos a usar acentos en los símbolos</span>
<span class="c1">; pero sí en los comentarios</span>
<span class="p">(</span><span class="nb">symbol? </span><span class="s">&quot;hola&quot;</span><span class="p">)</span> <span class="c1">; #f</span>
<span class="p">(</span><span class="nb">symbol? </span> <span class="no">#f</span><span class="p">)</span> <span class="c1">; #f</span>
<span class="p">(</span><span class="nb">symbol? </span><span class="p">(</span><span class="nb">car </span><span class="o">&#39;</span><span class="p">(</span><span class="nv">hola</span> <span class="nv">c</span><span class="err">ó</span><span class="nv">mo</span> <span class="nv">est</span><span class="err">á</span><span class="nv">s</span><span class="p">)))</span> <span class="c1">; #t</span>
<span class="p">(</span><span class="nb">equal? </span><span class="ss">&#39;hola</span> <span class="ss">&#39;hola</span><span class="p">)</span>
<span class="p">(</span><span class="nb">equal? </span><span class="ss">&#39;hola</span> <span class="s">&quot;hola&quot;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Un símbolo puede asociarse o ligarse (<em>bind</em>) a un valor (cualquier
dato <em>de primera clase</em>) con la forma especial <code>define</code>.</p>
<p>Cuando escribimos un símbolo en el prompt de Scheme el intérprete lo
evalúa y devuelve su valor:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">pi</span> <span class="mf">3.14159</span><span class="p">)</span>
<span class="nv">pi</span>
<span class="err">⇒</span><span class="mf">3.14159</span>
</pre></div>
</td></tr></table>

<p>Los nombres de las funciones (<code>equal?</code>, <code>sin</code>, <code>+</code>, ...) son también
símbolos y Scheme también los evalúa (en un par de semanas hablaremos
de las funciones como objetos primitivos en Scheme):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="nv">sin</span> <span class="c1">; ⇒ #&lt;procedure:sin&gt;</span>
<span class="nv">+</span> <span class="c1">; ⇒ #&lt;procedure:+&gt;</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">cuadrado</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span> 
<span class="nv">cuadrado</span> <span class="c1">; ⇒ #&lt;procedure:cuadrado&gt;</span>
</pre></div>
</td></tr></table>

<p>Los símbolos son tipos primitivos del lenguaje: pueden pasarse como
parámetros o ligarse a variables.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="ss">&#39;hola</span><span class="p">)</span>
<span class="nv">x</span> <span class="c1">; ⇒ hola</span>
</pre></div>
</td></tr></table>

<h3 id="24-listas"><a name="2-4"></a>2.4. Listas<a class="headerlink" href="#24-listas" title="Permanent link">&para;</a></h3>
<p>Otra de las características fundamentales del paradigma funcional es
la utilización de listas. Ya hemos visto en el seminario de Scheme las
funciones más importantes para trabajar con ellas. Vamos a repasarlas
de nuevo en este apartado, antes de ver algún ejemplo de cómo usar la
recursión con listas.</p>
<p>Ya hemos visto en dicho seminario que Scheme es un lenguaje débilmente
tipado. Una variable o parámetro no se declara de un tipo y puede
contener cualquier valor. Sucede igual con las listas: una lista en
Scheme puede contener cualquier valor, incluyendo otras listas.</p>
<h4 id="241-funcion-list-y-forma-especial-quote">2.4.1 Función <code>list</code> y forma especial <code>quote</code><a class="headerlink" href="#241-funcion-list-y-forma-especial-quote" title="Permanent link">&para;</a></h4>
<p>En el seminario de Scheme explicamos que podemos crear listas de forma
dinámica, llamando a la función <code>list</code> y pasándole un número variable
de parámetros que son los elementos que se incluirán en la lista:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">; ⇒ {1 2 3 4}</span>
<span class="p">(</span><span class="nb">list </span><span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">)</span> <span class="c1">; ⇒ {a b c}</span>
<span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="ss">&#39;a</span> <span class="mi">2</span> <span class="ss">&#39;b</span> <span class="mi">3</span> <span class="ss">&#39;c</span> <span class="no">#t</span><span class="p">)</span> <span class="c1">; ⇒ {1 a 2 b 3 c #t}</span>
<span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span> <span class="c1">; ⇒ {1 2 6}</span>
</pre></div>
</td></tr></table>

<p>Las expresiones interiores se evalúan y se llama a la función <code>list</code>
con los valores resultantes.</p>
<p>Otro ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">c</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="nb">list </span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="c1">; ⇒ {1 2 3}</span>
</pre></div>
</td></tr></table>

<p>La otra forma de crear una lista es de forma estática, utilizando la
forma especial <code>quote</code> vista anteriormente. Esa forma especial detiene
la evaluación natural de Scheme y devuelve la expresión que hay a
continuación sin evaluar. Si esa expresión es compuesta (entre
paréntesis) se devuelve como una lista, sin evaluar sus elementos</p>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">; ⇒ {1 2 3 4}</span>
<span class="p">(</span><span class="k">define </span><span class="nv">a</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">b</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="k">define </span><span class="nv">c</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="c1">; ⇒ {a b c}</span>
<span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span> <span class="c1">; ⇒ {1 {+ 1 1} {* 2 {+ 1 2}}}</span>
</pre></div>
</td></tr></table>

<p>La última lista tiene 3 elementos:</p>
<ul>
<li>El número 1</li>
<li>La lista <code>{+ 1 1}</code></li>
<li>La lista <code>{* 2 {+ 1 2}}</code></li>
</ul>
<p>Es posible definir una lista vacía (sin elementos) realizando una
llamada sin argumentos a la función <code>list</code> o utilizando el símbolo `():</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">list</span><span class="p">)</span> <span class="c1">; ⇒ {}</span>
<span class="o">`</span><span class="p">()</span> <span class="c1">; ⇒ {}</span>
</pre></div>
</td></tr></table>

<p>La diferencia entre creación de listas con la función <code>list</code> y con la
forma especial <code>quote</code> se puede comprobar en los ejemplos.</p>
<p>La evaluación de la función <code>list</code> funciona como cualquier función,
primero se evalúan los argumentos y después se invoca a la
función con los argumentos evaluados. Por ejemplo, en la
siguiente invocación se obtiene una lista con cuatro elementos
resultantes de las invocaciones de las funciones dentro del
paréntesis:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; ⇒ {1 2/3 5 {3 . 4}}</span>
</pre></div>
</td></tr></table>

<p>Sin embargo, usamos <code>quote</code> obtenemos una lista con sublistas
con símbolos en sus primeras posiciones:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; ⇒ {1 {/ 2 3} {+ 2 3} {cons 3 4}}</span>
</pre></div>
</td></tr></table>

<h4 id="242-seleccion-de-elementos-de-una-lista-car-y-cdr">2.4.2 Selección de elementos de una lista: <code>car</code> y <code>cdr</code><a class="headerlink" href="#242-seleccion-de-elementos-de-una-lista-car-y-cdr" title="Permanent link">&para;</a></h4>
<p>En el seminario vimos también cómo obtener los elementos de una lista.</p>
<ul>
<li>Primer elemento: función <code>car</code></li>
<li>Resto de elementos: función <code>cdr</code> (los devuelve en forma de lista)</li>
</ul>
<p>Ejemplos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">lista1</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="nb">car </span><span class="nv">lista1</span><span class="p">)</span> <span class="c1">; ⇒ 1</span>
<span class="p">(</span><span class="nb">cdr </span><span class="nv">lista1</span><span class="p">)</span> <span class="c1">; ⇒ {2 3 4}</span>
<span class="p">(</span><span class="k">define </span><span class="nv">lista2</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="nb">car </span><span class="nv">lista2</span><span class="p">)</span> <span class="err">⇒</span> <span class="err">{</span><span class="mi">1</span> <span class="mi">2</span><span class="err">}</span>
<span class="p">(</span><span class="nb">cdr </span><span class="nv">lista2</span><span class="p">)</span> <span class="err">⇒</span> <span class="err">{</span><span class="mi">3</span> <span class="mi">4</span><span class="err">}</span>
</pre></div>
</td></tr></table>

<h4 id="243-composicion-de-listas-cons-y-append">2.4.3 Composición de listas: <code>cons</code> y <code>append</code><a class="headerlink" href="#243-composicion-de-listas-cons-y-append" title="Permanent link">&para;</a></h4>
<p>Por último, en el seminario vimos también cómo crear nuevas listas a
partir de ya existentes con las funciones <code>cons</code> y <code>append</code>.</p>
<p>La función <code>cons</code> crea una lista nueva resultante de añadir un elemento
al comienzo de la lista. Esta función es la forma habitual de
construir nuevas listas a partir de una lista ya existente y un
nuevo elemento.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; ⇒ {1 1 2 3 4}</span>
<span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;hola</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">como</span> <span class="nv">est</span><span class="err">á</span><span class="nv">s</span><span class="p">))</span> <span class="c1">; ⇒ {hola como estás}</span>
<span class="p">(</span><span class="nb">cons </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>  <span class="c1">; ⇒ {{1 2} 1 2 3 4}</span>
</pre></div>
</td></tr></table>

<p>La función <code>append</code> se usa para crear una lista nueva resultado de
concatenar dos o más listas</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">list1</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">list2</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">hola</span> <span class="nv">como</span> <span class="nv">est</span><span class="err">á</span><span class="nv">s</span><span class="p">))</span>
<span class="p">(</span><span class="nb">append </span><span class="nv">list1</span> <span class="nv">list2</span><span class="p">)</span> <span class="c1">; ⇒ {1 2 3 4 hola como estás}</span>
</pre></div>
</td></tr></table>

<h3 id="25-recursion"><a name="2-5"></a> 2.5. Recursión<a class="headerlink" href="#25-recursion" title="Permanent link">&para;</a></h3>
<p>Otra característica fundamental de la programación funcional es la no
existencia de bucles. Un bucle implica la utilización de pasos de
ejecución en el programa y esto es característico de la programación
imperativa. En programación funcional las iteraciones se realizan con
recursión.</p>
<p>En una definición recursiva siempre tenemos un caso general y un caso
base. El caso base define el valor que devuelve la función en el caso
elemental en el que no hay que hacer ningún cálculo. El caso general
define una expresión que contiene una llamada a la propia función que
estamos definiendo.</p>
<h4 id="251-la-funcion-suma-hasta-x">2.5.1 La función <code>(suma-hasta x)</code><a class="headerlink" href="#251-la-funcion-suma-hasta-x" title="Permanent link">&para;</a></h4>
<p>Por ejemplo, podemos definir la función <code>(suma-hasta x)</code> que devuelve
la suma de los números hasta el parámetro <code>x</code> cuyo valor pasamos en la
invocación de la función.</p>
<p>Por ejemplo, <code>(suma-hasta 5)</code> devolverá <code>0+1+2+3+4+5 = 15</code>.</p>
<p>La definición de la función es la siguiente (después explicaremos cómo
la hemos diseñado)</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma-hasta</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="nv">x</span><span class="p">)</span>
      <span class="mi">0</span>
      <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">suma-hasta</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">x</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>El <strong>caso base</strong> es el caso en el que <code>x</code> vale 0. En este caso devolvemos
el propio 0, no hay que realizar ningún cálculo.</p>
<p>El <strong>caso general</strong> es en el que se realiza la llamada recursiva. Para
entender la expresión no es conveniente utilizar el depurador, ni
hacer trazas, ni <em>entrar en la recursión</em>, sino que hay que suponer
que <strong>la llamada recursiva se ejecuta y devuelve el valor que
debería. ¡Debemos confiar en la recursión!</strong>. Una vez devuelto el
valor, éste se utiliza para completar el resto del cálculo evaluando
la expresión resultante.</p>
<p>En nuestro el caso general indica lo siguiente:</p>
<blockquote>
<p>Para calcular la suma hasta x, llamamos a la recursión para que
calcule la suma hasta x-1, obtenemos el resultado (confiamos en que la
función funciona bien) y a ese resultado le sumamos el propio número
x.</p>
</blockquote>
<p>Siempre es aconsejable usar un ejemplo concreto para probar el caso
general. Por ejemplo, el caso general de la suma hasta 5 se calcularía
con la expresión:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">suma-hasta</span> <span class="p">(</span><span class="nb">- </span><span class="mi">5</span> <span class="mi">1</span><span class="p">))</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>La evaluación de esta función calculará la llamada recursiva
<code>(suma-hasta 4)</code>. Ahí es donde debemos <strong>confiar en que la recursión
hace bien su trabajo</strong> y que esa llamada devuelve el valor
resultante de 4+3+2+1, o sea, 10. Una vez obtenido ese valor hay que
terminar el cálculo sumándole el propio número 5.</p>
<p>```(+ (suma-hasta (- 5 1)) 5) =
(+ (suma-hasta 4) 5) = (confiamos en la recursión: (suma-hasta 4) = 10)
(+ 10 5) =
15</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>Otra característica necesaria del caso general en una definición
recursiva, que también vemos en este ejemplo, es que **la llamada
recursiva debe trabajar sobre un caso más sencillo que la llamada
general**. De esta forma la recursión va descomponiendo el problema
hasta llegar al caso base y construye la solución a partir de ahí.

En nuestro caso, la llamada recursiva para calcular la suma hasta 5 se
hace calculando la suma hasta 4 (un caso más sencillo).

#### 2.5.2 Diseño de la función `(suma-hasta x)`

¿Cómo hemos diseñado esta función? ¿Cómo hemos llegado a la solución?

Debemos empezar teniendo claro qué es lo que queremos calcular. Lo
mejor es utilizar un ejemplo. 

Por ejemplo, `(suma-hasta 5)` devolverá `0+1+2+3+4+5 = 15`. 

Una vez que tenemos esta expresión de un ejemplo concreto debemos
diseñar el caso general de la recursión. Para ello tenemos que
encontrar una expresión para el cálculo de `(suma-hasta 5)` que
contenga una llamada recursiva a un problema más pequeño.

O, lo que es lo mismo, ¿podemos obtener el resultado 15 con lo que nos
devuelve una llamada recursiva a un número más pequeño y haciendo algo
más?

Pues sí: para calcular la suma hasta 5, esto es, para obtener 15,
podemos llamar a la recursión para calcular la suma hasta 4 (devuelve
10) y a este resultado sumarle el propio 5.

Lo podemos expresar con el siguiente dibujo:

&lt;img src=&quot;imagenes/suma-hasta.png&quot; width=&quot;600px&quot;/&gt;

Generalizamos este ejemplo y lo expresamos en Scheme de la siguiente
forma:

```scheme
(suma-hasta x) = (+ (suma-hasta (- x 1)) x)
</pre></div>
</td></tr></table>

<p>Nos falta el caso base de la recursión. Debemos preguntarnos <strong>¿cuál
es el caso más sencillo del problema, que podemos calcular sin hacer
ninguna llamada recursiva?</strong>. En este caso podría ser el caso en el
que <code>x</code> es 0, en el que devolveríamos 0.</p>
<p>Podemos ya escribirlo todo en Scheme:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma-hasta</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="nv">x</span><span class="p">)</span>
      <span class="mi">0</span>
      <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">suma-hasta</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">x</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>Una aclaración sobre el caso general. En la implementación anterior la
llamada recursiva a <code>suma-hasta</code> se realiza en el primer argumento de
la suma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">suma-hasta</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="mi">1</span><span class="p">))</span> <span class="nv">x</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>La expresión anterior es totalmente equivalente a la siguiente
en la que la llamada recursiva aparece como segundo argumento</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="p">(</span><span class="nf">suma-hasta</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>Ambas expresiones son equivalentes porque en programación funcional no
importa el orden en el que se evalúan los argumentos. Da lo mismo
evaluarlos de derecha a izquierda que de izquierda a derecha. La
transparencia referencial garantiza que el resultado es el mismo.</p>
<h4 id="253-funcion-alfabeto-hasta-char">2.5.3. Función <code>(alfabeto-hasta char)</code><a class="headerlink" href="#253-funcion-alfabeto-hasta-char" title="Permanent link">&para;</a></h4>
<p>Vamos con otro ejemplo. Queremos diseñar una función <code>(alfabeto-hasta
char)</code> que devuelva una cadena que empieza en la letra <code>a</code> y termina
en el carácter que le pasamos como parámetro.</p>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">alfabeto-hasta</span> <span class="sc">#\h</span><span class="p">)</span> <span class="c1">; ⇒ &quot;abcdefgh&quot;</span>
<span class="p">(</span><span class="nf">alfabeto-hasta</span> <span class="sc">#\z</span><span class="p">)</span> <span class="c1">; ⇒ &quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
</pre></div>
</td></tr></table>

<p>Pensamos en el caso general: ¿cómo podríamos invocar a la propia
función <code>alfabeto-hasta</code> para que (confiando en la recursión) nos haga
gran parte del trabajo (construya casi toda la cadena con el
alfabeto)?</p>
<p>Podríamos hacer que la llamada recursiva devolviera el alfabeto hasta
el carácter previo al que nos pasan como parámetro y después nosotros
añadir ese carácter a la cadena que devuelve la recursión.</p>
<p>Veamos un ejemplo concreto:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>(alfabeto-hasta #\h) = (alfabeto-hasta #\g) + \#h
</pre></div>
</td></tr></table>

<p>La llamada recursiva <code>(alfabeto-hasta #\g)</code> devolvería la cadena
<code>"abcdefg"</code> (confiando en la recursión) y sólo faltaría añadir la
última letra.</p>
<p>Para implementar esta idea en Scheme lo único que necesitamos es usar
la función <code>string-append</code> para concatenar cadenas y una función
auxiliar <code>(anterior char)</code> que devuelve el carácter anterior a uno
dado.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">anterior</span> <span class="nv">char</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">integer-&gt;char </span><span class="p">(</span><span class="nb">- </span><span class="p">(</span><span class="nb">char-&gt;integer </span><span class="nv">char</span><span class="p">)</span> <span class="mi">1</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>El caso general quedaría como sigue:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">alfabeto-hasta</span> <span class="nv">char</span><span class="p">)</span> <span class="nv">=</span>
    <span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="nf">alfabeto-hasta</span> <span class="p">(</span><span class="nf">anterior</span> <span class="nv">char</span><span class="p">))</span> <span class="p">(</span><span class="nb">string </span><span class="nv">char</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Faltaría el caso base. ¿Cuál es el caso más sencillo posible que nos
pueden pedir? El caso del alfabeto hasta la <code>#\a</code>. En ese caso basta
con devolver la cadena <code>"a"</code>.</p>
<p>La función completa quedaría así:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">alfabeto-hasta</span> <span class="nv">char</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">equal? </span><span class="nv">char</span> <span class="sc">#\a</span><span class="p">)</span>
      <span class="s">&quot;a&quot;</span>
      <span class="p">(</span><span class="nb">string-append </span><span class="p">(</span><span class="nf">alfabeto-hasta</span> <span class="p">(</span><span class="nf">anterior</span> <span class="nv">char</span><span class="p">))</span> <span class="p">(</span><span class="nb">string </span><span class="nv">char</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<h3 id="26-recursion-y-listas"><a name="2-6"></a> 2.6. Recursión y listas<a class="headerlink" href="#26-recursion-y-listas" title="Permanent link">&para;</a></h3>
<p>La utilización de la recursión es muy útil para trabajar con
estructuras secuenciales, como listas. Vamos a empezar viendo unos
sencillos ejemplos y más adelante veremos algunos más complicadas.</p>
<h4 id="261-funcion-recursiva-suma-lista">2.6.1 Función recursiva <code>suma-lista</code><a class="headerlink" href="#261-funcion-recursiva-suma-lista" title="Permanent link">&para;</a></h4>
<p>Veamos un primer ejemplo, la función <code>(suma-lista
lista-nums)</code> que recibe como parámetro una lista de números y devuelve
la suma de todos ellos.</p>
<p>Siempre tenemos que empezar escribiendo un ejemplo de la función:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>(suma-lista &#39;(12 3 5 1 8)) = 29
</pre></div>
</td></tr></table>

<p>Para diseñar una implementación recursiva de la función tenemos que
pensar en cómo descomponer el ejemplo en una llamada recursiva a un
problema más pequeño y en cómo tratar el valor devuelto por la
recursión para obtener el valor esperado.</p>
<p>Por ejemplo, en este caso podemos pensar que para sumar la lista de
números <code>(12 3 5 1 8)</code> podemos obtener un problema más sencillo (una
lista más pequeña) haciendo el <code>cdr</code> de la lista de números y llamando
a la recursión con el resultado. La llamada recursiva devolverá la
suma de esos números (confiamos en la recursión) y a ese valor basta
con sumarle el primer número de la lista. Lo podemos representar en el
siguiente dibujo:</p>
<p><img src="imagenes/suma-lista.png" width="600px"/></p>
<p>Podemos generalizar este ejemplo y expresarlo en Scheme de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>(suma-lista lista) = (+ (car lista) (suma-lista (cdr lista)))
</pre></div>
</td></tr></table>

<p>Falta el caso base, que es el caso más sencillo en que podemos
devolver un valor sin llamar a la recursión. En este caso, podría ser
cuando le pesamos a la función una lista sin elementos, en donde hay
que devolver 0.</p>
<p>Con todo junto, quedaría la recursión como sigue</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma-lista</span> <span class="nv">lista</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">lista</span><span class="p">)</span>
       <span class="mi">0</span>
       <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">)</span> <span class="p">(</span><span class="nf">suma-lista</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)))))</span>
</pre></div>
</td></tr></table>

<h4 id="262-funcion-recursiva-veces">2.6.2 Función recursiva <code>veces</code><a class="headerlink" href="#262-funcion-recursiva-veces" title="Permanent link">&para;</a></h4>
<p>Como último ejemplo vamos a definir la función <code>(veces lista id)</code> que
cuenta el número de veces que aparece un identificador en una lista.</p>
<p>¿Cómo planteamos el caso general? Llamaremos a la recursión con el
resto de la lista. Esta llamada nos devolverá el número de veces que
aparece el identificador en este resto de la lista. Y después sumamos
al valor devuelto 1 si el primer elemento de la lista coincide con el
identificador.</p>
<p>En Scheme:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>(veces lista identificador) = (if (equal? (car lista) identificador)
                                   (+ 1 (veces (cdr lista) identificador))
                                   (veces (cdr lista) identificador))
</pre></div>
</td></tr></table>

<p>Como caso base, si la lista es vacía devolvemos 0.</p>
<p>La versión completa:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">veces</span> <span class="nv">lista</span> <span class="nv">id</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">cond</span>
    <span class="p">((</span><span class="nb">null? </span><span class="nv">lista</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">((</span><span class="nb">equal? </span><span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">)</span> <span class="nv">id</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="p">(</span><span class="nf">veces</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)</span> <span class="nv">id</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">veces</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)</span> <span class="nv">id</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">veces</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">a</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">b</span><span class="p">)</span> <span class="ss">&#39;a</span><span class="p">)</span> <span class="c1">; ⇒ 3 </span>
</pre></div>
</td></tr></table>

<h2 id="3-tipos-de-datos-compuestos-en-scheme"><a name="3"></a> 3. Tipos de datos compuestos en Scheme<a class="headerlink" href="#3-tipos-de-datos-compuestos-en-scheme" title="Permanent link">&para;</a></h2>
<h3 id="31-el-tipo-de-dato-pareja"><a name="3-1"></a> 3.1. El tipo de dato pareja<a class="headerlink" href="#31-el-tipo-de-dato-pareja" title="Permanent link">&para;</a></h3>
<h4 id="311-funcion-de-construccion-de-parejas-cons">3.1.1. Función de construcción de parejas <code>cons</code><a class="headerlink" href="#311-funcion-de-construccion-de-parejas-cons" title="Permanent link">&para;</a></h4>
<p>Ya hemos visto en el seminario de Scheme que el tipo de dato compuesto
más simple es la pareja: una entidad formada por dos elementos. Se
utiliza la función <code>cons</code> para construirla:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; ⇒ {1 . 2}</span>
<span class="p">(</span><span class="k">define </span><span class="nv">c</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Dibujamos la pareja anterior y la variable <code>c</code> que la referencia de la
siguiente forma:</p>
<p><img src="imagenes/pareja.png" width="200px"/></p>
<p><em>Tipo compuesto pareja</em></p>
<p>La instrucción <code>cons</code> construye un dato compuesto a partir de otros
dos datos (que llamaremos izquierdo y derecho). La expresión <code>{1 . 2}</code>
es la forma que el intérprete tiene de imprimir las parejas.</p>
<h4 id="312-funciones-de-acceso-car-y-cdr">3.1.2. Funciones de acceso <code>car</code> y <code>cdr</code><a class="headerlink" href="#312-funciones-de-acceso-car-y-cdr" title="Permanent link">&para;</a></h4>
<p>Una vez construida una pareja, podemos obtener el elemento
correspondiente a su parte izquierda con la función <code>car</code> y su parte
derecha con la función <code>cdr</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">c</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nb">car </span><span class="nv">c</span><span class="p">)</span> <span class="c1">; ⇒ 1</span>
<span class="p">(</span><span class="nb">cdr </span><span class="nv">c</span><span class="p">)</span> <span class="c1">; ⇒ 2</span>
</pre></div>
</td></tr></table>

<h5 id="definicion-declarativa">Definición declarativa<a class="headerlink" href="#definicion-declarativa" title="Permanent link">&para;</a></h5>
<p>Las funciones <code>cons</code>, <code>car</code> y <code>cdr</code> quedan perfectamente definidas con
las siguientes ecuaciones algebraicas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="nv">=</span> <span class="nv">x</span>
<span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="nv">=</span> <span class="nv">y</span>
</pre></div>
</td></tr></table>

<h5 id="de-donde-vienen-los-nombres-car-y-cdr">¿De dónde vienen los nombres <code>car</code> y <code>cdr</code>?<a class="headerlink" href="#de-donde-vienen-los-nombres-car-y-cdr" title="Permanent link">&para;</a></h5>
<p>Inicialmente los nombres eran CAR y CDR (en mayúsculas). La historia
se remonta al año 1959, en los orígenes del Lisp y tiene que ver con
el nombre que se les daba a ciertos registros de la memoria del IBM
709.</p>
<p>Podemos leer la explicación completa en
<a href="http://www.iwriteiam.nl/HaCAR_CDR.html">The origin of CAR and CDR in LISP</a>.</p>
<h4 id="313-funcion-pair">3.1.3. Función pair?<a class="headerlink" href="#313-funcion-pair" title="Permanent link">&para;</a></h4>
<p>La función <code>pair?</code> nos dice si un objeto es atómico o es una pareja:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">pair? </span><span class="mi">3</span><span class="p">)</span> <span class="c1">; ⇒ #f</span>
<span class="p">(</span><span class="nb">pair? </span><span class="p">(</span><span class="nb">cons </span><span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; ⇒ #t</span>
</pre></div>
</td></tr></table>

<h4 id="314-las-parejas-pueden-contener-cualquier-tipo-de-dato">3.1.4. Las parejas pueden contener cualquier tipo de dato<a class="headerlink" href="#314-las-parejas-pueden-contener-cualquier-tipo-de-dato" title="Permanent link">&para;</a></h4>
<p>Ya hemos comprobado que Scheme es un lenguaje <em>débilmente
tipado</em>. Las funciones pueden devolver y recibir distintos tipos de
datos.</p>
<p>Por ejemplo, podríamos definir la siguiente función <code>suma</code> que sume
tanto números como cadenas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span>
    <span class="p">((</span><span class="k">and </span><span class="p">(</span><span class="nb">number? </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">number? </span><span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
    <span class="p">((</span><span class="k">and </span><span class="p">(</span><span class="nb">string? </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">string? </span><span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">string-append </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
    <span class="p">(</span><span class="k">else </span><span class="ss">&#39;error</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>En la función anterior los parámetros <code>x</code> e <code>y</code> pueden ser números o
cadenas (o incluso de cualquier otro tipo). Y el valor devuelto por la
función será un número, una cadena o el símbolo <code>'error</code>.</p>
<p>Sucede lo mismo con el contenido de las parejas. Es posible guardar en
las parejas cualquier tipo de dato y combinar distintos tipos. Por
ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">c</span> <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;hola</span> <span class="no">#f</span><span class="p">))</span>
<span class="p">(</span><span class="nb">car </span><span class="nv">c</span><span class="p">)</span> <span class="c1">; ⇒ &#39;hola</span>
<span class="p">(</span><span class="nb">cdr </span><span class="nv">c</span><span class="p">)</span> <span class="c1">; ⇒ #f</span>
</pre></div>
</td></tr></table>

<h4 id="315-las-parejas-son-objetos-inmutables">3.1.5. Las parejas son objetos inmutables<a class="headerlink" href="#315-las-parejas-son-objetos-inmutables" title="Permanent link">&para;</a></h4>
<p>Recordemos que en los paradigmas de programación declarativa y
funcional no existe el <em>estado mutable</em>. Una vez declarado un valor,
no se puede modificar. Esto debe suceder también con las parejas: una
vez creada una pareja no se puede modificar su contenido.</p>
<p>En Lisp y Scheme estándar (R6RS) las parejas sí que pueden ser
mutadas. Pero durante toda esta primera parte de la asignatura no lo
contemplaremos, para no salirnos del paradigma funcional.</p>
<p>En Swift y otros lenguajes de programación es posible definir
<strong>estructuras de datos inmutables</strong> que no pueden ser modificadas una
vez creadas. Lo veremos también más adelante.</p>
<h3 id="32-las-parejas-son-objetos-de-primera-clase"><a name="3-2"></a> 3.2. Las parejas son objetos de primera clase<a class="headerlink" href="#32-las-parejas-son-objetos-de-primera-clase" title="Permanent link">&para;</a></h3>
<p>En un lenguaje de programación un elemento es de primera clase cuando puede:</p>
<ul>
<li>Asignarse a variables</li>
<li>Pasarse como argumento</li>
<li>Devolverse por una función</li>
<li>Guardarse en una estructura de datos mayor</li>
</ul>
<p>Las parejas son objetos de primera clase.</p>
<p>Una pareja puede asignarse a una variable:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">p1</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p2</span> <span class="p">(</span><span class="nb">cons </span><span class="no">#f</span> <span class="s">&quot;hola&quot;</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Una pareja puede pasarse como argumento y devolverse en una función:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma-parejas</span> <span class="nv">p1</span> <span class="nv">p2</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">car </span><span class="nv">p1</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">p2</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">p1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">p2</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">suma-parejas</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="o">.</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">4</span> <span class="o">.</span> <span class="mi">12</span><span class="p">))</span> <span class="c1">; ⇒ {5 . 17}</span>
</pre></div>
</td></tr></table>

<p>Una vez definida esta función <code>suma-parejas</code> podríamos ampliar la
función <code>suma</code> que vimos previamente con este nuevo tipo de datos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">cond </span>
    <span class="p">((</span><span class="k">and </span><span class="p">(</span><span class="nb">number? </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">number? </span><span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
    <span class="p">((</span><span class="k">and </span><span class="p">(</span><span class="nb">string? </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">string? </span><span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">string-append </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
    <span class="p">((</span><span class="k">and </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">pair? </span><span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nf">suma-parejas</span> <span class="nv">p1</span> <span class="nv">p2</span><span class="p">))</span>
    <span class="p">(</span><span class="k">else </span><span class="ss">&#39;error</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>Y, por último, las parejas <em>pueden formar parte de otras parejas</em>. Es
lo que se denomina la propiedad de clausura de la función <code>cons</code>:</p>
<blockquote>
<p>El resultado de un <code>cons</code> puede usarse como parámetro de nuevas llamadas a <code>cons</code>.</p>
</blockquote>
<p>Ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">p1</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p2</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="nv">p</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">p1</span> <span class="nv">p2</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Expresión equivalente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">p</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">cons </span><span class="mi">3</span> <span class="mi">4</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>Podríamos representar esta estructura así:</p>
<p><img src="imagenes/pareja-pareja.png" width="300px"/></p>
<p><em>Propiedad de clausura: las parejas pueden contener parejas</em></p>
<p>Pero se haría muy complicado representar muchos niveles de
anidamiento. Por eso utilizamos la siguiente representación:</p>
<p><img src="imagenes/pareja-pareja2.png" width="250px"/></p>
<p>Llamamos a estos diagramas <em>diagramas caja-y-puntero</em>
(<em>box-and-pointer</em> en inglés).</p>
<h3 id="33-diagramas-caja-y-puntero"><a name="3-3"></a> 3.3. Diagramas <em>caja-y-puntero</em><a class="headerlink" href="#33-diagramas-caja-y-puntero" title="Permanent link">&para;</a></h3>
<p>Al escribir expresiones complicadas con <code>cons</code> anidados es conveniente
para mejorar su legibilidad utilizar el siguiente formato:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">p</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">cons </span><span class="mi">1</span>
                      <span class="p">(</span><span class="nb">cons </span><span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
                <span class="mi">2</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Para entender la construcción de estas estructuras es importante
recordar que las expresiones se evalúan <em>de dentro a afuera</em>.</p>
<p>¿Qué figura representaría la estructura anterior?</p>
<p>Solución:</p>
<p><img src="imagenes/pareja-pareja3.png" width="200px"/></p>
<p>Es importante tener en cuenta que cada caja del diagrama representa
una pareja creada en la memoria del intérprete con la instrucción
<code>cons</code> y que el resultado de evaluar una variable en la que se ha
guardado una pareja devuelve la pareja recién creada. Por ejemplo, si
el intérprete evalúa <code>p</code> después de haber hecho la sentencia anterior
devuelve la pareja contenida en <code>p</code>, no se crea una pareja nueva.</p>
<p>Por ejemplo, si después de haber evaluado la sentencia anterior
evaluamos la siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">p2</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">5</span> <span class="p">(</span><span class="nb">cons </span><span class="nv">p</span> <span class="mi">6</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>El diagrama caja y puntero resultante sería el siguiente:</p>
<p><img src="imagenes/box-and-pointer2.png" width="250px"/></p>
<p>Vemos que en la pareja que se crea con <code>(cons p 6)</code> se guarda en la
parte izquierda <strong>la misma pareja que hay en <code>p</code></strong>. Lo representamos
con una flecha que apunta a la misma pareja que <code>p</code>.</p>
<p><strong>IMPORTANTE</strong>: El funcionamiento de la evaluación de las parejas es
  similar al de los objetos en lenguajes orientados a objetos como
  Java. Cuando se evalúa una variable que contiene una pareja se
  devuelve la propia pareja, no una copia. En programación funcional,
  como el contenido de las parejas es inmutable, no hay problemas de
  <em>efectos laterales</em> por el hecho de que una pareja esté
  compartida. Veremos que cuando introduzcamos la mutación en Scheme
  aparecerán estos efectos laterales.</p>
<p>Es conveniente que pruebes a crear distintas estructuras de parejas
con parejas y a dibujar su diagrama caja y puntero. Y también a
recuperar un determinado dato (pareja o dato atómico) una vez creada
la estructura.</p>
<p>La siguiente función <code>print-pareja</code> puede ser útil a la hora de
mostrar por pantalla los elementos de una pareja</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">print-pareja</span> <span class="nv">pareja</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">pareja</span><span class="p">)</span>
        <span class="p">(</span><span class="k">begin </span>
            <span class="p">(</span><span class="nb">display </span><span class="s">&quot;{&quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">print-dato</span> <span class="p">(</span><span class="nb">car </span><span class="nv">pareja</span><span class="p">))</span>
            <span class="p">(</span><span class="nb">display </span><span class="s">&quot; . &quot;</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">print-dato</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pareja</span><span class="p">))</span>
            <span class="p">(</span><span class="nb">display </span><span class="s">&quot;}&quot;</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">print-dato</span> <span class="nv">dato</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">pair? </span><span class="nv">dato</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">print-pareja</span> <span class="nv">dato</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">display </span><span class="nv">dato</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p><strong>!Cuidado¡</strong>: la función anterior contiene sentencias como <code>begin</code> o
   llamadas a <code>display</code> dentro del código de la función, que son
   propias de la programación imperativa. <strong>No hacerlo en programación
   funcional</strong>.</p>
<h4 id="331-funciones-cr">3.3.1. Funciones c????r<a class="headerlink" href="#331-funciones-cr" title="Permanent link">&para;</a></h4>
<p>Al trabajar con estructuras de parejas anidades es muy habitual
realizar llamadas del tipo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">cdr </span><span class="p">(</span><span class="nb">car </span><span class="nv">p</span><span class="p">)))</span> <span class="c1">; ⇒ 4</span>
</pre></div>
</td></tr></table>

<p>Es equivalente a la función <code>cadar</code> de Scheme:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">cddar </span><span class="nv">p</span><span class="p">)</span> <span class="c1">; ⇒ 4</span>
</pre></div>
</td></tr></table>

<p>El nombre de la función se obtiene concatenando a la letra "c", las
letras "a" o "d" según hagamos un car o un cdr y terminando con la
letra "r".</p>
<p>Hay definidas 2^4 funciones de este tipo: <code>caaaar</code>, <code>caaadr</code>, …,
<code>cddddr</code>.</p>
<h2 id="4-listas-en-scheme"><a name="4"></a> 4. Listas en Scheme<a class="headerlink" href="#4-listas-en-scheme" title="Permanent link">&para;</a></h2>
<h3 id="41-implementacion-de-listas-en-scheme"><a name="4-1"></a> 4.1. Implementación de listas en Scheme<a class="headerlink" href="#41-implementacion-de-listas-en-scheme" title="Permanent link">&para;</a></h3>
<p>Recordemos que Scheme permite manejar listas como un tipo de datos
básico. Hemos visto funciones para crear, añadir y recorrer listas.</p>
<p>Como repaso, podemos ver las siguientes expresiones. Fijaros que las
funciones <code>car</code>, <code>cdr</code> y <code>cons</code> son exactamente las mismas funciones
que las vistas anteriormente.</p>
<p>¿Por qué? ¿Qué relación hay entre las parejas y las listas?</p>
<p>Hagamos algunas pruebas, probando si los resultados son listas o
parejas usando las funciones <code>list?</code> y <code>pair?</code>.</p>
<p>Por ejemplo, una pareja formada por dos números es una pareja, pero no
es una lista:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">p1</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
<span class="p">(</span><span class="nb">pair? </span><span class="nv">p1</span><span class="p">)</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="nb">list? </span><span class="nv">p1</span><span class="p">)</span> <span class="c1">; ⇒ #f</span>
</pre></div>
</td></tr></table>

<p>Y una lista vacía es una lista, pero no es una pareja:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">list? </span><span class="o">&#39;</span><span class="p">())</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="nb">pair? </span><span class="o">&#39;</span><span class="p">())</span> <span class="c1">; ⇒ #f</span>
</pre></div>
</td></tr></table>

<p>¿Una lista es una pareja? Pues sí:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">lista</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nb">list? </span><span class="nv">lista</span><span class="p">)</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="nb">pair? </span><span class="nv">lista</span><span class="p">)</span> <span class="c1">; ⇒ #t</span>
</pre></div>
</td></tr></table>

<p>Por último, una pareja con una lista vacía como segundo elemento es
una pareja y una lista:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">p1</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="o">&#39;</span><span class="p">()))</span>
<span class="p">(</span><span class="nb">pair? </span><span class="nv">p1</span><span class="p">)</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="nb">list? </span><span class="nv">p1</span><span class="p">)</span> <span class="c1">; ⇒ #t</span>
</pre></div>
</td></tr></table>

<p>Con estos ejemplos ya tenemos pistas para deducir la relación entre
listas y parejas en Scheme (y Lisp). Vamos a explicarlo.</p>
<h4 id="411-definicion-de-listas-con-parejas">4.1.1. Definición de listas con parejas<a class="headerlink" href="#411-definicion-de-listas-con-parejas" title="Permanent link">&para;</a></h4>
<p>Una lista es (definición recursiva):</p>
<ul>
<li>Una pareja que contiene en su parte izquierda el primer elemento de
  la lista y en su parte derecha el resto de la lista</li>
<li>Un símbolo especial <code>'()</code> que denota la lista vacía</li>
</ul>
<p>Por ejemplo, una lista muy sencilla con un solo elemento, <code>{1}</code>, se
define con la siguiente pareja:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="o">&#39;</span><span class="p">())</span>
</pre></div>
</td></tr></table>

<p>La pareja cumple las condiciones anteriores: </p>
<ul>
<li>La parte izquierda de la pareja es el primer elemento de la lista
  (el número 1)</li>
<li>La parte derecha es el resto de la lista (la lista vacía)</li>
</ul>
<p><img src="imagenes/pareja-lista.png" width="150px"/></p>
<p><em>La lista {1}</em></p>
<p>El objeto es al mismo tiempo una pareja y una lista. La función
<code>list?</code> permite comprobar si un objeto es una lista:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">l</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="o">&#39;</span><span class="p">()))</span>
<span class="p">(</span><span class="nb">pair? </span><span class="nv">l</span><span class="p">)</span>
<span class="p">(</span><span class="nb">list? </span><span class="nv">l</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Por ejemplo, la lista '(1 2 3 4) se construye con la siguiente
secuencia de parejas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">cons </span><span class="mi">1</span>
      <span class="p">(</span><span class="nb">cons </span><span class="mi">2</span>
            <span class="p">(</span><span class="nb">cons </span><span class="mi">3</span>
                  <span class="p">(</span><span class="nb">cons </span><span class="mi">4</span> 
                        <span class="o">&#39;</span><span class="p">()))))</span>
</pre></div>
</td></tr></table>

<p>La primera pareja cumple las condiciones de ser una lista:</p>
<ul>
<li>Su primer elemento es el 1</li>
<li>Su parte derecha es la lista '(2 3 4)</li>
</ul>
<p><img src="imagenes/lista.png" width="400px"/></p>
<p><em>Parejas formando una lista</em></p>
<p>Al comprobar la implementación de las listas en Scheme, entendemos por
qué las funciones <code>car</code> y <code>cdr</code> nos devuelven el primer elemento y el
resto de la lista.</p>
<h4 id="412-lista-vacia">4.1.2. Lista vacía<a class="headerlink" href="#412-lista-vacia" title="Permanent link">&para;</a></h4>
<p>La lista vacía es una lista:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">list? </span><span class="o">&#39;</span><span class="p">())</span> <span class="c1">; ⇒ #t</span>
</pre></div>
</td></tr></table>

<p>Y no es un símbolo ni una pareja:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">symbol? </span><span class="o">&#39;</span><span class="p">())</span> <span class="c1">; ⇒ #f</span>
<span class="p">(</span><span class="nb">pair? </span><span class="o">&#39;</span><span class="p">())</span> <span class="c1">; ⇒ #f</span>
</pre></div>
</td></tr></table>

<p>Para saber si un objeto es la lista vacía, podemos utilizar la función
<code>null?</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">null? </span><span class="o">&#39;</span><span class="p">())</span> <span class="c1">; ⇒ #t</span>
</pre></div>
</td></tr></table>

<h3 id="42-listas-con-elementos-compuestos"><a name="4-2"></a> 4.2. Listas con elementos compuestos<a class="headerlink" href="#42-listas-con-elementos-compuestos" title="Permanent link">&para;</a></h3>
<p>Las listas pueden contener cualquier tipo de elementos, incluyendo
otras parejas.</p>
<p>La siguiente estructura se denomina <em>lista de asociación</em>. Son listas
cuyos elementos son parejas (<em>clave</em>, <em>valor</em>):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;a</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;b</span> <span class="mi">2</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;c</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">; ⇒ {{a . 1} {b . 2} {c . 2}}</span>
</pre></div>
</td></tr></table>

<p>¿Cuál sería el diagrama <em>box and pointer</em> de la estructura anterior?</p>
<p><img src="imagenes/lista-parejas.png" width="400px"/></p>
<p>La expresión equivalente utilizando conses es:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;a</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;b</span> <span class="mi">2</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">cons </span><span class="ss">&#39;c</span> <span class="mi">3</span><span class="p">)</span>
                  <span class="o">&#39;</span><span class="p">())))</span>
</pre></div>
</td></tr></table>

<h4 id="421-listas-de-listas">4.2.1. Listas de listas<a class="headerlink" href="#421-listas-de-listas" title="Permanent link">&para;</a></h4>
<p>Hemos visto que podemos construir listas que contienen otras listas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">lista</span> <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>La lista anterior también se puede definir con quote:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">lista</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>La lista resultante contiene tres elementos: el primero y el último
son elementos atómicos (números) y el segundo es otra lista.</p>
<p>Si preguntamos por la longitud de la lista Scheme nos dirá que es una
lista de 3 elementos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">length </span><span class="nv">lista</span><span class="p">)</span> <span class="c1">; ⇒ 3</span>
</pre></div>
</td></tr></table>

<p>Y el segundo elemento de la lista es otra lista:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">))</span> <span class="c1">; ⇒ {1 2 3}</span>
</pre></div>
</td></tr></table>

<p>¿Cómo implementa Scheme esta lista usando parejas?</p>
<p>Al ser una lista de tres elementos lo hará con tres parejas enlazadas
que terminan en una lista vacía en la parte derecha de la última
pareja. En las partes izquierdas de esas tres parejas tendremos los
elementos de la lista propiamente dichos: un 1 y un 3 en la primera y
última pareja y una lista en la segunda pareja.</p>
<p>El diagrama <em>box and pointer</em>:</p>
<p><img src="imagenes/lista-lista.png" width="500px"/></p>
<p><em>Lista que contiene otra lista como segundo elemento</em></p>
<h4 id="422-distintos-niveles-de-abstraccion">4.2.2. Distintos niveles de abstracción<a class="headerlink" href="#422-distintos-niveles-de-abstraccion" title="Permanent link">&para;</a></h4>
<p>Es muy importante utilizar el nivel de abstracción correcto a la hora
de trabajar con listas que contienen otros elementos compuestos, como
otras parejas u otras listas.</p>
<p>Sólo hace falta <em>bajar</em> al nivel de caja y puntero cuando estemos
definiendo funciones de bajo nivel que tratan la estructura de datos
para obtener elementos concretos de las parejas.</p>
<p>Si, por el contrario, estamos recorriendo la lista principal y
queremos tratar sus elementos, debemos <em>verla</em> como una lista normal y
recorrerla con las funciones <code>car</code> para obtener su primer elemento y
<code>cdr</code> para obtener el resto. O <code>list-ref</code> para obtener un elemento
determinado (que puede ser atómico o compuesto).</p>
<p>Por ejemplo, la lista anterior <code>{1 {1 2 3} 3}</code> es una lista de 3
elementos. Si queremos obtener su segundo elemento (la lista <code>{1 2
3}</code>) bastaría con:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">lista</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nb">car </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">))</span> <span class="p">(</span><span class="nb">list-ref </span><span class="nv">lista</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<h3 id="43-funciones-recursivas-y-listas"><a name="4-3"></a> 4.3. Funciones recursivas y listas<a class="headerlink" href="#43-funciones-recursivas-y-listas" title="Permanent link">&para;</a></h3>
<h4 id="431-implementacion-recursiva-de-funciones-sobre-listas">4.3.1. Implementación recursiva de funciones sobre listas<a class="headerlink" href="#431-implementacion-recursiva-de-funciones-sobre-listas" title="Permanent link">&para;</a></h4>
<p>Vamos a ver cómo se implementan de forma recursiva alguna de funciones
que trabajan con listas, incluyendo algunas de las funciones de
Scheme. Para no solapar con las definiciones de Scheme pondremos el
prefijo <code>mi-</code> en todas ellas:</p>
<ul>
<li><code>mi-list-ref</code>: implementación de la función <code>list-ref</code></li>
<li><code>mi-append</code>: implementación de la funión <code>append</code> </li>
</ul>
<h5 id="funcion-mi-list-ref">Función <code>mi-list-ref</code><a class="headerlink" href="#funcion-mi-list-ref" title="Permanent link">&para;</a></h5>
<p>La función <code>(mi-list-ref n lista)</code> devuelve el elemento <code>n</code> de una
lista (empezando a contar por 0):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">lista</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span> <span class="nv">f</span> <span class="nv">g</span><span class="p">))</span>
<span class="p">(</span><span class="nf">mi-list-ref</span> <span class="nv">lista</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; ⇒ c</span>
</pre></div>
</td></tr></table>

<p>Veamos con el ejemplo anterior cómo hacer la formulación recursiva.</p>
<p>Hemos visto que, en general, cuando queremos resolver un problema de
forma recursiva tenemos que hacer una llamada recursiva a un problema
más sencillo, <strong>confiar en que la llamada nos devuelva el resultado
correcto</strong> y usar ese resultado para resolver el problema original.</p>
<p>En este caso nuestro problema es obtener el número que está en la
posición 2 de la lista <code>{a b c d e f g}</code>. Suponemos que la función que
nos devuelve una posición de la lista ya la tenemos implementada y que
la llamada recursiva nos va a devolver el resultado correcto. ¿Cómo
podemos simplificar el problema original? Veamos la solución para este
caso concreto:</p>
<blockquote>
<p>Para devolver el elemento 2 (empezando a contar por 0) de la lista
<code>{a b c d e f g}</code> podemos hacer el <code>cdr</code> de la lista (obtendríamos
<code>{b c d e f g}</code>) y devolver su elemento 1. Sería el valor <code>c</code>.</p>
</blockquote>
<p>Generalizamos el ejemplo anterior, para cualquier <code>n</code> y cualquier lista:</p>
<blockquote>
<p>Para devolver el elemento que está en la posición <code>n</code> de una lista,
hago el cdr de la lista y devuelvo su elemento n-1.</p>
</blockquote>
<p>Y, por último, formulamos el caso base de la recursión, el problema
más sencillo que se puede resolver directamente, sin hacer una llamada
recursiva:</p>
<blockquote>
<p>Para devolver el elemento que está en la posición 0 de una lista,
devuelvo el <code>car</code> de la lista</p>
</blockquote>
<p>La implementación de todo esto en Scheme sería la siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mi-list-ref</span> <span class="nv">lista</span> <span class="nv">n</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> 
      <span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">mi-list-ref</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<h5 id="funcion-list-tail">Función <code>list-tail</code><a class="headerlink" href="#funcion-list-tail" title="Permanent link">&para;</a></h5>
<p>La función <code>(mi-list-tail lista n)</code> devuelve la lista resultante de
quitar n elementos de la lista original:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">mi-list-tail</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; ⇒ {3 4 5 6 7}</span>
</pre></div>
</td></tr></table>

<p>Piensa en cómo se implementaría de forma recursiva. Esta vez vamos a
mostrar directamente la implementación, sin dar explicaciones de cómo
se ha llegado a ella:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mi-list-tail</span> <span class="nv">lista</span> <span class="nv">n</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> 
       <span class="nv">lista</span>
       <span class="p">(</span><span class="nf">mi-list-tail</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<h5 id="funcion-mi-append">Función <code>mi-append</code><a class="headerlink" href="#funcion-mi-append" title="Permanent link">&para;</a></h5>
<p>Veamos ahora cómo podríamos implementar de forma recursiva la función
<code>append</code> que une dos listas. La llamaremos <code>(mi-append lista1
lista2)</code>.</p>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">mi-append</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">d</span> <span class="nv">e</span> <span class="nv">f</span><span class="p">))</span> <span class="c1">; ⇒ {a b c d e f}</span>
</pre></div>
</td></tr></table>

<p>Para resolver el problema de forma recursiva, haremos el <code>cdr</code> de la
primera lista, llamaremos a la recursión para que una el resultado con
la segunda lista`:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>(mi-append (cdr &#39;(a b c)) &#39;(d e f)) =
(mi-append &#39;(b c) &#39;(d e f) = {b c d e f}
</pre></div>
</td></tr></table>

<p>Y añadiremos el primer elemento a la lista resultante usando un <code>cons</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>(cons (car &#39;(a b c)) (mi-append (cdr &#39;(a b c)) &#39;(d e f))) =
(cons &#39;a &#39;(b c d e f)) = {a b c d e f}
</pre></div>
</td></tr></table>

<p>En general:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>(mi-append lista1 lista2) = (cons (car lista1) (mi-append (cdr lista1) lista2))
</pre></div>
</td></tr></table>

<p>El caso base, el caso en el que la función puede devolver un valor
directamente sin llamar a la recursión, es aquel en el que <code>lista1</code> es
<code>null?</code>. En ese caso devolvemos <code>lista2</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">mi-append</span> <span class="o">&#39;</span><span class="p">()</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span> <span class="nv">=</span> <span class="o">&#39;</span><span class="err">{</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="err">}</span>
</pre></div>
</td></tr></table>

<p>La formulación recursiva completa queda como sigue:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mi-append</span> <span class="nv">l1</span> <span class="nv">l2</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">l1</span><span class="p">)</span>
        <span class="nv">l2</span>
        <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">l1</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">mi-append</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">l1</span><span class="p">)</span> <span class="nv">l2</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<h5 id="funcion-mi-reverse">Función <code>mi-reverse</code><a class="headerlink" href="#funcion-mi-reverse" title="Permanent link">&para;</a></h5>
<p>Veamos cómo implementar de forma recursiva la función <code>mi-reverse</code> que
invierte una lista</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">mi-reverse</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span> <span class="c1">; ⇒ {6 5 4 3 2 1}</span>
</pre></div>
</td></tr></table>

<p>La idea es sencilla: llamamos a la recursión para hacer la inversa del
<code>cdr</code> de la lista y añadimos el primer elemento a la lista resultante
que devuelve ya invertida la llamada recursiva.</p>
<p>Podemos definir una función auxiliar <code>(añade-al-final dato lista)</code> que
añade un dato al final de una lista usando <code>append</code>:</p>
<p>Veamos directamente su implementación, usando <code>mi-append</code> para añadir
un elemento al final de la lista:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">a</span><span class="err">ñ</span><span class="nv">ade-al-final</span> <span class="nv">dato</span> <span class="nv">lista</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">append </span><span class="nv">lista</span> <span class="p">(</span><span class="nb">list </span><span class="nv">dato</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>La función <code>mi-reverse</code> quedaría entonces como sigue:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mi-reverse</span> <span class="nv">lista</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">lista</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">()</span>
    <span class="p">(</span><span class="nf">a</span><span class="err">ñ</span><span class="nv">ade-al-final</span> <span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">)</span> <span class="p">(</span><span class="nf">mi-reverse</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)))))</span>
</pre></div>
</td></tr></table>

<h4 id="432-ejemplos-de-funciones-recursivas-que-usan-listas">4.3.2. Ejemplos de funciones recursivas que usan listas<a class="headerlink" href="#432-ejemplos-de-funciones-recursivas-que-usan-listas" title="Permanent link">&para;</a></h4>
<h5 id="funcion-cuadrados-hasta">Función <code>cuadrados-hasta</code><a class="headerlink" href="#funcion-cuadrados-hasta" title="Permanent link">&para;</a></h5>
<p>La función <code>(cuadrados-hasta x)</code> devuelve una lista con los cuadrados
de los números hasta x:</p>
<blockquote>
<p>Para construir una lista de los cuadrados hasta x, añado el cuadrado
de x a la lista de los cuadrados hasta x-1</p>
</blockquote>
<p>El caso base de la recursión es el caso en el que x es 1, entonces
devolvemos una lista formada por el 1.</p>
<p>En Scheme:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">cuadrados-hasta</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
      <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">cuadrado</span> <span class="nv">x</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">cuadrados-hasta</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)))))</span>
</pre></div>
</td></tr></table>

<p>Ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">cuadrados-hasta</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">; ⇒ {100 81 64 49 36 25 16 9 4 1}</span>
</pre></div>
</td></tr></table>

<h5 id="funcion-filtra-pares">Función <code>filtra-pares</code><a class="headerlink" href="#funcion-filtra-pares" title="Permanent link">&para;</a></h5>
<p>Es muy habitual recorrer una lista y comprobar condiciones de sus
elementos, construyendo una lista con los que cumplan una determinada
condición.</p>
<p>Por ejemplo, la siguiente función <code>filtra-pares</code> construye una lista
con los números pares de la lista que le pasamos como parámetro:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">filtra-pares</span> <span class="nv">lista</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">null? </span><span class="nv">lista</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
      <span class="p">((</span><span class="nb">even? </span><span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">))</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">)</span>
       <span class="p">(</span><span class="nf">filtra-pares</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">))))</span>
      <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">filtra-pares</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)))))</span>
</pre></div>
</td></tr></table>

<p>Ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">filtra-pares</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span> <span class="c1">; ⇒ {2 4 6}</span>
</pre></div>
</td></tr></table>

<h5 id="funcion-primo">Función <code>primo?</code><a class="headerlink" href="#funcion-primo" title="Permanent link">&para;</a></h5>
<p>El uso de listas es uno de los elementos fundamentales de la
programación funcional.</p>
<p>Como ejemplo, vamos a ver cómo trabajar con listas para construir una
función que calcula si un número es primo. La forma de hacerlo será
calcular la lista de divisores del número y comprobar si su longitud
es dos. En ese caso será primo.</p>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">divisores</span> <span class="mi">8</span><span class="p">)</span> <span class="c1">; ⇒ {1 2 4 8} longitud = 4, no primo</span>
<span class="p">(</span><span class="nf">divisores</span> <span class="mi">9</span><span class="p">)</span> <span class="c1">; ⇒ {1 3 9} longitud = 3, no primo</span>
<span class="p">(</span><span class="nf">divisores</span> <span class="mi">11</span><span class="p">)</span> <span class="c1">; ⇒ {1 11} longitud = 2, primo</span>
</pre></div>
</td></tr></table>

<p>Podemos definir entonces la función <code>(primo? x)</code> de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">primo?</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">= </span> <span class="mi">2</span> 
      <span class="p">(</span><span class="nb">length </span><span class="p">(</span><span class="nf">divisores</span> <span class="nv">x</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<p>¿Cómo implementamos la función <code>(divisores x)</code> que nos devuelve la
lista de los divisores de un número <code>x</code>. Vamos a construirla de la
siguiente forma:</p>
<ol>
<li>Creamos una lista de todos los números del 1 a x</li>
<li>Filtramos la lista para dejar los divisores de x</li>
</ol>
<p>La función <code>(lista-hasta x)</code> devuelve una lista de números 1..x:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">lista-hasta</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
      <span class="o">&#39;</span><span class="p">()</span>
      <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="p">(</span><span class="nf">lista-hasta</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)))))</span>
</pre></div>
</td></tr></table>

<p>Ejemplos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">lista-hasta</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; ⇒ {1 2}</span>
<span class="p">(</span><span class="nf">lista-hasta</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">; ⇒ {1 2 3 4 5 6 7 8 9 10}</span>
</pre></div>
</td></tr></table>

<p>Definimos la función <code>(divisor? x y)</code> que nos diga si x es divisor de
y:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">divisor?</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="p">(</span><span class="nf">mod</span> <span class="nv">y</span> <span class="nv">x</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>Ejemplos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">divisor</span> <span class="mi">2</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="nf">divisor</span> <span class="mi">3</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">; ⇒ #f</span>
</pre></div>
</td></tr></table>

<p>Una vez que hemos definido La función <code>divisor?</code> podemos utilizarla
para definir la función recursiva <code>(filtra-divisores lista x)</code> que
devuelve una lista con los números de <code>lista</code> que son divisores de
<code>x</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">filtra-divisores</span> <span class="nv">lista</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">null? </span><span class="nv">lista</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
      <span class="p">((</span><span class="nf">divisor?</span> <span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">)</span>
                                      <span class="p">(</span><span class="nf">filtra-divisores</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">filtra-divisores</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)</span> <span class="nv">x</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<p>Ya podemos implementar la función que devuelve los divisores de un
número <code>x</code> generando los números hasta <code>x</code> y filtrando los divisores
de ese número. Por ejemplo, para calcular los divisores de 10:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">filtra-divisores</span> <span class="err">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span><span class="err">}</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">; ⇒ {1 2 5 10}</span>
</pre></div>
</td></tr></table>

<p>Se puede implementar de una forma muy sencilla:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">divisores</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">filtra-divisores</span> <span class="p">(</span><span class="nf">lista-hasta</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Y una vez definida esta función, ya puede funcionar correctamente la
función <code>primo?</code>.</p>
<h3 id="44-funciones-con-numero-variable-de-argumentos"><a name="4-4"></a> 4.4. Funciones con número variable de argumentos<a class="headerlink" href="#44-funciones-con-numero-variable-de-argumentos" title="Permanent link">&para;</a></h3>
<p>Hemos visto algunas funciones primitivas de Scheme, como <code>+</code> o <code>max</code>
que admiten un número variable de argumentos. ¿Podemos hacerlo también
en funciones definidas por nosotros?</p>
<p>La respuesta es sí, utilizando lo que se denomina notación
<em>dotted-tail</em> (punto-cola) para definir los parámetros de la
función. En esta notación se coloca un punto antes del último
parámetro. Los parámetros antes del punto (si existen) tendrán como
valores los argumentos usados en la llamada y el resto de argumentos
se pasarán en forma de lista en el último parámetro.</p>
<p>Por ejemplo, si tenemos la definición</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">funcion-dos-o-mas-args</span> <span class="nv">x</span> <span class="nv">y</span> <span class="o">.</span> <span class="nv">lista-args</span><span class="p">)</span> 
    <span class="nv">&lt;cuerpo&gt;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>podemos llamar a la función anterior con dos o más argumentos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">funcion-dos-o-mas-args</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>En la llamada, los parámetros <code>x</code> e <code>y</code> tomarán los valores 1 y 2. El
parámetro <code>lista-args</code> tomará como valor una lista con los argumentos
restantes <code>(3 4 5 6)</code>.</p>
<p>También es posible permitir que todos los argumentos sean opcionales
no poniendo ningún argumento antes del punto::</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">funcion-cualquier-numero-args</span> <span class="o">.</span> <span class="nv">lista-args</span><span class="p">)</span> 
    <span class="nv">&lt;cuerpo&gt;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Si hacemos la llamada</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">funcion-cualquier-numero-args</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>el parámetro <code>lista-args</code> tomará como valor la lista <code>(1 2 3 4 5 6)</code>.</p>
<p>Veamos un sencillo ejemplo.</p>
<p>Podemos implementar una función <code>mi-suma</code> que tome al menos dos
argumentos y después un número variable de argumentos y devuelva la
suma de todos ellos. Es muy sencillo: recogemos todos los argumentos
en la lista de argumentos variables y llamamos a la función
<code>suma-lista</code> que suma una lista de números:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mi-suma</span> <span class="nv">x</span> <span class="nv">y</span> <span class="o">.</span> <span class="nv">lista-nums</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">lista-nums</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">y</span> <span class="p">(</span><span class="nf">suma-lista</span> <span class="nv">lista-nums</span><span class="p">)))))</span>
</pre></div>
</td></tr></table>

<h2 id="5-funciones-como-tipos-de-datos-de-primera-clase"><a name="5"></a>5. Funciones como tipos de datos de primera clase<a class="headerlink" href="#5-funciones-como-tipos-de-datos-de-primera-clase" title="Permanent link">&para;</a></h2>
<p>Hemos visto que la característica fundamental de la programación
funcional es la definición de funciones. Hemos visto también que no
producen efectos laterales y no tienen estado. Una función toma unos
datos como entrada y produce un resultado como salida.</p>
<p>Para simbolizar el hecho de que las funciones toman parámetros de
entrada y devuelven una única salida, vamos a representar las
funciones como un símbolo especial, una pequeña casa invertida con
unas flechas en la parte superior que representan las entradas y una
única flecha que representa la salida. Por ejemplo, podemos
representar de la siguiente forma la función que eleva al cuadrado un
número:</p>
<p><img src="imagenes/funcion-cuadrado.png" width="80px"/></p>
<p>También podemos representar la función que suma dos parejas:</p>
<p><img src="imagenes/esquema-suma-parejas.png" width="200px"/></p>
<p>Una de las características fundamentales de la programación funcional
es considerar a las funciones como <em>objetos de primera
clase</em>. Recordemos que un tipo de primera clase es aquel que:</p>
<ol>
<li>Puede ser asignado a una variable</li>
<li>Puede ser pasado como argumento a una función</li>
<li>Puede ser devuelto como resultado de una invocación a una función</li>
<li>Puede ser parte de un tipo mayor</li>
</ol>
<p>Vamos a ver que las funciones son ejemplos de todos los casos
anteriores: vamos a poder crear funciones sin nombre y asignarlas a
variables, pasarlas como parámetro de otras funciones, devolverlas
como resultado de invocar a otra función y guardarlas en
tipos de datos compuestos como listas.</p>
<p>La posibilidad de usar funciones como objetos de primera clase es una
característica fundamental de los lenguajes funcionales. Es una
característica de muchos lenguajes multi-paradigma con características
funcionales como
<a href="http://helephant.com/2008/08/19/functions-are-first-class-objects-in-javascript/">JavaScript</a>,
<a href="https://thenewcircle.com/static/bookshelf/python_fundamentals_tutorial/functional_programming.html">Python</a>,
<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html">Swift</a>
o incluso en la última versión de Java,
<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Java 8</a>,
(donde se denominan <em>expresiones lambda</em>).</p>
<h3 id="51-forma-especial-lambda"><a name="5-1"></a>5.1. Forma especial <code>lambda</code><a class="headerlink" href="#51-forma-especial-lambda" title="Permanent link">&para;</a></h3>
<p>Vamos a empezar explicando la forma especial <code>lambda</code> de Scheme, que
nos permite crear funciones anónimas en tiempo de ejecución.</p>
<p>De la misma forma que podemos usar cadenas o enteros sin darles un
nombre, en Scheme es posible usar una función sin darle un
nombre mediante esta forma especial.</p>
<h4 id="sintaxis-de-la-forma-especial-lambda">Sintaxis de la forma especial <code>lambda</code><a class="headerlink" href="#sintaxis-de-la-forma-especial-lambda" title="Permanent link">&para;</a></h4>
<p>La sintaxis de la forma especial <code>lambda</code> es:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>(lambda (&lt;arg1&gt; ... &lt;argn&gt;) 
    &lt;cuerpo&gt;)
</pre></div>
</td></tr></table>

<p>El cuerpo del lambda define un <em>bloque de código</em> y sus argumentos son
los parámetros necesarios para ejecutar ese bloque de código. Llamamos
a la función resultante una <em>función anónima</em>.</p>
<p>Algunos ejemplos:</p>
<p>Una función anónima que suma dos parejas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">p1</span> <span class="nv">p2</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">car </span><span class="nv">p1</span><span class="p">)</span> <span class="p">(</span><span class="nb">car </span><span class="nv">p2</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">p1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">p2</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<p>Una función anónima que devuelve el mayor de dos números:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
        <span class="nv">a</span>
        <span class="nv">b</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<h4 id="semantica-de-la-forma-especial-lambda">Semántica de la forma especial <code>lambda</code><a class="headerlink" href="#semantica-de-la-forma-especial-lambda" title="Permanent link">&para;</a></h4>
<p>La invocación a la forma especial <code>lambda</code> construye una función
anónima en tiempo de ejecución.</p>
<p>Por ejemplo, si ejecutamos una expresión lambda en el intérprete
veremos que devuelve un procedimiento:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span> <span class="c1">; ⇒ #&lt;procedure&gt;</span>
</pre></div>
</td></tr></table>

<p>El procedimiento construido es un bloque de código que devuelve el
cuadrado de un número.</p>
<p>¿Qué podemos hacer con este procedimiento? </p>
<p>Podemos asignarlo a un identificador. Por ejemplo, en la siguiente
expresión, primero se evalúa la <em>expresión lambda</em> y el procedimiento
resultante se asocia al identificador <code>f</code>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">f</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>El ejemplo anterior funciona de una forma idéntica al siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">x</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>En ambos casos se evalúa la expresión derecha y el resultado se guarda
en un identificador. En el primer caso la expresión que se evalúa
devuelve un procedimiento, que se guarda en la variable <code>f</code> y en el
segundo un número, que se guarda en la variable <code>x</code>.</p>
<p>Si escribimos los identificadores <code>f</code> y <code>x</code> en el intérprete Scheme los
evalúa y muestra los valores guardados:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="nv">f</span> <span class="c1">; ⇒ #&lt;procedure:f&gt;</span>
<span class="nv">x</span> <span class="c1">; ⇒ 5</span>
</pre></div>
</td></tr></table>

<p>En el primer caso se devuelve un procedimiento y en el segundo un
número. Fíjate que Scheme trata a los procedimientos y a los números
de la misma forma; son lo que se denominan datos de primera clase.</p>
<p>Una vez asignado un procedimiento a un identificador, lo podemos
utilizar como de la misma forma que invocamos habitualmente a una
función:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">f</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; ⇒ 9</span>
</pre></div>
</td></tr></table>

<p>No es necesario un identificador para invocar a una función; podemos
crear la función con una expresión lambda e invocar a la función
anónima recién creada:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; ⇒ 9</span>
</pre></div>
</td></tr></table>

<p>La llamada a <code>lambda</code> crea un procedimiento y el paréntesis a su
izquierda lo invoca con el parámetro 3:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">((</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span> <span class="mi">3</span><span class="p">)</span> <span class="nv">=</span> <span class="p">(</span><span class="o">#</span><span class="nv">&lt;procedure&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="err">⇒</span> <span class="mi">9</span>
</pre></div>
</td></tr></table>

<p>Es importante remarcar que con <code>lambda</code> estamos creando una función en
<em>tiempo de ejecución</em>. Es código que creamos para su posterior
invocación.</p>
<p>Cada lenguaje de programación tiene su sintaxis propia de expresiones
lambda. Por ejemplo, las siguientes expresiones crean una función que
devuelve el cuadrado de un número:</p>
<p><strong>Java 8</strong></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">Integer</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="o">{</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">}</span>
</pre></div>
</td></tr></table>

<p><strong>Scala</strong></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">{</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">}</span>
</pre></div>
</td></tr></table>

<p><strong>Objective C</strong></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="o">^</span><span class="kt">int</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
   <span class="n">x</span><span class="o">*</span><span class="n">x</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p><strong>Swift</strong></p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">{</span> <span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Int</span> <span class="k">in</span> <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="p">}</span>
</pre></div>
</td></tr></table>

<h4 id="identificadores-y-funciones">Identificadores y funciones<a class="headerlink" href="#identificadores-y-funciones" title="Permanent link">&para;</a></h4>
<p>Tras conocer <code>lambda</code> ya podemos explicarnos por qué cuando escribimos
en el intérprete de Scheme el nombre de una función, se evalúa a un
<em>procedure</em>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="nv">+</span> <span class="c1">; ⇒ &lt;procedure:+&gt;</span>
</pre></div>
</td></tr></table>

<p>El identificador se evalúa y devuelve el <em>objeto función</em> al que está
ligado. En Scheme los nombres de las funciones son realmente símbolos
a los que están ligados <em>objetos de tipo función</em>.</p>
<p>Podemos asignar funciones ya existentes a nuevos identificadores
usando <code>define</code>, como en el ejemplo siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="nv">+</span> <span class="c1">; ⇒ &lt;procedure:+&gt;</span>
<span class="p">(</span><span class="k">define </span><span class="nv">suma</span> <span class="nv">+</span><span class="p">)</span>
<span class="p">(</span><span class="nf">suma</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">; ⇒ 10</span>
</pre></div>
</td></tr></table>

<p>Es muy importante darse cuenta que la expresión <code>(define suma +)</code> se
evalúa de forma idéntica a <code>(define y x)</code>. Primero se evalúa el
identificador <code>+</code>, que devuelve el <em>objeto función</em> suma, que se
asigna a la variable <code>suma</code>. El resultado final es que tanto <code>+</code> como
<code>suma</code> tienen como valor el mismo procedimiento:</p>
<p><img src="imagenes/suma.png" width="100px"/></p>
<p>La forma especial <code>define</code> para definir una función no es más que
<em>azucar sintáctico</em>.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>(define (&lt;nombre&gt; &lt;args&gt;)
    &lt;cuerpo&gt;)
</pre></div>
</td></tr></table>

<p>siempre se convierte internamente en:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>(define &lt;nombre&gt; 
    (lambda (&lt;args&gt;)
        &lt;cuerpo&gt;))
</pre></div>
</td></tr></table>

<p>Por ejemplo</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">cuadrado</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>es equivalente a:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">cuadrado</span> 
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<h4 id="predicado-procedure">Predicado <code>procedure?</code><a class="headerlink" href="#predicado-procedure" title="Permanent link">&para;</a></h4>
<p>Podemos comprobar si algo es una función utilizando el predicado de
Scheme <code>procedure?</code>.</p>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">procedure? </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">)))</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="k">define </span><span class="nv">suma</span> <span class="nv">+</span><span class="p">)</span>
<span class="p">(</span><span class="nb">procedure? </span><span class="nv">suma</span><span class="p">)</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="nb">procedure? </span><span class="ss">&#39;+</span><span class="p">)</span> <span class="c1">; ⇒ #f</span>
</pre></div>
</td></tr></table>

<p>Hemos visto que las funciones pueden asignarse a variables. También
cumplen las otras condiciones necesarias para ser consideradas objetos
de primera clase.</p>
<h3 id="52-funciones-argumentos-de-otras-funciones"><a name="5-2"></a> 5.2. Funciones argumentos de otras funciones<a class="headerlink" href="#52-funciones-argumentos-de-otras-funciones" title="Permanent link">&para;</a></h3>
<p>Hemos visto ya un ejemplo de cómo pasar una función como parámetro de
otra. Veamos algún otro.</p>
<p>Por ejemplo, podemos definir la función <code>aplica</code> que recibe una
función en el parámetro <code>func</code> y dos valores en los parámetros <code>x</code> e
<code>y</code> y devuelve el resultado de invocar a la función que pasamos como
parámetro con <code>x</code> e <code>y</code>. La función que se pase como parámetro debe
tener dos argumentos</p>
<p>Para realizar la invocación a la función que se pasa como parámetro
basta con usar <code>func</code> como su nombre. La función se ha ligado al
nombre <code>func</code> en el momento de la invocación a <code>aplica</code>, de la misma
forma que los argumentos se ligan a los parámetros <code>x</code> e <code>y</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">aplica</span> <span class="nv">f</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Algunos ejemplos de invocación, usando funciones primitivas, funciones
definidas y expresiones lambda:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">aplica</span> <span class="nv">+</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; ⇒ 5</span>
<span class="p">(</span><span class="nf">aplica</span> <span class="nv">*</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">; ⇒ 10</span>
<span class="p">(</span><span class="nf">aplica</span> <span class="nv">string-append</span> <span class="s">&quot;hola&quot;</span> <span class="s">&quot;adios&quot;</span><span class="p">)</span> <span class="c1">; ⇒ &quot;holaadios&quot;</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">string-append-con-guion</span> <span class="nv">s1</span> <span class="nv">s2</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">string-append </span><span class="nv">s1</span> <span class="s">&quot;-&quot;</span> <span class="nv">s2</span><span class="p">))</span>

<span class="p">(</span><span class="nf">aplica</span> <span class="nv">string-append-con-guion</span> <span class="s">&quot;hola&quot;</span> <span class="s">&quot;adios&quot;</span><span class="p">)</span> <span class="c1">; ⇒ &quot;hola-adios&quot;</span>

<span class="p">(</span><span class="nf">aplica</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">sqrt </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">y</span> <span class="nv">y</span><span class="p">))))</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">; ⇒ 5</span>
</pre></div>
</td></tr></table>

<p>Otro ejemplo, la función <code>aplica-2</code> que toma dos funciones <code>f</code> y <code>g</code> y
un argumento <code>x</code> y devuelve el resultado de aplicar <code>f</code> a lo que
devuelve la invocación de <code>g</code> con <code>x</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">aplica-2</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">g</span> <span class="nv">x</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma-5</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">doble</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nf">aplica-2</span> <span class="nv">suma-5</span> <span class="nv">doble</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; ⇒ 11</span>
</pre></div>
</td></tr></table>

<h3 id="521-generalizacion">5.2.1. Generalización<a class="headerlink" href="#521-generalizacion" title="Permanent link">&para;</a></h3>
<p>La posibilidad de pasar funciones como parámetros de otras es una
poderosa herramienta de abstracción. Por ejemplo, supongamos que
queremos calcular el sumatorio de <code>a</code> hasta <code>b</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sum-x</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
        <span class="mi">0</span>
        <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="p">(</span><span class="nf">sum-x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">b</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">sum-x</span> <span class="mi">1</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">; ⇒ 55</span>
</pre></div>
</td></tr></table>

<p>Supongamos ahora que queremos calcular el sumatorio de <code>a</code> hasta <code>b</code>
sumando los números al cuadrado:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sum-cuadrado-x</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
        <span class="mi">0</span>
        <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">sum-cuadrado-x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">b</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">sum-cuadrado-x</span> <span class="mi">1</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">; ⇒ 385</span>
</pre></div>
</td></tr></table>

<p>Y el sumatorio de <code>a</code> hasta <code>b</code> sumando los cubos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sum-cubo-x</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
        <span class="mi">0</span>
        <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">* </span><span class="nv">a</span> <span class="nv">a</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">sum-cubo-x</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">b</span><span class="p">))))</span>

<span class="p">(</span><span class="nf">sum-cubo-x</span> <span class="mi">1</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">; ⇒ 3025</span>
</pre></div>
</td></tr></table>

<p>Vemos que el código de las tres funciones anteriores es muy similar,
cada función la podemos obtener haciendo un <em>copy-paste</em> de otra
previa. Lo único que cambia es la función a aplicar a cada número de
la serie.</p>
<p>Siempre que hagamos <em>copy-paste</em> al programar tenemos que empezar a
sospechar que no estamos generalizando suficientemente el código. Un
<em>copy-paste</em> arrastra también <em>bugs</em> y obliga a realizar múltiples
modificaciones del código cuando en el futuro tengamos que cambiar
cosas.</p>
<p>La posibilidad de pasar una función como parámetro es una herramienta
poderosa a la hora de generalizar código. En este caso, lo único que
cambia en las tres funciones anteriores es la función a aplicar a los
números de la serie. Podemos tomar esa función como un parámetro
adicional y definir una función genérica <code>sum-f-x</code> que generaliza las
tres funciones anteriores. Tendríamos el sumatorio desde <code>a</code> hasta <code>b</code>
de <code>f(x)</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">sum-f-x</span> <span class="nv">f</span> <span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
        <span class="mi">0</span>
        <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nf">f</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nf">sum-f-x</span> <span class="nv">f</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">a</span> <span class="mi">1</span><span class="p">)</span> <span class="nv">b</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<p>Las funciones anteriores son casos particulares de esta función que
las generaliza. Por ejemplo, para calcular el sumatorio desde 1 hasta
10 de <code>x</code> al cubo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">cubo</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="nf">sum-f-x</span> <span class="nv">cubo</span> <span class="mi">1</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">; ⇒ 3025</span>
</pre></div>
</td></tr></table>

<p>También podemos utilizar una expresión lambda en la invocación a
<code>sum-f</code> que construya la función que queremos aplicar a cada
número. Por ejemplo, podemos sumar la expresión (n/(n-1)) para todos
los números del 2 al 100:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">sum-f-x</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">/ </span><span class="nv">n</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))</span> <span class="mi">2</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<h3 id="53-funciones-que-devuelven-funciones"><a name="5-3"></a> 5.3. Funciones que devuelven funciones<a class="headerlink" href="#53-funciones-que-devuelven-funciones" title="Permanent link">&para;</a></h3>
<p>Cualquier objeto de primera clase puede ser devuelto por una
función; enteros, booleanos, parejas, etc. son objetos primitivos y
podemos definir funciones que los devuelven.</p>
<p>En el paradigma funcional lo mismo sucede con las funciones. Podemos
definir una función que cuando se invoque construya otra función y la
devuelva como resultado. </p>
<p>Esta es una de la características más importantes que diferencia los
lenguajes de programación funcionales de otros que no lo
son. En lenguajes como C, C++ o Java (antes de Java 8) no es posible
hacer esto.</p>
<p>Para devolver una función en Scheme basta con usar la forma especial
<code>lambda</code> en el cuerpo de una función. Así, cuando se invoca a esta
función se evalúa <code>lambda</code> y se devuelve la función resultante. Es una
función que creamos en tiempo de ejecución, durante la evaluación de
la función principal.</p>
<p>La función que se devuelve se denomina <strong>clausura</strong>
(<a href="https://es.wikipedia.org/wiki/Clausura_(informática)">Wikipedia</a>). Y
decimos que la función que ha construido la clausura es una <strong>función
constructora</strong>.</p>
<h4 id="funcion-sumador">Función <code>sumador</code><a class="headerlink" href="#funcion-sumador" title="Permanent link">&para;</a></h4>
<p>Vamos a empezar con un ejemplo muy sencillo. Definimos una función
constructora que crea en su ejecución una función que suma
<code>k</code> a un número:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">construye-sumador</span> <span class="nv">k</span><span class="p">)</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">k</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>El cuerpo de la función <code>(construye-sumador k)</code> está formado por una
expresión lambda. Cuando se invoca a <code>construye-sumador</code> se evalúa
esta expresión lambda y se devuelve el procedimiento creado. </p>
<p>En este caso se construye otra función de 1 argumento que suma <code>k</code> al
argumento. </p>
<p>Por ejemplo, podemos invocar a <code>construye-sumador</code> pasando 10 como parámetro:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">construye-sumador</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">; =&gt; #&lt;procedure&gt;</span>
</pre></div>
</td></tr></table>

<p>Como hemos dicho, se devuelve un procedimiento, una función. Esta
función devuelta debe invocarse con un argumento y devolverá el
resultado de sumar 10 a ese argumento:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">f</span> <span class="p">(</span><span class="nf">construye-sumador</span> <span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="nf">f</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; =&gt; 13</span>
</pre></div>
</td></tr></table>

<p>También podemos invocar directamente a la función que devuelve la
función constructora, sin guardarla en una variable:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">((</span><span class="nf">construye-sumador</span> <span class="mi">10</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; =&gt; 13</span>
</pre></div>
</td></tr></table>

<p>Dependiendo del parámetro que le pasemos a la función constructora
obtendremos una función sumadora que sume un número u otro. Por
ejemplo para obtener una función sumadora que suma 100:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">g</span> <span class="p">(</span><span class="nf">construye-sumador</span> <span class="mi">100</span><span class="p">))</span>
<span class="p">(</span><span class="nf">g</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; =&gt; 103</span>
</pre></div>
</td></tr></table>

<p>¿Cómo funciona la clausura? ¿Por qué la invocación a <code>(g 3)</code>
devuelve 103?.</p>
<p>Aquí hay que apartarse bastante del modelo de evaluación de
sustitución que hemos visto y utilizar un nuevo modelo en el que se
tiene en cuenta los ámbitos de las variables.</p>
<p>No vamos a explicar en detalle este modelo, pero sí dar unas breves
pinceladas.</p>
<p>Recordemos la definición de <code>construye-sumador</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">construye-sumador</span> <span class="nv">k</span><span class="p">)</span>
   <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">k</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>Y supongamos que realizamos las siguientes invocaciones:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">g</span> <span class="p">(</span><span class="nf">construye-sumador</span> <span class="mi">100</span><span class="p">))</span>
<span class="p">(</span><span class="nf">g</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; =&gt; 103</span>
</pre></div>
</td></tr></table>

<p>Podemos explicar lo que sucede en la evaluación de estas funciones de
la siguiente forma:</p>
<ul>
<li>Cuando invocamos a <code>construye-sumador</code> con un valor concreto para
  <code>k</code> (por  ejemplo 100), queda vinculado el valor de 100 al parámetro
  <code>k</code> en el ámbito local de la función.</li>
<li>En este ámbito local la expresión lambda crea una función. Esta
  función creada en el ámbito local <strong>captura</strong> este ámbito local, con
  sus variables y sus valores (en este caso la variable <code>k</code> y su valor
  100).</li>
<li>Cuando se invoca a la función desde fuera (cuando llamamos a <code>g</code> en
  el ejemplo) se ejecuta el cuerpo de la función <code>(+ x k)</code> con <code>x</code>
  valiendo el parámetro (3) y el valor de <code>k</code> se obtiene del ámbito
  capturado (100).</li>
</ul>
<p>El hecho de que función creada en el ámbito local capture este ámbito
es lo que hace que se denomine una <strong>clausura</strong> (del inglés
<strong>closure</strong>). La función <em>se cierra</em> sobre el ámbito capturado y puede
utilizar sus variables.</p>
<h4 id="funcion-componedor">Función <code>componedor</code><a class="headerlink" href="#funcion-componedor" title="Permanent link">&para;</a></h4>
<p>Otro ejemplo de una función que devuelve otra función es la función
siguiente <code>(componedor f g)</code> que recibe dos funciones de un argumento
y devuelve otra función que realiza la composición de ambas:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">componedor</span> <span class="nv">f</span> <span class="nv">g</span><span class="p">)</span>
    <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nf">g</span> <span class="nv">x</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<p>La función devuelta invoca primero a <code>g</code> y el resultado se lo pasa a
<code>f</code>. Veamos un ejemplo. Supongamos que tenemos definidas la función
<code>cuadrado</code> y <code>doble</code> que calculan el cuadrado y el doble de un número
respectivamente. Podremos entonces llamar a <code>componedor</code> con esas dos
funciones para construir otra función que primero calcule el cuadrado y
después el doble de una número:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">h</span> <span class="p">(</span><span class="nf">componendor</span> <span class="nv">doble</span> <span class="nv">cuadrado</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>La variable <code>h</code> contiene la función devuelta por <code>componedor</code>. Una
función de un argumento que devuelve el doble del cuadrado de un
número:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">h</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">; =&gt; 32</span>
</pre></div>
</td></tr></table>

<h4 id="usos-reales-de-las-funciones-constructoras">Usos reales de las funciones constructoras<a class="headerlink" href="#usos-reales-de-las-funciones-constructoras" title="Permanent link">&para;</a></h4>
<p>Las funciones que construyen otras funciones permiten un alto nivel de
configuración y de generalización en la programación.</p>
<p>Por ejemplo, un par de ejemplos de uso en problemas reales:</p>
<ol>
<li>Posibilidad de definir funciones configurables sin tener que
  depender de variables globales o parámetros adicionales.</li>
<li>Posibilidad de modificar funciones ya construidas, añadiéndoles condiciones
  a comprobar antes o cálculos a realizar después.</li>
</ol>
<h5 id="ejemplo-de-funciones-constructoras-para-definir-funciones-configurables">Ejemplo de funciones constructoras para definir funciones configurables<a class="headerlink" href="#ejemplo-de-funciones-constructoras-para-definir-funciones-configurables" title="Permanent link">&para;</a></h5>
<p>Supongamos que queremos definir una función <code>logger</code> a la que le
llamemos con una cadena para que imprima un mensaje de log.</p>
<p>Queremos poder configurar el prefijo del mensaje de log, de forma que
sólo tengamos que definirlo una vez, al crear la función
<code>logger</code>. Después llamaremos a la función <code>logger</code> pasándole
únicamente el mensaje de log.</p>
<p>Lo podemos hacer con la siguiente función constructora:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">construye-logger</span> <span class="nv">str-prefijo</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">display </span><span class="p">(</span><span class="nb">string-append </span><span class="nv">str-prefijo</span> <span class="nv">x</span> <span class="s">&quot;\n&quot;</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<p>Por ejemplo, definimos distintos loggers y los probamos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">logger</span> <span class="p">(</span><span class="nf">construye-logger</span> <span class="s">&quot;Módulo acceso red: &quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">logger</span> <span class="s">&quot;Error en el acceso a BD&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">logger</span> <span class="s">&quot;Intentando conexión a red&quot;</span><span class="p">)</span>
<span class="c1">; Módulo acceso red: Error en el acceso a BD</span>
<span class="c1">; Módulo acceso red: Intentando conexión a red</span>

<span class="p">(</span><span class="k">define </span><span class="nv">logger2</span> <span class="p">(</span><span class="nf">construye-logger</span> <span class="s">&quot;Módulo correo electrónico: &quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">logger2</span> <span class="s">&quot;Enviando e-mail&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">logger2</span> <span class="s">&quot;Problemas al recibir mensaje&quot;</span><span class="p">)</span>
<span class="c1">; Módulo correo electrónico: Enviando e-mail</span>
<span class="c1">; Módulo correo electrónico: Problemas al recibir mensaje</span>

<span class="p">(</span><span class="k">define </span><span class="nv">logger3</span> <span class="p">(</span><span class="nf">construye-logger</span> <span class="s">&quot;Módulo acceso a SO: &quot;</span><span class="p">))</span>

<span class="p">(</span><span class="nf">logger3</span> <span class="s">&quot;Intentando abrir fichero&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">logger3</span> <span class="s">&quot;Sin espacio de memoria&quot;</span><span class="p">)</span>
<span class="c1">; Módulo acceso a SO: Intentando abrir fichero</span>
<span class="c1">; Módulo acceso a SO: Sin espacio de memoria</span>
</pre></div>
</td></tr></table>

<h5 id="ejemplo-de-funciones-constructoras-para-modificar-funciones-ya-construidas">Ejemplo de funciones constructoras para modificar funciones ya construidas<a class="headerlink" href="#ejemplo-de-funciones-constructoras-para-modificar-funciones-ya-construidas" title="Permanent link">&para;</a></h5>
<p>Recordemos la función <code>divisores</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">lista-hasta</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
      <span class="o">&#39;</span><span class="p">()</span>
      <span class="p">(</span><span class="nb">cons </span><span class="nv">x</span> <span class="p">(</span><span class="nf">lista-hasta</span> <span class="p">(</span><span class="nb">- </span><span class="nv">x</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">divisor?</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="p">(</span><span class="nf">mod</span> <span class="nv">y</span> <span class="nv">x</span><span class="p">)))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">filtra-divisores</span> <span class="nv">lista</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">cond</span>
      <span class="p">((</span><span class="nb">null? </span><span class="nv">lista</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
      <span class="p">((</span><span class="nf">divisor?</span> <span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">)</span>
                                      <span class="p">(</span><span class="nf">filtra-divisores</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)</span> <span class="nv">x</span><span class="p">)))</span>
      <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">filtra-divisores</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)</span> <span class="nv">x</span><span class="p">))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">divisores</span> <span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">filtra-divisores</span> <span class="p">(</span><span class="nf">lista-hasta</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Un problema de la función anterior <code>divisores</code> es que si le pasamos un
número negativo entra en un bucle infinito.</p>
<p>Podemos definir la siguiente función general a la que le pasamos una
función de un argumento <code>f</code> y devuelve la función f "segura" a la que
sólo se va a invocar si el parámetro es mayor o igual que 0:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">construye-segura-menor-cero</span> <span class="nv">f</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)</span>
        <span class="ss">&#39;error</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>Podemos entonces "segurizar" la función <code>divisores</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">divisores-segura</span> <span class="p">(</span><span class="nf">construye-segura-menor-cero</span> <span class="nv">divisores</span><span class="p">))</span>
<span class="p">(</span><span class="nf">divisores-segura</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">; =&gt; {10 5 2 1}</span>
<span class="p">(</span><span class="nf">divisores-segura</span> <span class="mi">-10</span><span class="p">)</span> <span class="c1">; =&gt; error</span>
</pre></div>
</td></tr></table>

<p>La función <code>(construye-segura-menor-cero f)</code> se puede aplicar para
"segurizar" cualquier función, no sólo <code>divisores</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">sqrt-segura</span> <span class="p">(</span><span class="nf">construye-segura-menor-cero</span> <span class="nv">sqrt</span><span class="p">))</span>
<span class="p">(</span><span class="nf">sqrt-segura</span> <span class="mi">100</span><span class="p">)</span> <span class="c1">; =&gt; 10</span>
<span class="p">(</span><span class="nf">sqrt-segura</span> <span class="mi">-100</span><span class="p">)</span> <span class="c1">; =&gt; error</span>
</pre></div>
</td></tr></table>

<p>Se podría generalizar aún más la función "segurizadora" haciendo que
la condición a cumplir por el número sea otra función que también pasamos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">construye-segura</span> <span class="nv">condicion</span> <span class="nv">f</span><span class="p">)</span>
  <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">condicion</span> <span class="nv">x</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">f</span> <span class="nv">x</span><span class="p">)</span>
        <span class="ss">&#39;error</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>La forma de definir una función <code>divisores</code> segura con esta nueva
función sería:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">divisores-segura2</span> <span class="p">(</span><span class="nf">construye-segura</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">&gt;= </span><span class="nv">x</span> <span class="mi">0</span><span class="p">))</span> <span class="nv">divisores</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<h3 id="54-funciones-en-estructuras-de-datos"><a name="5-4"></a> 5.4. Funciones en estructuras de datos<a class="headerlink" href="#54-funciones-en-estructuras-de-datos" title="Permanent link">&para;</a></h3>
<p>La última característica de los tipos de primera clase es que pueden
formar parte de tipos de datos compuestos, como listas.</p>
<p>Para construir una lista de funciones debemos llamar a <code>list</code> con las
funciones:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">lista</span> <span class="p">(</span><span class="nb">list </span><span class="nv">cuadrado</span> <span class="nv">suma-1</span> <span class="nv">doble</span><span class="p">))</span>
<span class="nv">lista</span> <span class="c1">; ⇒ {#&lt;procedure:cuadrado&gt;  #&lt;procedure:suma-1&gt;  #&lt;procedure:doble&gt;}</span>
</pre></div>
</td></tr></table>

<p>También podemos evaluar una expresión lambda y añadir el procedimiento
resultante. Por ejemplo, para añadir otra función a la lista anterior
podemos llamar a <code>cons</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">lista2</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">5</span><span class="p">))</span> <span class="nv">lista</span><span class="p">))</span>
<span class="nv">lista2</span> <span class="c1">; ⇒ {#&lt;procedure&gt; #&lt;procedure:cuadrado&gt; #&lt;procedure:suma-1&gt; #&lt;procedure:doble&gt;}</span>
</pre></div>
</td></tr></table>

<p>Una vez creada una lista con funciones, ¿cómo podemos invocar a alguna
de ellas?. Debemos tratarlas de la misma forma que tratamos cualquier
otro dato guardado en la lista, las recuperamos con las funciones
<code>car</code> o <code>list-ref</code> y las invocamos. Por ejemplo, para invocar a la
primera función de <code>lista2</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">((</span><span class="nb">car </span><span class="nv">lista2</span><span class="p">)</span> <span class="mi">10</span><span class="p">)</span> <span class="c1">; ⇒ 15</span>
</pre></div>
</td></tr></table>

<h4 id="funciones-que-trabajan-con-listas-de-funciones">Funciones que trabajan con listas de funciones<a class="headerlink" href="#funciones-que-trabajan-con-listas-de-funciones" title="Permanent link">&para;</a></h4>
<p>Veamos un ejemplo de una función <code>(aplica-funcs lista-funcs x)</code> que
recibe una lista de funciones en el parámetro <code>lista-funcs</code> y las
aplica todas al número que pasamos en el parámetro <code>x</code>.</p>
<p>Por ejemplo, si construimos una lista con las funciones <code>cuadrado</code>,
<code>cubo</code> y <code>suma-1</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">lista</span> <span class="p">(</span><span class="nb">list </span><span class="nv">cuadrado</span> <span class="nv">cubo</span> <span class="nv">suma-1</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>la llamada a <code>(aplica-funcs lista 5)</code> debería devolver el resultado de
aplicar primero <code>suma-1</code> a 5, después <code>cubo</code> al resultado y después
<code>cuadrado</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">cuadrado</span> <span class="p">(</span><span class="nf">cubo</span> <span class="p">(</span><span class="nf">suma-1</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">; ⇒ 46656</span>
</pre></div>
</td></tr></table>

<p>Para implementar <code>aplica-funcs</code> tenemos que usar una recursión. Si
vemos el ejemplo, podemos comprobar que es sencillo definir el caso
general:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>(aplica-funcs (cuadrado cubo suma-1) 5) = (cuadrado (aplica-funcs (cubo suma-1) 5))
= (cuadrado 216) = 46656
</pre></div>
</td></tr></table>

<p>El caso general de la recursión de la función <code>aplica-funcs</code> se define
entonces como:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span>(aplica-funcs lista-funcs x) = ((car lista-funcs) (aplica-funcs (cdr lista-funcs) x))
</pre></div>
</td></tr></table>

<p>El caso base sería en el que la lista de funciones tiene sólo una
función:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="p">(</span><span class="nb">cdr </span><span class="nv">lista-funcs</span><span class="p">))</span> <span class="c1">; la lista de funciones solo tiene una función</span>
    <span class="p">((</span><span class="nb">car </span><span class="nv">lista-funcs</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span> <span class="c1">; invocamos a la función con el parámetro x</span>
    <span class="o">...</span>
</pre></div>
</td></tr></table>

<p>La implementación completa es:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">aplica-funcs</span> <span class="nv">lista-funcs</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">lista-funcs</span><span class="p">)</span>
        <span class="nv">x</span>
        <span class="p">((</span><span class="nb">car </span><span class="nv">lista-funcs</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">aplica-funcs</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista-funcs</span><span class="p">)</span> <span class="nv">x</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<p>Un ejemplo de uso:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">lista-funcs</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
                          <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
                          <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="mi">1</span><span class="p">))))</span>
<span class="p">(</span><span class="nf">aplica-funcs</span> <span class="nv">lista-funcs</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">; ⇒ 46656</span>
</pre></div>
</td></tr></table>

<h3 id="55-funciones-de-orden-superior"><a name="5-5"></a> 5.5. Funciones de orden superior<a class="headerlink" href="#55-funciones-de-orden-superior" title="Permanent link">&para;</a></h3>
<p>Llamamos funciones de orden superior (<em>higher order functions</em> en
inglés) a las funciones que toman otras como parámetro o devuelven
otra función. Permiten generalizar soluciones con un alto grado de
abstracción.</p>
<p>Los lenguajes de programación funcional como Scheme, Scala o Java 8
tienen ya predefinidas algunas funciones de orden superior que
permiten tratar listas o <em>streams</em> de una forma muy concisa y
compacta.</p>
<p>Las funciones que veremos son:</p>
<ul>
<li><code>map</code></li>
<li><code>filter</code></li>
<li><code>exists</code></li>
<li><code>for-all</code></li>
<li><code>fold-right</code> y <code>fold-left</code></li>
</ul>
<p>Para las tres primeras funciones veremos también una implementación
recursiva que nos ayudará a comprobar su funcionamiento. </p>
<p>Y después de explicar estas funciones terminaremos con un ejemplo de
su aplicación en el que comprobaremos cómo la utilización de funciones
de orden superior es una excelente herramienta de la programación
funcional que permite hacer código muy conciso y expresivo.</p>
<p>La combinación de funciones de nivel superior con listas es una de las
características más potentes de la programación funcional.</p>
<h4 id="551-funcion-map">5.5.1. Función <code>map</code><a class="headerlink" href="#551-funcion-map" title="Permanent link">&para;</a></h4>
<p>Comenzamos con la función <code>map</code>. La palabra <code>map</code> viene del inglés
<code>mapping</code> o transformación. Se trata de una función que <strong>transforma</strong>
una lista aplicando a todos sus elementos una función de
transformación que se pasa como parámetro.</p>
<p>En concreto, la función recibe otra función y una lista:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">map </span><span class="nv">funcion</span> <span class="nv">lista</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Y devuelve la lista resultante de aplicar la función a todos los
elementos de la lista.</p>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">map </span><span class="nv">cuadrado</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span> <span class="c1">; ⇒ {1 4 9 16 25}</span>
</pre></div>
</td></tr></table>

<p>La lista resultante es el resultado de construir una lista nueva
aplicando la función <code>cuadrado</code> a todos los elementos de la lista
original.</p>
<p>La función de transformación debe ser compatible con los elementos de
la lista original. Por ejemplo, si la lista es una lista de parejas,
la función de transformación debe recibir una pareja. Veamos un
ejemplo de este caso, en el que a partir de una lista de parejas
obtenemos una lista con las sumas de cada pareja:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma-pareja</span> <span class="nv">pareja</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">car </span><span class="nv">pareja</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pareja</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">map </span><span class="nv">suma-pareja</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">2</span> <span class="o">.</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="o">.</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="o">.</span> <span class="mi">3</span><span class="p">)))</span> <span class="c1">; ⇒ {6 9 8}</span>
</pre></div>
</td></tr></table>

<p>También podríamos hacerlo con una expresión lambda:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pareja</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">car </span><span class="nv">pareja</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pareja</span><span class="p">)))</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">2</span> <span class="o">.</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="o">.</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="o">.</span> <span class="mi">3</span><span class="p">)))</span> 
<span class="c1">; ⇒ {6 9 8}</span>
</pre></div>
</td></tr></table>

<p>Un último ejemplo, en el que usamos <code>map</code> para transformar una lista
de símbolos en una lista con sus longitudes:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">s</span><span class="p">)</span> 
        <span class="p">(</span><span class="nb">string-length </span><span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">s</span><span class="p">)))</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">Esta</span> <span class="nv">es</span> <span class="nv">una</span> <span class="nv">lista</span> <span class="nv">de</span> <span class="nv">s</span><span class="err">í</span><span class="nv">mbolos</span><span class="p">))</span>
<span class="c1">; =&gt; {4 2 3 5 2 8}</span>
</pre></div>
</td></tr></table>

<blockquote>
<p>CONSEJO DE USO<br />
La función <code>map</code> recibe una lista de <em>n</em> elementos y devuelve otra
de <em>n</em> elementos transformados.</p>
</blockquote>
<h5 id="implementacion-de-map">Implementación de <code>map</code><a class="headerlink" href="#implementacion-de-map" title="Permanent link">&para;</a></h5>
<p>¿Cómo se podría implementar <code>map</code> de forma recursiva? Definimos la
función <code>mi-map</code>. La implementación es la siguiente:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mi-map</span> <span class="nv">f</span> <span class="nv">lista</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">lista</span><span class="p">)</span>
        <span class="o">&#39;</span><span class="p">()</span>
        <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nf">f</span> <span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">))</span>
              <span class="p">(</span><span class="nf">mi-map</span> <span class="nv">f</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)))))</span>
</pre></div>
</td></tr></table>

<h5 id="funcion-map-con-mas-de-una-lista">Función <code>map</code> con más de una lista<a class="headerlink" href="#funcion-map-con-mas-de-una-lista" title="Permanent link">&para;</a></h5>
<p>Es posible pasar más de una lista como parámetro de la función
<code>map</code>. Todas las listas deben tener la misma longitud:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">map </span><span class="nv">f</span> <span class="nv">lista-1</span> <span class="o">...</span> <span class="nv">lista-n</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>En ese caso, la función de mapeado <code>f</code> debe tener tantos parámetros
como listas. El resultado es el mismo que antes: la función <code>f</code> coge
sus argumentos de los elementos de las listas y se devuelve la lista
con los resultados.</p>
<p>Ejemplos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">map </span><span class="nv">+</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span><span class="p">))</span> <span class="c1">; ⇒ {11 22 33}</span>
<span class="p">(</span><span class="nb">map </span><span class="nv">cons</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">10</span> <span class="mi">20</span> <span class="mi">30</span><span class="p">))</span> <span class="c1">; ⇒ {{1 . 10} {2 . 20} {3 . 30}}</span>
<span class="p">(</span><span class="nb">map </span><span class="nv">&gt;</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">12</span> <span class="mi">3</span> <span class="mi">40</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">20</span> <span class="mi">0</span> <span class="mi">10</span><span class="p">))</span> <span class="c1">; ⇒ {#f #t #t}</span>
<span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span>
        <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">12</span> <span class="mi">3</span> <span class="mi">40</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">20</span> <span class="mi">0</span> <span class="mi">10</span><span class="p">))</span> <span class="c1">; ⇒ {20 3 40}</span>
</pre></div>
</td></tr></table>

<h4 id="552-funcion-filter">5.5.2. Función <code>filter</code><a class="headerlink" href="#552-funcion-filter" title="Permanent link">&para;</a></h4>
<p>Veamos otra función de orden superior que trabaja sobre listas.</p>
<p>La función <code>(filter predicado lista)</code> toma como parámetro un predicado
y una lista y devuelve como resultado los elementos de la lista que
cumplen el predicado.</p>
<p>Un ejemplo de uso:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">filter</span> <span class="nv">even?</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span> <span class="c1">; ⇒ {2 4 6 8}</span>
</pre></div>
</td></tr></table>

<p>Otro ejemplo: supongamos que queremos filtrar una lista de parejas de
números, devolviendo aquellas que parejas que cumplen que su parte
izquierda es mayor o igual que la derecha. Lo podríamos hacer con la
siguiente expresión:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">filter</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pareja</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nb">car </span><span class="nv">pareja</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pareja</span><span class="p">)))</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">10</span> <span class="o">.</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="o">.</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">8</span> <span class="o">.</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">10</span> <span class="o">.</span> <span class="mi">20</span><span class="p">)))</span>
<span class="c1">; ⇒ {{10 . 4} {8 . 8}}</span>
</pre></div>
</td></tr></table>

<p>Y un último ejemplo: filtramos todos los símbolos con longitud menor
de 4.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">filter</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">s</span><span class="p">)</span> 
           <span class="p">(</span><span class="nb">&gt;= </span><span class="p">(</span><span class="nb">string-length </span><span class="p">(</span><span class="nb">symbol-&gt;string </span><span class="nv">s</span><span class="p">))</span> <span class="mi">4</span><span class="p">))</span>
           <span class="o">&#39;</span><span class="p">(</span><span class="nv">Esta</span> <span class="nv">es</span> <span class="nv">una</span> <span class="nv">lista</span> <span class="nv">de</span> <span class="nv">s</span><span class="err">í</span><span class="nv">mbolos</span><span class="p">))</span>
<span class="c1">; =&gt; {Esta lista símbolos}</span>
</pre></div>
</td></tr></table>

<blockquote>
<p>CONSEJO DE USO<br />
La función <code>filter</code> recibe una lista de <em>n</em> elementos y devuelve
otra de con <em>n</em> o menos elementos originales filtrados por una
condición.</p>
</blockquote>
<h5 id="implementacion-de-filter">Implementación de <code>filter</code><a class="headerlink" href="#implementacion-de-filter" title="Permanent link">&para;</a></h5>
<p>Podemos implementar la función <code>filter</code> de forma recursiva:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mi-filter</span> <span class="nv">pred</span> <span class="nv">lista</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">cond</span>
    <span class="p">((</span><span class="nb">null? </span><span class="nv">lista</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
    <span class="p">((</span><span class="nf">pred</span> <span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">))</span> <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">)</span>
                              <span class="p">(</span><span class="nf">mi-filter</span> <span class="nv">pred</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">))))</span>
    <span class="p">(</span><span class="k">else </span><span class="p">(</span><span class="nf">mi-filter</span> <span class="nv">pred</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)))))</span>
</pre></div>
</td></tr></table>

<h4 id="553-funcion-exists">5.5.3. Función <code>exists</code><a class="headerlink" href="#553-funcion-exists" title="Permanent link">&para;</a></h4>
<p>La función de orden superior <code>exists</code> recibe un predicado y una lista
y comprueba si algún elemento de la lista cumple ese predicado.</p>
<p>Ejemplo de uso:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">exists</span> <span class="nv">even?</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="nf">exists</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">&gt; </span><span class="nv">x</span> <span class="mi">10</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">8</span><span class="p">))</span> <span class="c1">; ⇒ #f</span>
</pre></div>
</td></tr></table>

<p>¿Cuál sería la implementación recursiva de la función <code>exists</code>? </p>
<h4 id="554-funcion-for-all">5.5.4. Función <code>for-all</code><a class="headerlink" href="#554-funcion-for-all" title="Permanent link">&para;</a></h4>
<p>La función de orden superior <code>for-all</code> recibe un predicado y una lista
y comprueba que todos los elementos de la lista cumplen ese predicado.</p>
<p>Ejemplo de uso:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">for-all</span> <span class="nv">even?</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">4</span> <span class="mi">6</span><span class="p">))</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="nf">for-all</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">&gt; </span><span class="nv">x</span> <span class="mi">10</span><span class="p">))</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">12</span> <span class="mi">30</span> <span class="mi">50</span> <span class="mi">80</span><span class="p">))</span> <span class="c1">; ⇒ #t</span>
</pre></div>
</td></tr></table>

<p>¿Cuál sería la implementación recursiva de la función <code>for-all</code>?</p>
<h4 id="555-funcion-fold-right">5.5.5. Función <code>fold-right</code><a class="headerlink" href="#555-funcion-fold-right" title="Permanent link">&para;</a></h4>
<p>Veamos ahora la función <code>(fold-right func base lista)</code> que permite
recorrer una lista aplicando una función binaria de forma acumulativa
a sus elementos. El nombre <code>fold</code> significa <em>plegado</em>. Utilizaremos la
función cuando necesitemos obtener un dato a partir de los elementos
de una lista.</p>
<p>La explicación de su funcionamiento es la siguiente:</p>
<p>Por ejemplo, supongamos que la función de plegado es una función que
suma dos valores.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma</span> <span class="nv">dato</span> <span class="nv">resultado</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">+ </span><span class="nv">dato</span> <span class="nv">resultado</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Llamamos a los parámetros <code>dato</code> y <code>resultado</code> para remarcar que el
primer parámetro se va a coger de la lista y el segundo del resultado
calculado.</p>
<p>Veamos qué pasa cuando hacemos un <code>fold-right</code> con esta función suma y
la lista '(1 2 3) y con el número 0 como base:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">fold-right</span> <span class="nv">suma</span> <span class="mi">0</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">; =&gt; 6</span>
</pre></div>
</td></tr></table>

<p>La función <code>suma</code> se va a ir aplicando a todos los elementos de la
lista de derecha a izquierda, empezando por el valor base (0) y el
último elemento de la lista (3) y cogiendo el resultado obtenido y
utilizándolo como nuevo parámetro <code>resultado</code> en la siguiente llamada.</p>
<p>En concreto, la secuencia de llamadas a la función <code>suma</code> serán las
siguientes:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">suma</span> <span class="mi">3</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">; =&gt; 3</span>
<span class="p">(</span><span class="nf">suma</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; =&gt; 5</span>
<span class="p">(</span><span class="nf">suma</span> <span class="mi">1</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">; =&gt; 6</span>
</pre></div>
</td></tr></table>

<p>Otro ejemplo de uso:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">fold-right</span> <span class="nv">string-append</span> <span class="s">&quot;****&quot;</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;hola&quot;</span> <span class="s">&quot;que&quot;</span> <span class="s">&quot;tal&quot;</span><span class="p">))</span> <span class="c1">; ⇒ &quot;holaquetal****&quot;</span>
</pre></div>
</td></tr></table>

<p>En este caso la secuencia de llamadas a <code>string-append</code> que se van a
producir son:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;tal&quot;</span> <span class="s">&quot;****&quot;</span><span class="p">)</span> <span class="c1">; =&gt; &quot;tal****&quot;</span>
<span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;que&quot;</span> <span class="s">&quot;tal****&quot;</span><span class="p">)</span> <span class="c1">; =&gt; &quot;quetal****&quot;</span>
<span class="p">(</span><span class="nb">string-append </span><span class="s">&quot;hola&quot;</span> <span class="s">&quot;quetal****&quot;</span><span class="p">)</span> <span class="c1">; =&gt; &quot;holaquetal****&quot;</span>
</pre></div>
</td></tr></table>

<p>Otros ejemplos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">fold-right</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="mi">1</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">))</span> <span class="c1">; ⇒ 40320</span>
<span class="p">(</span><span class="nf">fold-right</span> <span class="nv">cons</span> <span class="o">&#39;</span><span class="p">()</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; ⇒ {1 2 3 4}</span>
</pre></div>
</td></tr></table>

<p>Un último ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma-parejas</span> <span class="nv">lista-parejas</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">fold-right</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pareja</span> <span class="nv">resultado</span><span class="p">)</span>
                   <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">car </span><span class="nv">pareja</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pareja</span><span class="p">)</span> <span class="nv">resultado</span><span class="p">))</span> <span class="mi">0</span> <span class="nv">lista-parejas</span><span class="p">))</span>

<span class="p">(</span><span class="nf">suma-parejas</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">cons </span><span class="mi">3</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">2</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">-1</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">9</span> <span class="mi">3</span><span class="p">)))</span> <span class="c1">; ⇒ 39</span>
</pre></div>
</td></tr></table>

<h5 id="funcion-fold-left">Función <code>fold-left</code><a class="headerlink" href="#funcion-fold-left" title="Permanent link">&para;</a></h5>
<p>La función <code>fold-left</code> es similar a <code>fold-right</code> con la diferencia de
que la secuencia de aplicaciones de la función de plegado se hace de
izquierda a derecha en lugar de derecha a izquierda.</p>
<p>La función de plegado también cambia, porque tiene invertidos sus
argumentos:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">f</span> <span class="nv">resultado</span> <span class="nv">dato</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">fold-left</span> <span class="nv">-</span> <span class="mi">0</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span> <span class="c1">; =&gt; -6</span>
</pre></div>
</td></tr></table>

<p>La secuencia de llamadas a <code>-</code> son:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nb">- </span><span class="mi">0</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">; =&gt; -1</span>
<span class="p">(</span><span class="nb">- </span><span class="mi">-1</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">; =&gt; -3</span>
<span class="p">(</span><span class="nb">- </span><span class="mi">-3</span> <span class="mi">3</span><span class="p">)</span> <span class="c1">; =&gt; -6</span>
</pre></div>
</td></tr></table>

<blockquote>
<p>CONSEJO DE USO<br />
Las funciones <code>fold-right</code> o <code>fold-left</code> reciben una lista de datos y devuelven un único resultado</p>
</blockquote>
<h5 id="implementacion-de-fold-right-y-fold-left">Implementación de <code>fold-right</code> y <code>fold-left</code><a class="headerlink" href="#implementacion-de-fold-right-y-fold-left" title="Permanent link">&para;</a></h5>
<p>Podríamos implementar de forma recursiva la función <code>fold-right</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mi-fold-right</span> <span class="nv">func</span> <span class="nv">base</span> <span class="nv">lista</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">lista</span><span class="p">)</span>
      <span class="nv">base</span>
      <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">)</span> <span class="p">(</span><span class="nf">mi-fold-right</span> <span class="nv">func</span> <span class="nv">base</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)))))</span>
</pre></div>
</td></tr></table>

<p>Y la función <code>fold-left</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">mi-fold-left</span> <span class="nv">func</span> <span class="nv">base</span> <span class="nv">lista</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">lista</span><span class="p">)</span>
      <span class="nv">base</span>
      <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nf">mi-fold-left</span> <span class="nv">func</span> <span class="nv">base</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">))</span> <span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<h4 id="556-uso-de-funciones-de-orden-superior">5.5.6. Uso de funciones de orden superior<a class="headerlink" href="#556-uso-de-funciones-de-orden-superior" title="Permanent link">&para;</a></h4>
<p>El uso de funciones de orden superior y las expresiones lambda
proporciona muchísima expresividad en un lenguaje de programación. Es
posible escribir código muy conciso, que hace cosas complicadas en
pocas líneas.</p>
<h5 id="funcion-suma-n-n-lista">Función <code>(suma-n n lista)</code><a class="headerlink" href="#funcion-suma-n-n-lista" title="Permanent link">&para;</a></h5>
<p>Como hemos visto en las clausuras, es posible utilizar en el cuerpo de
las expresiones lambda los parámetros de la función principal en la
que se usa esta expresión. Veamos un ejemplo.</p>
<p>Supongamos que queremos definir una función <code>(suma-n n lista)</code> que
devuelve la lista resultante el resultado de sumar un número <code>n</code> a
todos los elementos de una lista.</p>
<p>Podemos hacerlo de forma recursiva:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma-n</span> <span class="nv">n</span> <span class="nv">lista</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">null? </span><span class="nv">lista</span><span class="p">)</span>
        <span class="o">&#39;</span><span class="p">()</span>
        <span class="p">(</span><span class="nb">cons </span><span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">car </span><span class="nv">lista</span><span class="p">)</span> <span class="nv">n</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">suma-n</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">lista</span><span class="p">)))))</span>
</pre></div>
</td></tr></table>

<p>Funciona de la siguiente manera:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">suma-n</span> <span class="mi">10</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="c1">; ⇒ (11 12 13 14)</span>
</pre></div>
</td></tr></table>

<p><strong>Implementacion con <code>map</code></strong></p>
<p>Pero si utilizamos funciones de orden superior, podemos implementar la
misma función de una forma mucho más concisa y expresiva. </p>
<p>Lo podemos hacer utilizando la función de orden superior <code>map</code> y una
expresión lambda que sume el número <code>n</code> a los elementos de la lista:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma-n</span> <span class="nv">n</span> <span class="nv">lista</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">n</span><span class="p">))</span> <span class="nv">lista</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>Vemos que utilizamos el parámetro <code>n</code> en el cuerpo de la expresión
lambda. De esta forma la función que se aplica a los elementos de la
lista es una función que suma este número a cada elemento. La variable
<code>x</code> en el parámetro de la expresión lambda es la que va tomando el
valor de los elementos de la lista.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">suma-n</span> <span class="mi">10</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">10</span><span class="p">)</span> <span class="k">=&gt; </span><span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="nv">&lt;prodedure-que-suma-10-a-x&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span> <span class="nv">=</span>  <span class="p">(</span><span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<h5 id="composicion-de-funciones-de-orden-superior">Composición de funciones de orden superior<a class="headerlink" href="#composicion-de-funciones-de-orden-superior" title="Permanent link">&para;</a></h5>
<p>Dado que muchas de las anteriores funciones de orden superior
devuelven listas, es muy común componer las llamadas, de forma que la
salida de una haga de entrada de otra.</p>
<p>Por ejemplo, podemos implementar una función que sume un número
<code>n</code> a todos los elementos de una lista (igual que la anterior) y
después que sume todos los elementos resultantes.</p>
<p>Lo podríamos hacer reutilizando el código del ejemplo anterior, y
añadiendo una llamada a <code>fold-right</code> para que haga la suma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">suma-n-total</span> <span class="nv">n</span> <span class="nv">lista</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">fold-right</span> <span class="nv">+</span> <span class="mi">0</span>
       <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">n</span><span class="p">))</span> <span class="nv">lista</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>Funcionaría de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">suma-n-total</span> <span class="mi">100</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>  <span class="k">=&gt; </span><span class="mi">410</span>
</pre></div>
</td></tr></table>

<p>Otro ejemplo. Supongamos que tenemos una lista de parejas de números y
queremos contar aquellas parejas cuya suma de ambos números es mayor
que un umbral (por ejemplo, 10).</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="nv">lista-parejas</span> <span class="p">(</span><span class="nb">list </span><span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> 
                            <span class="p">(</span><span class="nb">cons </span><span class="mi">3</span> <span class="mi">8</span><span class="p">)</span> 
                            <span class="p">(</span><span class="nb">cons </span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> 
                            <span class="p">(</span><span class="nb">cons </span><span class="mi">9</span> <span class="mi">6</span><span class="p">)))</span>
<span class="p">(</span><span class="nf">cuenta-mayores-que</span> <span class="mi">10</span> <span class="nv">lista-parejas</span><span class="p">)</span> <span class="c1">; =&gt; 2</span>
</pre></div>
</td></tr></table>

<p>Se podría implementar de una forma muy concisa componiendo una llamada
a <code>map</code> para realizar la suma de cada pareja junto con una llamada a
<code>filter</code> que compruebe que el resultado sea mayor de <code>n</code>. Y al final
llamamos a <code>length</code> para contar la longitud de la lista resultante:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">cuenta-mayores-que</span> <span class="nv">n</span> <span class="nv">lista-parejas</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">length</span>
   <span class="p">(</span><span class="nf">filter</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">&gt; </span><span class="nv">x</span> <span class="nv">n</span><span class="p">))</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pareja</span><span class="p">)</span>
                             <span class="p">(</span><span class="nb">+ </span><span class="p">(</span><span class="nb">car </span><span class="nv">pareja</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr </span><span class="nv">pareja</span><span class="p">)))</span> <span class="nv">lista-parejas</span><span class="p">))))</span>
</pre></div>
</td></tr></table>

<h5 id="funcion-contienen-letra-caracter-lista-pal">Función <code>(contienen-letra caracter lista-pal)</code><a class="headerlink" href="#funcion-contienen-letra-caracter-lista-pal" title="Permanent link">&para;</a></h5>
<p>Veamos otro ejemplo. Supongamos que queremos definir la función
<code>(contienen-letra caracter lista-pal)</code> que devuelve las palabras de
una lista que contienen un determinado carácter.</p>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">contienen-letra</span> <span class="sc">#\a</span> <span class="o">&#39;</span><span class="p">(</span><span class="s">&quot;En&quot;</span> <span class="s">&quot;un&quot;</span> <span class="s">&quot;lugar&quot;</span> <span class="s">&quot;de&quot;</span> <span class="s">&quot;la&quot;</span> <span class="s">&quot;Mancha&quot;</span><span class="p">))</span> <span class="err">⇒</span> <span class="p">(</span><span class="s">&quot;lugar&quot;</span> <span class="s">&quot;la&quot;</span> <span class="s">&quot;Mancha&quot;</span><span class="p">)</span>
</pre></div>
</td></tr></table>

<p>Podemos implementar <code>contienen-letra</code> usando la función de orden
superior <code>filter</code>, con una expresión lambda que se aplicará a cada una
de las palabras de la lista para comprobar si la palabra contiene el
carácter:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">contienen-letra</span> <span class="nv">caracter</span> <span class="nv">lista-pal</span><span class="p">)</span>
   <span class="p">(</span><span class="nf">filter</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">pal</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">letra-en-pal?</span> <span class="nv">caracter</span> <span class="nv">pal</span><span class="p">))</span> <span class="nv">lista-pal</span><span class="p">))</span>
</pre></div>
</td></tr></table>

<p>El parámetro <code>pal</code> de la expresión lambda irá cogiendo el valor de
todas las palabras de <code>lista-pal</code> y la función <code>(letra-en-pal?
caracter pal)</code> comprobará si la cadena contiene el carácter.</p>
<p>La función <code>(letra-en-pal? caracter pal)</code> es una función auxiliar que
tenemos que implementar.</p>
<p>Por ejemplo:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="nf">letra-en-pal?</span> <span class="sc">#\a</span> <span class="s">&quot;Hola&quot;</span><span class="p">)</span> <span class="c1">; ⇒ #t</span>
<span class="p">(</span><span class="nf">letra-en-pal?</span> <span class="sc">#\a</span> <span class="s">&quot;Pepe&quot;</span><span class="p">)</span> <span class="c1">; ⇒ #f</span>
</pre></div>
</td></tr></table>

<p>La podemos implementar de una forma muy elegante obteniendo una lista
de caracteres a partir de la cadena y usando la función de orden
superior <code>exists</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">letra-en-pal?</span> <span class="nv">caracter</span> <span class="nv">palabra</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">exists</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">c</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">equal? </span><span class="nv">c</span> <span class="nv">caracter</span><span class="p">))</span> <span class="p">(</span><span class="nb">string-&gt;list </span><span class="nv">palabra</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<h5 id="funcion-divisores">Función divisores<a class="headerlink" href="#funcion-divisores" title="Permanent link">&para;</a></h5>
<p>Un último ejemplo en el que implementamos la función <code>(divisores n)</code>
utilizando una función de orden superior.</p>
<p>Suponemos que tenemos definidas las funciones <code>(numeros-hasta n)</code> y
<code>(divisor? x n)</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">numeros-hasta</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="nv">n</span><span class="p">)</span>
      <span class="o">&#39;</span><span class="p">()</span>
      <span class="p">(</span><span class="nb">cons </span><span class="nv">n</span> <span class="p">(</span><span class="nf">numeros-hasta</span> <span class="p">(</span><span class="nb">- </span><span class="nv">n</span> <span class="mi">1</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">divisor?</span> <span class="nv">x</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="p">(</span><span class="nf">mod</span> <span class="nv">n</span> <span class="nv">x</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<p>Entonces la función <code>(divisores n)</code> se implementaría de la siguiente forma:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="p">(</span><span class="k">define </span><span class="p">(</span><span class="nf">divisores</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">filter</span> <span class="p">(</span><span class="k">lambda </span><span class="p">(</span><span class="nf">x</span><span class="p">)</span>
            <span class="p">(</span><span class="nf">divisor?</span> <span class="nv">x</span> <span class="nv">n</span><span class="p">))</span> <span class="p">(</span><span class="nf">numeros-hasta</span> <span class="nv">n</span><span class="p">)))</span>
</pre></div>
</td></tr></table>

<hr />
<p>Lenguajes y Paradigmas de Programación, curso 2017-18<br />
© Departamento Ciencia de la Computación e Inteligencia Artificial, Universidad de Alicante<br />
Domingo Gallardo, Cristina Pomares, Antonio Botía, Francisco Martínez</p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
        
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.583bbe55.js"></script>
      
        
        
          
          <script src="../../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
              
              
                <script src="../../assets/javascripts/lunr/lunr.es.js"></script>
              
            
          
          
        
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
    
    
      
    
  </body>
</html>